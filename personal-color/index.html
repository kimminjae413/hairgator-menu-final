<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HAIRGATOR Personal Color</title>
    
    <!-- MediaPipe CDN -->
    <script crossorigin="anonymous" src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script crossorigin="anonymous" src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script crossorigin="anonymous" src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script crossorigin="anonymous" src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <!-- ë¡œë”© í™”ë©´ -->
    <div class="loading-screen" id="loading-screen">
        <div class="loading-content">
            <div class="loading-logo">ğŸ¨</div>
            <h2>HAIRGATOR Personal Color</h2>
            <p id="loading-text">ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì¤‘...</p>
            <div class="loading-progress">
                <div class="loading-bar" id="loading-bar"></div>
            </div>
        </div>
    </div>

    <!-- ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ -->
    <div class="main-app" id="main-app">
        <header class="app-header">
            <div class="header-content">
                <div class="app-title-section">
                    <h1 class="app-title">HAIRGATOR Personal Color</h1>
                    <div class="app-subtitle">AI ê¸°ë°˜ í¼ìŠ¤ë„ì»¬ëŸ¬ ì§„ë‹¨ ì‹œìŠ¤í…œ</div>
                </div>
            </div>
        </header>

        <main class="main-content">
            <!-- ëª¨ë“œ ì„ íƒ ì„¹ì…˜ -->
            <section class="section active" id="mode-selection">
                <h2 class="mode-title">í¼ìŠ¤ë„ì»¬ëŸ¬ ì§„ë‹¨ ë°©ë²•ì„ ì„ íƒí•˜ì„¸ìš”</h2>
                
                <div class="mode-cards">
                    <div class="mode-card" onclick="selectMode('ai')">
                        <span class="mode-icon">ğŸ¤–</span>
                        <h3 class="mode-card-title">AI í¼ìŠ¤ë„ì»¬ëŸ¬ ë¶„ì„</h3>
                        <p class="mode-description">
                            ê³¼í•™ì  AI ê¸°ìˆ ë¡œ ì–¼êµ´ì„ ë¶„ì„í•˜ì—¬ ì •í™•í•œ í¼ìŠ¤ë„ì»¬ëŸ¬ë¥¼ ì§„ë‹¨í•©ë‹ˆë‹¤. 
                            MediaPipe ì–¼êµ´ ì¸ì‹ê³¼ ì‹¤ì œ Delta E 2000 ìƒ‰ì°¨ ì¸¡ì •ì„ í™œìš©í•©ë‹ˆë‹¤.
                        </p>
                        <ul class="mode-features">
                            <li>468í¬ì¸íŠ¸ ì‹¤ì‹œê°„ ì–¼êµ´ ì¸ì‹</li>
                            <li>15x15 í”½ì…€ ë‹¤ì¤‘ ì˜ì—­ í”¼ë¶€í†¤ ì¶”ì¶œ</li>
                            <li>LAB ìƒ‰ê³µê°„ ê¸°ë°˜ ì •ë°€ ë¶„ì„</li>
                            <li>Delta E 2000 ìƒ‰ì°¨ ê³„ì‚°</li>
                            <li>624ê°œ í—¤ì–´ì»¬ëŸ¬ì™€ ìë™ ë§¤ì¹­</li>
                        </ul>
                        <button class="mode-btn">AI ë¶„ì„ ì‹œì‘</button>
                    </div>
                    
                    <div class="mode-card" onclick="selectMode('draping')">
                        <span class="mode-icon">ğŸ­</span>
                        <h3 class="mode-card-title">ì „ë¬¸ê°€ ë“œë˜ì´í•‘ ëª¨ë“œ</h3>
                        <p class="mode-description">
                            ì „ë¬¸ê°€ ë…¸í•˜ìš°ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì‹¤ì‹œê°„ ë“œë˜ì´í•‘ì„ í†µí•´ 
                            ê°€ì¥ ì–´ìš¸ë¦¬ëŠ” í—¤ì–´ì»¬ëŸ¬ë¥¼ ì§ì ‘ í™•ì¸í•´ë³´ì„¸ìš”.
                        </p>
                        <ul class="mode-features">
                            <li>ì‹¤ì‹œê°„ ì¹´ë©”ë¼ ë“œë˜ì´í•‘</li>
                            <li>4ê³„ì ˆ ìƒ‰ìƒ íŒ”ë ˆíŠ¸ ì œê³µ</li>
                            <li>Before/After ì¦‰ì‹œ ë¹„êµ</li>
                            <li>ë¸Œëœë“œë³„ ì œí’ˆ ì¶”ì²œ</li>
                        </ul>
                        <button class="mode-btn">ë“œë˜ì´í•‘ ì‹œì‘</button>
                    </div>
                </div>
            </section>

            <!-- AI ë¶„ì„ ëª¨ë“œ -->
            <section class="section" id="ai-analysis">
                <div class="section-nav">
                    <button class="nav-btn" onclick="goHome()">â† í™ˆìœ¼ë¡œ</button>
                    <h2 class="section-title">AI í¼ìŠ¤ë„ì»¬ëŸ¬ ë¶„ì„</h2>
                </div>
                
                <div class="analysis-grid">
                    <!-- ì¹´ë©”ë¼ ì˜ì—­ -->
                    <div class="camera-container">
                        <div class="video-container">
                            <video id="ai-camera" autoplay muted playsinline></video>
                            <canvas id="ai-face-overlay"></canvas>
                            <div class="face-guide" id="ai-face-guide">
                                ì–¼êµ´ì„ ê°€ì´ë“œë¼ì¸ì—<br>ë§ì¶°ì£¼ì„¸ìš”
                            </div>
                        </div>
                        <div class="camera-controls">
                            <button class="control-btn" onclick="startAICamera()">ì¹´ë©”ë¼ ì‹œì‘</button>
                            <button class="control-btn" onclick="analyzeAI()">AI ë¶„ì„</button>
                            <button class="control-btn" onclick="stopAICamera()">ì •ì§€</button>
                        </div>
                    </div>
                    
                    <!-- ë¶„ì„ íŒ¨ë„ -->
                    <div class="analysis-panel">
                        <h3>AI ë¶„ì„ ì§„í–‰ìƒí™©</h3>
                        <div class="analysis-steps">
                            <div class="analysis-step" id="ai-step-1">
                                <div class="step-number">1</div>
                                <div class="step-content">
                                    <h4>ì–¼êµ´ ì¸ì‹</h4>
                                    <p>MediaPipeë¡œ 468í¬ì¸íŠ¸ ê°ì§€</p>
                                </div>
                            </div>
                            
                            <div class="analysis-step" id="ai-step-2">
                                <div class="step-number">2</div>
                                <div class="step-content">
                                    <h4>í”¼ë¶€í†¤ ë¶„ì„</h4>
                                    <p>ë‹¤ì¤‘ ì˜ì—­ RGB â†’ LAB ë³€í™˜</p>
                                </div>
                            </div>
                            
                            <div class="analysis-step" id="ai-step-3">
                                <div class="step-number">3</div>
                                <div class="step-content">
                                    <h4>Delta E ê³„ì‚°</h4>
                                    <p>CIE 2000 í‘œì¤€ ìƒ‰ì°¨ ì¸¡ì •</p>
                                </div>
                            </div>
                            
                            <div class="analysis-step" id="ai-step-4">
                                <div class="step-number">4</div>
                                <div class="step-content">
                                    <h4>ê²°ê³¼ ìƒì„±</h4>
                                    <p>ê³¼í•™ì  ë¶„ì„ ê¸°ë°˜ ìµœì¢… ì§„ë‹¨</p>
                                </div>
                            </div>
                        </div>
                        
                        <div class="analysis-results" id="ai-analysis-results" style="display: none;">
                            <h4>ë¶„ì„ ê²°ê³¼</h4>
                            <div class="result-summary">
                                <div class="season-result" id="ai-season-result">ë¶„ì„ ì¤‘...</div>
                                <div class="confidence-score" id="ai-confidence">-</div>
                            </div>
                            <div class="color-analysis-data" id="ai-analysis-data">
                                <!-- ìƒì„¸ ë°ì´í„°ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤ -->
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- ë“œë˜ì´í•‘ ëª¨ë“œ -->
            <section class="section" id="draping-mode">
                <div class="section-nav">
                    <button class="nav-btn" onclick="goHome()">â† í™ˆìœ¼ë¡œ</button>
                    <h2 class="section-title">ì „ë¬¸ê°€ ë“œë˜ì´í•‘ ëª¨ë“œ</h2>
                </div>
                
                <div class="draping-layout">
                    <!-- ë“œë˜ì´í•‘ ì¹´ë©”ë¼ -->
                    <div class="draping-camera-section">
                        <div class="video-container">
                            <video id="draping-camera" autoplay muted playsinline></video>
                            <canvas id="draping-overlay"></canvas>
                            <div class="face-guide" id="draping-face-guide">
                                ì–¼êµ´ì„ ê°€ì´ë“œë¼ì¸ì—<br>ë§ì¶°ì£¼ì„¸ìš”
                            </div>
                        </div>
                        
                        <div class="camera-controls">
                            <button class="control-btn" onclick="startDrapingCamera()">ì¹´ë©”ë¼ ì‹œì‘</button>
                            <button class="control-btn" onclick="saveCurrentColor()">í˜„ì¬ ìƒ‰ìƒ ì €ì¥</button>
                        </div>
                    </div>
                    
                    <!-- ìƒ‰ìƒ íŒ”ë ˆíŠ¸ -->
                    <div class="color-palette-section">
                        <h3>4ê³„ì ˆ ìƒ‰ìƒ íŒ”ë ˆíŠ¸</h3>
                        
                        <!-- ê³„ì ˆ íƒ­ -->
                        <div class="season-tabs">
                            <button class="season-tab active" data-season="spring" onclick="selectSeason('spring')">ë´„</button>
                            <button class="season-tab" data-season="summer" onclick="selectSeason('summer')">ì—¬ë¦„</button>
                            <button class="season-tab" data-season="autumn" onclick="selectSeason('autumn')">ê°€ì„</button>
                            <button class="season-tab" data-season="winter" onclick="selectSeason('winter')">ê²¨ìš¸</button>
                        </div>
                        
                        <!-- ìƒ‰ìƒ ê·¸ë¦¬ë“œ -->
                        <div class="color-grid" id="color-grid">
                            <!-- ë™ì ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤ -->
                        </div>
                        
                        <!-- ì„¸ë¶€ ì¡°ì • -->
                        <div class="color-adjustments">
                            <h4>ìƒ‰ìƒ ì„¸ë¶€ ì¡°ì •</h4>
                            
                            <div class="adjustment-slider">
                                <label>ëª…ë„</label>
                                <input type="range" id="lightness-slider" min="-30" max="30" value="0" oninput="adjustColor()">
                                <span id="lightness-value">0</span>
                            </div>
                            
                            <div class="adjustment-slider">
                                <label>ì±„ë„</label>
                                <input type="range" id="saturation-slider" min="-50" max="50" value="0" oninput="adjustColor()">
                                <span id="saturation-value">0</span>
                            </div>
                            
                            <div class="adjustment-slider">
                                <label>ì˜¨ë„ê°</label>
                                <input type="range" id="warmth-slider" min="-40" max="40" value="0" oninput="adjustColor()">
                                <span id="warmth-value">0</span>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- ê³µí†µ ê²°ê³¼ ì„¹ì…˜ -->
            <div class="results-section" id="results-section" style="display: none;">
                <h3>í¼ìŠ¤ë„ì»¬ëŸ¬ ì§„ë‹¨ ê²°ê³¼</h3>
                <div class="final-results" id="final-results">
                    <!-- ê²°ê³¼ ë‚´ìš©ì´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤ -->
                </div>
                
                <div class="product-recommendations" id="product-recommendations">
                    <h4>ì¶”ì²œ í—¤ì–´ì»¬ëŸ¬ ì œí’ˆ</h4>
                    <div class="brand-sections" id="brand-sections">
                        <!-- ë¸Œëœë“œë³„ ì œí’ˆ ì¶”ì²œì´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤ -->
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // ========================================
        // ì „ì—­ ë³€ìˆ˜ ì •ì˜
        // ========================================
        let currentMode = null;
        let analysisInProgress = false;
        let faceDetected = false;
        let hairColorData = [];
        let videoElement = null;
        let canvasElement = null;
        let canvasCtx = null;
        let currentSeason = 'spring';
        let selectedColor = null;
        let savedColors = [];
        let activeVideoStream = null;
        let mediaPipeCamera = null;
        let faceDetectionInstance = null;
        let sharedExtractCanvas = null;
        let sharedExtractCtx = null;
        let scientificAnalyzer = null;
        
        // ========================================
        // ê³¼í•™ì  í¼ìŠ¤ë„ì»¬ëŸ¬ ë¶„ì„ê¸° í´ë˜ìŠ¤
        // ========================================
        class ScientificPersonalColorAnalyzer {
            constructor() {
                // í•™ìˆ  ì—°êµ¬ ê¸°ë°˜ ê¸°ì¤€ê°’ë“¤ (L*a*b* ìƒ‰ê³µê°„)
                this.seasonReferences = {
                    spring: { L: 67.58, a: 8.91, b: 14.81, undertone: 'warm' },
                    summer: { L: 67.92, a: 9.23, b: 11.70, undertone: 'cool' },
                    autumn: { L: 62.09, a: 10.20, b: 16.54, undertone: 'warm' },
                    winter: { L: 61.41, a: 12.46, b: 12.54, undertone: 'cool' }
                };
            }

            // ì •í™•í•œ í”¼ë¶€ìƒ‰ ì¶”ì¶œ (ì—¬ëŸ¬ ì˜ì—­ ê°€ì¤‘ í‰ê· )
            extractSkinColor(landmarks, videoElement) {
                if (!landmarks || landmarks.length < 468) {
                    throw new Error('ì¶©ë¶„í•œ ì–¼êµ´ ëœë“œë§ˆí¬ê°€ í•„ìš”í•©ë‹ˆë‹¤');
                }

                // í”¼ë¶€ìƒ‰ ì¶”ì¶œì„ ìœ„í•œ ì£¼ìš” ì˜ì—­ë“¤ (ê°€ì¤‘ì¹˜ ì ìš©)
                const skinRegions = [
                    { indices: [9, 10, 151], weight: 0.3, name: 'ì´ë§ˆì¤‘ì•™' },
                    { indices: [116, 117, 118], weight: 0.25, name: 'ì¢Œì¸¡ë³¼' },
                    { indices: [345, 346, 347], weight: 0.25, name: 'ìš°ì¸¡ë³¼' },
                    { indices: [175, 176, 199], weight: 0.15, name: 'í„±' },
                    { indices: [19, 20, 94], weight: 0.05, name: 'ì½”ì˜†' }
                ];

                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d', { willReadFrequently: true });
                canvas.width = videoElement.videoWidth;
                canvas.height = videoElement.videoHeight;
                ctx.drawImage(videoElement, 0, 0);

                let totalR = 0, totalG = 0, totalB = 0, totalWeight = 0;
                const regionData = [];

                skinRegions.forEach(region => {
                    let regionR = 0, regionG = 0, regionB = 0, regionSamples = 0;
                    
                    region.indices.forEach(landmarkIndex => {
                        const landmark = landmarks[landmarkIndex];
                        const centerX = Math.floor(landmark.x * canvas.width);
                        const centerY = Math.floor(landmark.y * canvas.height);
                        
                        // 15x15 í”½ì…€ ì˜ì—­ì—ì„œ ìƒ˜í”Œë§ (ê¸°ì¡´ 5x5ë³´ë‹¤ í™•ì¥)
                        for (let dx = -7; dx <= 7; dx++) {
                            for (let dy = -7; dy <= 7; dy++) {
                                const x = Math.max(0, Math.min(canvas.width - 1, centerX + dx));
                                const y = Math.max(0, Math.min(canvas.height - 1, centerY + dy));
                                
                                const imageData = ctx.getImageData(x, y, 1, 1);
                                const [r, g, b] = imageData.data;
                                
                                // ê·¹ë‹¨ê°’ í•„í„°ë§
                                const brightness = (r + g + b) / 3;
                                if (brightness > 30 && brightness < 240) {
                                    regionR += r;
                                    regionG += g;
                                    regionB += b;
                                    regionSamples++;
                                }
                            }
                        }
                    });
                    
                    if (regionSamples > 0) {
                        const avgR = regionR / regionSamples;
                        const avgG = regionG / regionSamples;
                        const avgB = regionB / regionSamples;
                        
                        regionData.push({
                            name: region.name,
                            rgb: { r: avgR, g: avgG, b: avgB },
                            weight: region.weight,
                            samples: regionSamples
                        });
                        
                        totalR += avgR * region.weight;
                        totalG += avgG * region.weight;
                        totalB += avgB * region.weight;
                        totalWeight += region.weight;
                    }
                });

                if (totalWeight === 0) {
                    throw new Error('ìœ íš¨í•œ í”¼ë¶€ìƒ‰ ë°ì´í„°ë¥¼ ì¶”ì¶œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                }

                return {
                    rgb: {
                        r: Math.round(totalR / totalWeight),
                        g: Math.round(totalG / totalWeight),
                        b: Math.round(totalB / totalWeight)
                    },
                    regionData: regionData,
                    totalSamples: regionData.reduce((sum, region) => sum + region.samples, 0)
                };
            }

            // RGBë¥¼ L*a*b* ìƒ‰ê³µê°„ìœ¼ë¡œ ë³€í™˜
            rgbToLab(r, g, b) {
                // 1. RGBë¥¼ XYZë¡œ ë³€í™˜
                let rNorm = r / 255.0;
                let gNorm = g / 255.0;
                let bNorm = b / 255.0;

                // Gamma correction
                rNorm = rNorm > 0.04045 ? Math.pow((rNorm + 0.055) / 1.055, 2.4) : rNorm / 12.92;
                gNorm = gNorm > 0.04045 ? Math.pow((gNorm + 0.055) / 1.055, 2.4) : gNorm / 12.92;
                bNorm = bNorm > 0.04045 ? Math.pow((bNorm + 0.055) / 1.055, 2.4) : bNorm / 12.92;

                // Observer: 2Â°, Illuminant: D65
                const x = rNorm * 0.4124564 + gNorm * 0.3575761 + bNorm * 0.1804375;
                const y = rNorm * 0.2126729 + gNorm * 0.7151522 + bNorm * 0.0721750;
                const z = rNorm * 0.0193339 + gNorm * 0.1191920 + bNorm * 0.9503041;

                // 2. XYZë¥¼ LABë¡œ ë³€í™˜
                const xn = 0.95047;  // D65 reference white
                const yn = 1.00000;
                const zn = 1.08883;

                const fx = this.labF(x / xn);
                const fy = this.labF(y / yn);
                const fz = this.labF(z / zn);

                const L = 116 * fy - 16;
                const a = 500 * (fx - fy);
                const b_val = 200 * (fy - fz);

                return { L: L, a: a, b: b_val };
            }

            // LAB ë³€í™˜ ë³´ì¡° í•¨ìˆ˜
            labF(t) {
                const delta = 6.0 / 29.0;
                return t > Math.pow(delta, 3) ? Math.pow(t, 1.0 / 3.0) : (t / (3 * delta * delta) + 4.0 / 29.0);
            }

            // Delta E 2000 ê³„ì‚° (CIE 2000 í‘œì¤€)
            calculateDeltaE2000(lab1, lab2) {
                const L1 = lab1.L, a1 = lab1.a, b1 = lab1.b;
                const L2 = lab2.L, a2 = lab2.a, b2 = lab2.b;

                // Calculate C and h
                const C1 = Math.sqrt(a1 * a1 + b1 * b1);
                const C2 = Math.sqrt(a2 * a2 + b2 * b2);
                const Cab = (C1 + C2) / 2.0;

                const G = 0.5 * (1 - Math.sqrt(Math.pow(Cab, 7) / (Math.pow(Cab, 7) + Math.pow(25, 7))));

                const ap1 = (1 + G) * a1;
                const ap2 = (1 + G) * a2;

                const Cp1 = Math.sqrt(ap1 * ap1 + b1 * b1);
                const Cp2 = Math.sqrt(ap2 * ap2 + b2 * b2);

                let hp1 = Math.atan2(b1, ap1) * 180 / Math.PI;
                if (hp1 < 0) hp1 += 360;

                let hp2 = Math.atan2(b2, ap2) * 180 / Math.PI;
                if (hp2 < 0) hp2 += 360;

                // Calculate differences
                const dL = L2 - L1;
                const dC = Cp2 - Cp1;

                let dhp = hp2 - hp1;
                if (Math.abs(dhp) > 180) {
                    if (hp2 > hp1) dhp -= 360;
                    else dhp += 360;
                }

                const dH = 2 * Math.sqrt(Cp1 * Cp2) * Math.sin(dhp * Math.PI / 360);

                // Calculate means
                const Lm = (L1 + L2) / 2;
                const Cm = (Cp1 + Cp2) / 2;
                let Hm = (hp1 + hp2) / 2;

                if (Math.abs(hp1 - hp2) > 180) {
                    if (hp1 + hp2 < 360) Hm += 180;
                    else Hm -= 180;
                }

                const T = 1 - 0.17 * Math.cos((Hm - 30) * Math.PI / 180) +
                         0.24 * Math.cos(2 * Hm * Math.PI / 180) +
                         0.32 * Math.cos((3 * Hm + 6) * Math.PI / 180) -
                         0.20 * Math.cos((4 * Hm - 63) * Math.PI / 180);

                const SL = 1 + ((0.015 * Math.pow(Lm - 50, 2)) / Math.sqrt(20 + Math.pow(Lm - 50, 2)));
                const SC = 1 + 0.045 * Cm;
                const SH = 1 + 0.015 * Cm * T;

                const RT = -2 * Math.sqrt(Math.pow(Cm, 7) / (Math.pow(Cm, 7) + Math.pow(25, 7))) *
                          Math.sin(60 * Math.exp(-Math.pow((Hm - 275) / 25, 2)) * Math.PI / 180);

                const kL = 1.0, kC = 1.0, kH = 1.0;

                const deltaE = Math.sqrt(
                    Math.pow(dL / (kL * SL), 2) +
                    Math.pow(dC / (kC * SC), 2) +
                    Math.pow(dH / (kH * SH), 2) +
                    RT * (dC / (kC * SC)) * (dH / (kH * SH))
                );

                return deltaE;
            }

            // í¼ìŠ¤ë„ì»¬ëŸ¬ ë¶„ì„ ì‹¤í–‰
            analyzePersonalColor(landmarks, videoElement) {
                try {
                    // 1. í”¼ë¶€ìƒ‰ ì¶”ì¶œ
                    const skinData = this.extractSkinColor(landmarks, videoElement);
                    
                    // 2. LAB ë³€í™˜
                    const userLab = this.rgbToLab(skinData.rgb.r, skinData.rgb.g, skinData.rgb.b);
                    
                    // 3. ê° ê³„ì ˆê³¼ì˜ Delta E ê³„ì‚°
                    const seasonScores = {};
                    let bestSeason = 'spring';
                    let minDeltaE = Infinity;
                    
                    Object.keys(this.seasonReferences).forEach(season => {
                        const refLab = this.seasonReferences[season];
                        const deltaE = this.calculateDeltaE2000(userLab, refLab);
                        seasonScores[season] = deltaE;
                        
                        if (deltaE < minDeltaE) {
                            minDeltaE = deltaE;
                            bestSeason = season;
                        }
                    });
                    
                    // 4. ì‹ ë¢°ë„ ê³„ì‚° (Delta Eê°€ ë‚®ì„ìˆ˜ë¡ ë†’ì€ ì‹ ë¢°ë„)
                    const maxDeltaE = Math.max(...Object.values(seasonScores));
                    const confidence = Math.round(((maxDeltaE - minDeltaE) / maxDeltaE) * 100);
                    
                    // 5. ê³„ì ˆëª… ë§¤í•‘
                    const seasonNames = {
                        spring: 'ë´„ ì›œí†¤',
                        summer: 'ì—¬ë¦„ ì¿¨í†¤', 
                        autumn: 'ê°€ì„ ì›œí†¤',
                        winter: 'ê²¨ìš¸ ì¿¨í†¤'
                    };
                    
                    return {
                        season: seasonNames[bestSeason],
                        confidence: Math.max(60, Math.min(95, confidence)), // 60-95% ë²”ìœ„
                        skinColor: skinData.rgb,
                        labValues: userLab,
                        deltaEScores: seasonScores,
                        minDeltaE: minDeltaE,
                        regionData: skinData.regionData,
                        totalSamples: skinData.totalSamples,
                        expertAnalysis: this.generateScientificAnalysis(bestSeason, userLab, minDeltaE)
                    };
                    
                } catch (error) {
                    console.error('ê³¼í•™ì  ë¶„ì„ ì‹¤íŒ¨:', error);
                    throw error;
                }
            }
            
            generateScientificAnalysis(season, labValues, deltaE) {
                const analyses = {
                    spring: `L*=${labValues.L.toFixed(1)}, a*=${labValues.a.toFixed(1)}, b*=${labValues.b.toFixed(1)}ìœ¼ë¡œ ë”°ëœ»í•˜ê³  ë°ì€ í†¤ì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤. Delta E=${deltaE.toFixed(2)}ë¡œ ë´„ ì›œí†¤ê³¼ ë†’ì€ ì¼ì¹˜ë„ë¥¼ ë³´ì…ë‹ˆë‹¤.`,
                    summer: `ì¸¡ì •ëœ ìƒ‰ìƒê°’ì´ ì—¬ë¦„ ì¿¨í†¤ì˜ íŠ¹ì§•ì¸ ë¶€ë“œëŸ¬ìš´ íŒŒìŠ¤í…” í†¤ê³¼ ì¼ì¹˜í•©ë‹ˆë‹¤. ì°¨ê°€ìš´ ì–¸ë”í†¤ì´ ê°ì§€ë˜ì–´ ì¿¨í†¤ ìƒ‰ìƒì„ ì¶”ì²œí•©ë‹ˆë‹¤.`,
                    autumn: `ê¹Šê³  ë”°ëœ»í•œ ìƒ‰ìƒ íŠ¹ì„±ì´ í™•ì¸ë˜ì—ˆìŠµë‹ˆë‹¤. ê°€ì„ ì›œí†¤ì— ì í•©í•œ ë¦¬ì¹˜í•œ ë¸Œë¼ìš´ ê³„ì—´ì´ ì–´ìš¸ë¦½ë‹ˆë‹¤.`,
                    winter: `ë†’ì€ ëŒ€ë¹„ì™€ ì°¨ê°€ìš´ ì–¸ë”í†¤ì´ íŠ¹ì§•ì…ë‹ˆë‹¤. ê²¨ìš¸ ì¿¨í†¤ì— ë§ëŠ” ì§„í•˜ê³  ì„ ëª…í•œ ìƒ‰ìƒì´ ì í•©í•©ë‹ˆë‹¤.`
                };
                return analyses[season] || 'ê³¼í•™ì  ë¶„ì„ì„ ì™„ë£Œí–ˆìŠµë‹ˆë‹¤.';
            }
        }
        
        // ========================================
        // ì „ë¬¸ê°€ ë…¸í•˜ìš° ë°ì´í„° (ìµëª…í™”)
        // ========================================
        const ExpertKnowledge = {
            colorTheory: {
                warmCool: "ì£¼í™©ìƒ‰ì€ ì›œí†¤ì˜ ëŒ€í‘œì ì¸ ìƒ‰ìƒì´ë©° ì¿¨í†¤ìœ¼ë¡œ ë³€í™˜ì´ ì–´ë µìŠµë‹ˆë‹¤",
                foundation: "íŒŒìš´ë°ì´ì…˜ 21-23í˜¸ëŒ€ëŠ” ë¹„ìŠ·í•œ ëª…ë„ì˜ í—¤ì–´ì»¬ëŸ¬ì™€ ë§¤ì¹˜í•  ë•Œ ì£¼ì˜ê°€ í•„ìš”í•©ë‹ˆë‹¤"
            },
            skinAnalysis: {
                redness: "í™ì¡° í”¼ë¶€ëŠ” ë¯¸ë“œë‚˜ì‡ ì»¬ëŸ¬ë¡œ ì¤‘í™”ì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤",
                principle: "ëª…ë„ì™€ ì±„ë„ì˜ ì¡°í•©ì´ ìƒ‰ìƒ ì´ë¦„ë³´ë‹¤ ì¤‘ìš”í•©ë‹ˆë‹¤"
            },
            colorMatching: {
                warm: "ì•„ì´ë³´ë¦¬ í”¼ë¶€ì—ëŠ” ì½”í† ë¦¬ë² ì´ì§€ë‚˜ ì˜¤ë Œì§€ë¸Œë¼ìš´ì´ ì˜ ì–´ìš¸ë¦½ë‹ˆë‹¤",
                cool: "í™”ì´íŠ¸ í”¼ë¶€ì—ëŠ” ë¸”ë£¨ë¸”ë™ì´ë‚˜ ì• ì‰¬ë¸”ë£¨ê°€ ì í•©í•©ë‹ˆë‹¤"
            }
        };

        // ========================================
        // ê³„ì ˆë³„ ìƒ‰ìƒ íŒ”ë ˆíŠ¸
        // ========================================
        const SeasonPalettes = {
            spring: {
                colors: ['#FFB6C1', '#FFA07A', '#F0E68C', '#98FB98', '#FFE4B5', '#DDA0DD', '#FF7F50', '#FFF8DC', '#FFE4E1', '#FAFAD2'],
                characteristics: ['ë°ê³  ë”°ëœ»í•œ ìƒ‰ìƒ', 'ë†’ì€ ì±„ë„', 'ë…¸ë€ ì–¸ë”í†¤']
            },
            summer: {
                colors: ['#B0E0E6', '#DDA0DD', '#C8B2DB', '#AFEEEE', '#F0F8FF', '#E6E6FA', '#D8BFD8', '#B0C4DE', '#E0E6FF', '#F5F5DC'],
                characteristics: ['ë¶€ë“œëŸ½ê³  ì°¨ê°€ìš´ ìƒ‰ìƒ', 'ì¤‘ê°„ ì±„ë„', 'íŒŒë€ ì–¸ë”í†¤']
            },
            autumn: {
                colors: ['#D2691E', '#CD853F', '#A0522D', '#8B4513', '#B22222', '#800000', '#FF8C00', '#DAA520', '#B8860B', '#8B7355'],
                characteristics: ['ê¹Šê³  ë”°ëœ»í•œ ìƒ‰ìƒ', 'ë‚®ì€ ì±„ë„', 'ë…¸ë€ ì–¸ë”í†¤']
            },
            winter: {
                colors: ['#000080', '#4B0082', '#8B008B', '#191970', '#2F4F4F', '#708090', '#483D8B', '#2E2E2E', '#1C1C1C', '#000000'],
                characteristics: ['ì§„í•˜ê³  ì°¨ê°€ìš´ ìƒ‰ìƒ', 'ë†’ì€ ëŒ€ë¹„', 'íŒŒë€ ì–¸ë”í†¤']
            }
        };

        // ========================================
        // ì‹œìŠ¤í…œ ì´ˆê¸°í™”
        // ========================================
        document.addEventListener('DOMContentLoaded', function() {
            console.log('HAIRGATOR Personal Color ì‹œìŠ¤í…œ ì‹œì‘...');
            initializeSystem();
        });

        async function initializeSystem() {
            const timeoutId = setTimeout(() => {
                console.warn('ë¡œë”© íƒ€ì„ì•„ì›ƒ - ê°•ì œë¡œ ì•± í‘œì‹œ');
                document.getElementById('loading-screen').style.display = 'none';
                document.getElementById('main-app').classList.add('loaded');
                showToast('ì‹œìŠ¤í…œì´ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤', 'warning');
            }, 5000);

            try {
                console.log('ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹œì‘...');
                
                updateLoadingProgress(25, 'í—¤ì–´ì»¬ëŸ¬ ë°ì´í„° ë¡œë“œ ì¤‘...');
                await loadHairColorData();
                
                updateLoadingProgress(50, 'UI ì»´í¬ë„ŒíŠ¸ ì„¤ì • ì¤‘...');
                setupUI();
                
                updateLoadingProgress(75, 'ê³¼í•™ì  AI ì—”ì§„ ì¤€ë¹„ ì¤‘...');
                scientificAnalyzer = new ScientificPersonalColorAnalyzer();
                await new Promise(resolve => setTimeout(resolve, 500));
                
                updateLoadingProgress(100, 'ì‹œìŠ¤í…œ ì¤€ë¹„ ì™„ë£Œ!');
                await new Promise(resolve => setTimeout(resolve, 800));
                
                clearTimeout(timeoutId);
                
                document.getElementById('loading-screen').style.display = 'none';
                document.getElementById('main-app').classList.add('loaded');
                
                console.log('HAIRGATOR Personal Color ì¤€ë¹„ ì™„ë£Œ');
                showToast('ê³¼í•™ì  í¼ìŠ¤ë„ì»¬ëŸ¬ ì‹œìŠ¤í…œì´ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤!', 'success');
                
            } catch (error) {
                clearTimeout(timeoutId);
                console.error('ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
                
                document.getElementById('loading-screen').style.display = 'none';
                document.getElementById('main-app').classList.add('loaded');
                showToast('ì¼ë¶€ ê¸°ëŠ¥ì— ì œí•œì´ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.', 'warning');
            }
        }

        function updateLoadingProgress(percent, text) {
            const bar = document.getElementById('loading-bar');
            const textEl = document.getElementById('loading-text');
            if (bar) bar.style.width = percent + '%';
            if (textEl) textEl.textContent = text;
        }

        // ========================================
        // í—¤ì–´ì»¬ëŸ¬ ë°ì´í„° ë¡œë“œ
        // ========================================
        async function loadHairColorData() {
            try {
                if (parent && parent.HAIR_COLOR_614_DATA) {
                    hairColorData = parent.HAIR_COLOR_614_DATA;
                    console.log('ë¶€ëª¨ì°½ì—ì„œ 614ê°œ í—¤ì–´ì»¬ëŸ¬ ë°ì´í„° ë¡œë“œ ì™„ë£Œ');
                    checkShiseidoData();
                    return;
                }
                
                if (typeof HAIR_COLOR_614_DATA !== 'undefined') {
                    hairColorData = HAIR_COLOR_614_DATA;
                    console.log('ê¸€ë¡œë²Œ ë³€ìˆ˜ì—ì„œ 614ê°œ ë°ì´í„° ë¡œë“œ');
                    checkShiseidoData();
                    return;
                }
                
                if (parent && parent.hairColorDatabase) {
                    hairColorData = parent.hairColorDatabase;
                    console.log(`ë¶€ëª¨ì°½ ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ${hairColorData.length}ê°œ ë¡œë“œ`);
                    checkShiseidoData();
                    return;
                }
                
                await loadExternalHairColorData();
                checkShiseidoData();
                
            } catch (error) {
                console.error('í—¤ì–´ì»¬ëŸ¬ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:', error);
                hairColorData = generateDefaultHairColors();
                checkShiseidoData();
            }
        }

        async function loadExternalHairColorData() {
            try {
                const script = document.createElement('script');
                script.src = 'hair-color-data.js';
                script.onload = () => {
                    if (typeof HAIR_COLOR_614_DATA !== 'undefined') {
                        hairColorData = HAIR_COLOR_614_DATA;
                        console.log('ì™¸ë¶€ ìŠ¤í¬ë¦½íŠ¸ì—ì„œ 614ê°œ ë°ì´í„° ë¡œë“œ');
                    }
                };
                script.onerror = () => {
                    console.warn('ì™¸ë¶€ í—¤ì–´ì»¬ëŸ¬ ë°ì´í„° ìŠ¤í¬ë¦½íŠ¸ ë¡œë“œ ì‹¤íŒ¨');
                    hairColorData = generateDefaultHairColors();
                };
                
                document.head.appendChild(script);
                await new Promise(resolve => setTimeout(resolve, 3000));
                
                if (hairColorData.length === 0) {
                    hairColorData = generateDefaultHairColors();
                }
                
            } catch (error) {
                console.error('ì™¸ë¶€ ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜:', error);
                hairColorData = generateDefaultHairColors();
            }
        }

        function generateDefaultHairColors() {
            const brands = ['ë¡œë ˆì•Œ', 'ì›°ë¼', 'ë°€ë³¸'];
            const seasons = ['spring', 'summer', 'autumn', 'winter'];
            const data = [];
            
            brands.forEach(brand => {
                seasons.forEach(season => {
                    SeasonPalettes[season].colors.forEach((color, index) => {
                        data.push({
                            brand: brand,
                            name: `${season} Color ${index + 1}`,
                            hex: color,
                            season: season,
                            confidence: 0.8 + Math.random() * 0.2
                        });
                    });
                });
            });
            
            return data;
        }

        function checkShiseidoData() {
            const shiseidoCount = hairColorData.filter(item => 
                item.brand && (
                    item.brand.toLowerCase().includes('shiseido') ||
                    item.brand.toLowerCase().includes('ì‹œì„¸ì´ë„')
                )
            ).length;
            
            console.log(`í˜„ì¬ ì‹œì„¸ì´ë„ ë°ì´í„°: ${shiseidoCount}ê°œ`);
            
            if (shiseidoCount === 0) {
                console.warn('ì‹œì„¸ì´ë„ ë°ì´í„° ì—†ìŒ. ì¶”ê°€í•©ë‹ˆë‹¤...');
                addShiseidoData();
            } else {
                console.log('ì‹œì„¸ì´ë„ ë°ì´í„° í™•ì¸ë¨');
            }
            
            console.log(`ì´ ë°ì´í„°: ${hairColorData.length}ê°œ`);
        }

        function addShiseidoData() {
            const shiseidoData = [
                {brand: "Shiseido", line: "PRIMIENCE", code: "N5", name: "ë‚´ì¸„ëŸ´ ë¸Œë¼ìš´", hex: "#6B4E37", season: "autumn"},
                {brand: "Shiseido", line: "PRIMIENCE", code: "A6", name: "ì• ì‰¬ ë¸Œë¼ìš´", hex: "#8B7D6B", season: "summer"},
                {brand: "Shiseido", line: "PRIMIENCE", code: "G7", name: "ê³¨ë“  ë² ì´ì§€", hex: "#D2B48C", season: "spring"},
                {brand: "Shiseido", line: "ADENOVITAL", code: "AD01", name: "ë”¥ ë¸”ë™", hex: "#2F2F2F", season: "winter"},
                {brand: "Shiseido", line: "ADENOVITAL", code: "AD02", name: "ì†Œí”„íŠ¸ ë¸”ë™", hex: "#4A4A4A", season: "winter"},
                {brand: "Shiseido", line: "PRIMIENCE", code: "B8", name: "ë² ì´ì§€ ë¸Œë¼ìš´", hex: "#A0826D", season: "autumn"},
                {brand: "Shiseido", line: "PRIMIENCE", code: "M9", name: "ë§¤íŠ¸ ë¸Œë¼ìš´", hex: "#8B6F47", season: "autumn"},
                {brand: "Shiseido", line: "ADENOVITAL", code: "AD03", name: "ë‹¤í¬ ë¸Œë¼ìš´", hex: "#3D2F23", season: "winter"},
                {brand: "Shiseido", line: "ADENOVITAL", code: "AD04", name: "ì¿¨ ë¸Œë¼ìš´", hex: "#5D4E3A", season: "summer"},
                {brand: "Shiseido", line: "PRIMIENCE", code: "C10", name: "ì¹´ë¼ë©œ ë¸Œë¼ìš´", hex: "#B8860B", season: "spring"}
            ];
            
            hairColorData.push(...shiseidoData);
            console.log(`ì‹œì„¸ì´ë„ ${shiseidoData.length}ê°œ ë°ì´í„° ì¶”ê°€ ì™„ë£Œ`);
        }

        function setupUI() {
            selectSeason('spring');
            console.log('UI ì„¤ì • ì™„ë£Œ');
        }

        // ========================================
        // ëª¨ë“œ ì„ íƒ ë° ì „í™˜
        // ========================================
        function selectMode(mode) {
            console.log('ëª¨ë“œ ì„ íƒ:', mode);
            currentMode = mode;

            document.querySelectorAll('.section').forEach(section => {
                section.classList.remove('active');
            });

            if (mode === 'ai') {
                document.getElementById('ai-analysis').classList.add('active');
                showToast('ê³¼í•™ì  AI í¼ìŠ¤ë„ì»¬ëŸ¬ ë¶„ì„ ëª¨ë“œê°€ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤', 'success');
            } else if (mode === 'draping') {
                document.getElementById('draping-mode').classList.add('active');
                showToast('ì „ë¬¸ê°€ ë“œë˜ì´í•‘ ëª¨ë“œê°€ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤', 'success');
            }
        }

        function goHome() {
            document.querySelectorAll('.section').forEach(section => {
                section.classList.remove('active');
            });
            document.getElementById('mode-selection').classList.add('active');
            
            stopAICamera();
            stopDrapingCamera();
            cleanupCameraResources();
            
            currentMode = null;
            showToast('í™ˆ í™”ë©´ìœ¼ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤', 'info');
        }

        // ========================================
        // AI ì¹´ë©”ë¼ í•¨ìˆ˜ë“¤
        // ========================================
        async function startAICamera() {
            try {
                showToast('ê³¼í•™ì  AI ì¹´ë©”ë¼ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤...', 'info');
                
                cleanupCameraResources();
                
                activeVideoStream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: 640, height: 480 }
                });

                videoElement = document.getElementById('ai-camera');
                videoElement.srcObject = activeVideoStream;
                
                canvasElement = document.getElementById('ai-face-overlay');
                canvasCtx = canvasElement.getContext('2d', { willReadFrequently: true });
                
                if (typeof FaceMesh !== 'undefined' && !faceDetectionInstance) {
                    try {
                        faceDetectionInstance = new FaceMesh({
                            locateFile: (file) => {
                                return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
                            }
                        });
                        
                        faceDetectionInstance.setOptions({
                            maxNumFaces: 1,
                            refineLandmarks: true,
                            minDetectionConfidence: 0.5,
                            minTrackingConfidence: 0.5
                        });
                        
                        faceDetectionInstance.onResults(onAdvancedFaceResults);
                        
                        if (typeof Camera !== 'undefined') {
                            mediaPipeCamera = new Camera(videoElement, {
                                onFrame: async () => {
                                    if (faceDetectionInstance && videoElement.readyState === 4) {
                                        await faceDetectionInstance.send({ image: videoElement });
                                    }
                                },
                                width: 640,
                                height: 480
                            });
                            mediaPipeCamera.start();
                        }
                        
                        console.log('MediaPipe Face Mesh í™œì„±í™”');
                        showToast('ê³ ê¸‰ 468í¬ì¸íŠ¸ ì–¼êµ´ ëœë“œë§ˆí¬ ì¸ì‹ì´ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤', 'success');
                    } catch (error) {
                        console.warn('Face Mesh ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
                        showToast('ê¸°ë³¸ ì¹´ë©”ë¼ ëª¨ë“œë¡œ ì‹œì‘í•©ë‹ˆë‹¤', 'warning');
                    }
                }
                
                document.getElementById('ai-face-guide').style.display = 'flex';
                
            } catch (error) {
                console.error('ì¹´ë©”ë¼ ì‹œì‘ ì‹¤íŒ¨:', error);
                cleanupCameraResources();
                showToast('ì¹´ë©”ë¼ì— ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤', 'error');
            }
        }

        function onAdvancedFaceResults(results) {
            if (!canvasCtx || !videoElement) return;
            
            canvasElement.width = videoElement.videoWidth || 640;
            canvasElement.height = videoElement.videoHeight || 480;
            
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                
                drawFullFaceMesh(canvasCtx, landmarks);
                drawSkinTonePoints(canvasCtx, landmarks);
                
                if (scientificAnalyzer) {
                    try {
                        const analysisData = scientificAnalyzer.extractSkinColor(landmarks, videoElement);
                        displayRealtimeAnalysis(analysisData);
                    } catch (error) {
                        console.warn('ì‹¤ì‹œê°„ ë¶„ì„ ì˜¤ë¥˜:', error);
                    }
                }
                
                if (!faceDetected) {
                    faceDetected = true;
                    document.getElementById('ai-face-guide').style.display = 'none';
                    showToast('ê³ ê¸‰ 468í¬ì¸íŠ¸ Face Mesh ì¸ì‹ ì™„ë£Œ!', 'success');
                }
            } else {
                if (faceDetected) {
                    faceDetected = false;
                    document.getElementById('ai-face-guide').style.display = 'flex';
                    clearSkinToneDisplay();
                    window.lastLandmarks = null;
                }
            }
        }

        function displayAIAnalysisResult(result) {
            document.getElementById('ai-season-result').textContent = result.season;
            document.getElementById('ai-confidence').textContent = `ì‹ ë¢°ë„: ${result.confidence}%`;
            
            const analysisData = document.getElementById('ai-analysis-data');
            analysisData.innerHTML = `
                <div class="color-data">
                    <h5>ì¶”ì¶œëœ í”¼ë¶€ìƒ‰ (ê³¼í•™ì  ë¶„ì„)</h5>
                    <div class="skin-color-sample" style="background: rgb(${result.skinColor.r}, ${result.skinColor.g}, ${result.skinColor.b}); width: 60px; height: 60px; border-radius: 50%; margin: 10px auto; border: 3px solid #00FF88;"></div>
                    <p><strong>RGB:</strong> (${result.skinColor.r}, ${result.skinColor.g}, ${result.skinColor.b})</p>
                    ${result.labValues ? `<p><strong>LAB:</strong> L*=${result.labValues.L.toFixed(1)}, a*=${result.labValues.a.toFixed(1)}, b*=${result.labValues.b.toFixed(1)}</p>` : ''}
                    ${result.minDeltaE ? `<p><strong>Delta E:</strong> ${result.minDeltaE.toFixed(2)} (ë‚®ì„ìˆ˜ë¡ ì •í™•í•¨)</p>` : ''}
                    ${result.totalSamples ? `<p><strong>ë¶„ì„ ìƒ˜í”Œ:</strong> ${result.totalSamples}ê°œ í”½ì…€</p>` : ''}
                </div>
                <div class="expert-analysis">
                    <h5>ê³¼í•™ì  ë¶„ì„ ê²°ê³¼</h5>
                    <p>${result.expertAnalysis}</p>
                </div>
            `;
            
            document.getElementById('ai-analysis-results').style.display = 'block';
            displayFinalResults(result);
            showToast(`ê³¼í•™ì  AI ë¶„ì„ ì™„ë£Œ: ${result.season}`, 'success');
            
            document.dispatchEvent(new CustomEvent('personalColorAnalyzed', {
                detail: {
                    season: result.season,
                    tone: result.season.includes('ì›œí†¤') ? 'ì›œí†¤' : 'ì¿¨í†¤',
                    characteristics: result.expertAnalysis,
                    confidence: result.confidence,
                    scientific: true,
                    labValues: result.labValues,
                    deltaE: result.minDeltaE
                }
            }));
        }

        // ========================================
        // ë“œë˜ì´í•‘ ëª¨ë“œ í•¨ìˆ˜ë“¤
        // ========================================
        async function startDrapingCamera() {
            try {
                showToast('ë“œë˜ì´í•‘ ì¹´ë©”ë¼ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤...', 'info');
                
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: 640, height: 480 }
                });

                const drapingVideo = document.getElementById('draping-camera');
                drapingVideo.srcObject = stream;
                
                document.getElementById('draping-face-guide').style.display = 'flex';
                
                showToast('ë“œë˜ì´í•‘ ì¹´ë©”ë¼ê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤', 'success');
                
            } catch (error) {
                console.error('ë“œë˜ì´í•‘ ì¹´ë©”ë¼ ì‹œì‘ ì‹¤íŒ¨:', error);
                showToast('ì¹´ë©”ë¼ì— ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤', 'error');
            }
        }

        function stopDrapingCamera() {
            const drapingVideo = document.getElementById('draping-camera');
            if (drapingVideo && drapingVideo.srcObject) {
                const tracks = drapingVideo.srcObject.getTracks();
                tracks.forEach(track => track.stop());
                drapingVideo.srcObject = null;
            }
            
            showToast('ë“œë˜ì´í•‘ ì¹´ë©”ë¼ê°€ ì •ì§€ë˜ì—ˆìŠµë‹ˆë‹¤', 'info');
        }

        function selectSeason(season) {
            currentSeason = season;
            
            document.querySelectorAll('.season-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelector(`[data-season="${season}"]`).classList.add('active');
            
            updateColorGrid(season);
            showToast(`${season} ê³„ì ˆ ìƒ‰ìƒì„ ì„ íƒí–ˆìŠµë‹ˆë‹¤`, 'info');
        }

        function updateColorGrid(season) {
            const colorGrid = document.getElementById('color-grid');
            
            const seasonColors = hairColorData.filter(item => 
                item.season && item.season.toLowerCase() === season.toLowerCase()
            );
            
            colorGrid.innerHTML = '';
            
            if (seasonColors.length === 0) {
                const defaultColors = SeasonPalettes[season].colors;
                defaultColors.forEach(color => {
                    const colorItem = document.createElement('div');
                    colorItem.className = 'color-item';
                    colorItem.style.background = color;
                    colorItem.onclick = () => selectColor(color);
                    colorGrid.appendChild(colorItem);
                });
                return;
            }
            
            const representativeColors = seasonColors
                .sort((a, b) => (b.confidence || 0.8) - (a.confidence || 0.8))
                .slice(0, 12)
                .map(item => ({
                    hex: item.hex,
                    name: item.name,
                    brand: item.brand,
                    code: item.code
                }));
            
            representativeColors.forEach(colorData => {
                const colorItem = document.createElement('div');
                colorItem.className = 'color-item';
                colorItem.style.background = colorData.hex;
                colorItem.title = `${colorData.brand} ${colorData.code} - ${colorData.name}`;
                colorItem.onclick = () => selectColor(colorData.hex, colorData);
                colorGrid.appendChild(colorItem);
            });
        }

        function selectColor(color, colorData = null) {
            selectedColor = color;
            
            document.querySelectorAll('.color-item').forEach(item => {
                item.style.border = '3px solid transparent';
            });
            event.target.style.border = '3px solid #E91E63';
            
            applyDrapingColor(color);
            
            let toastMessage = `ìƒ‰ìƒ ${color}ë¥¼ ì„ íƒí–ˆìŠµë‹ˆë‹¤`;
            
            if (colorData) {
                toastMessage = `${colorData.brand} ${colorData.code} - ${colorData.name} ì„ íƒë¨`;
            }
            
            showToast(toastMessage, 'info');
        }

        function applyDrapingColor(color) {
            const overlay = document.getElementById('draping-overlay');
            const ctx = overlay.getContext('2d');
            
            if (overlay.width === 0) {
                overlay.width = 640;
                overlay.height = 480;
            }
            
            ctx.clearRect(0, 0, overlay.width, overlay.height);
            
            ctx.fillStyle = color;
            ctx.globalAlpha = 0.8;
            ctx.fillRect(0, 0, overlay.width, overlay.height / 4);
            ctx.globalAlpha = 1.0;
        }

        function adjustColor() {
            if (!selectedColor) return;
            
            const lightness = parseInt(document.getElementById('lightness-slider').value);
            const saturation = parseInt(document.getElementById('saturation-slider').value);
            const warmth = parseInt(document.getElementById('warmth-slider').value);
            
            document.getElementById('lightness-value').textContent = lightness;
            document.getElementById('saturation-value').textContent = saturation;
            document.getElementById('warmth-value').textContent = warmth;
            
            const adjustedColor = adjustColorValues(selectedColor, lightness, saturation, warmth);
            applyDrapingColor(adjustedColor);
        }

        function adjustColorValues(hexColor, lightness, saturation, warmth) {
            const r = parseInt(hexColor.substr(1, 2), 16);
            const g = parseInt(hexColor.substr(3, 2), 16);
            const b = parseInt(hexColor.substr(5, 2), 16);
            
            let newR = Math.max(0, Math.min(255, r + lightness + warmth));
            let newG = Math.max(0, Math.min(255, g + lightness));
            let newB = Math.max(0, Math.min(255, b + lightness - warmth));
            
            const gray = (newR + newG + newB) / 3;
            const saturationFactor = 1 + (saturation / 100);
            newR = Math.max(0, Math.min(255, gray + (newR - gray) * saturationFactor));
            newG = Math.max(0, Math.min(255, gray + (newG - gray) * saturationFactor));
            newB = Math.max(0, Math.min(255, gray + (newB - gray) * saturationFactor));
            
            return `#${Math.round(newR).toString(16).padStart(2, '0')}${Math.round(newG).toString(16).padStart(2, '0')}${Math.round(newB).toString(16).padStart(2, '0')}`;
        }

        function saveCurrentColor() {
            if (!selectedColor) {
                showToast('ë¨¼ì € ìƒ‰ìƒì„ ì„ íƒí•´ì£¼ì„¸ìš”', 'warning');
                return;
            }
            
            const colorData = {
                color: selectedColor,
                season: currentSeason,
                timestamp: new Date().toISOString()
            };
            
            savedColors.push(colorData);
            showToast('í˜„ì¬ ìƒ‰ìƒì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤', 'success');
        }

        // ========================================
        // ê²°ê³¼ í‘œì‹œ í•¨ìˆ˜ë“¤
        // ========================================
        function displayFinalResults(result) {
            const resultsSection = document.getElementById('results-section');
            const finalResults = document.getElementById('final-results');
            
            let colors = [];
            let season = 'ë¶„ì„ ì¤‘';
            let confidence = 0;
            
            if (result && typeof result === 'object') {
                season = result.season || 'ë¶„ì„ ì¤‘';
                confidence = result.confidence || 0;
                
                if (season && season !== 'ë¶„ì„ ì¤‘') {
                    const seasonKey = season.toLowerCase()
                        .replace(' ì›œí†¤', '')
                        .replace(' ì¿¨í†¤', '')
                        .replace('ë´„', 'spring')
                        .replace('ì—¬ë¦„', 'summer')
                        .replace('ê°€ì„', 'autumn')
                        .replace('ê²¨ìš¸', 'winter');
                        
                    colors = SeasonPalettes[seasonKey]?.colors || ['#8B4513', '#A0522D', '#CD853F'];
                } else {
                    colors = ['#8B4513', '#A0522D', '#CD853F'];
                }
            } else {
                colors = ['#8B4513', '#A0522D', '#CD853F'];
            }
            
            const scientificBadge = result?.scientific ? '<span style="background: #00FF88; color: black; padding: 3px 8px; border-radius: 12px; font-size: 0.8em; font-weight: bold; margin-left: 10px;">ğŸ”¬ ê³¼í•™ì  ë¶„ì„</span>' : '';
            
            finalResults.innerHTML = `
                <div class="result-header" style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 1rem;">
                    <h3 style="margin: 0;">${season}${scientificBadge}</h3>
                    <div class="confidence" style="font-size: 1.1em; font-weight: bold; color: #00FF88;">ì‹ ë¢°ë„: ${confidence}%</div>
                </div>
                ${result?.labValues ? `
                <div style="background: rgba(0,255,136,0.1); padding: 1rem; border-radius: 8px; margin-bottom: 1rem; border: 1px solid rgba(0,255,136,0.3);">
                    <h5 style="margin: 0 0 0.5rem 0; color: #00FF88;">ğŸ”¬ ê³¼í•™ì  ì¸¡ì • ë°ì´í„°</h5>
                    <p style="margin: 0; font-size: 0.9em;">LAB ìƒ‰ê³µê°„: L*=${result.labValues.L.toFixed(1)}, a*=${result.labValues.a.toFixed(1)}, b*=${result.labValues.b.toFixed(1)}</p>
                    ${result.deltaE ? `<p style="margin: 0; font-size: 0.9em;">Delta E 2000: ${result.deltaE.toFixed(2)} (ìƒ‰ì°¨)</p>` : ''}
                    ${result.totalSamples ? `<p style="margin: 0; font-size: 0.9em;">ë¶„ì„ ìƒ˜í”Œ: ${result.totalSamples}ê°œ í”½ì…€</p>` : ''}
                </div>
                ` : ''}
                <div class="result-colors" style="display: flex; flex-wrap: wrap; gap: 10px; margin: 1rem 0;">
                    ${colors.slice(0, 8).map(color => 
                        `<div class="result-color" style="background: ${color}; width: 50px; height: 50px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.2);" title="${color}"></div>`
                    ).join('')}
                </div>
                <div class="result-description">
                    <p>${season}ì— ì–´ìš¸ë¦¬ëŠ” í—¤ì–´ì»¬ëŸ¬ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.</p>
                </div>
            `;
            
            if (season && season !== 'ë¶„ì„ ì¤‘') {
                displayProductRecommendations(season);
            }
            
            resultsSection.style.display = 'block';
            resultsSection.scrollIntoView({ behavior: 'smooth' });
        }

        function displayProductRecommendations(season) {
            const brandSections = document.getElementById('brand-sections');
            
            if (!brandSections) {
                console.warn('brand-sections ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                return;
            }
            
            const defaultRecommendations = {
                'ë´„ ì›œí†¤': [
                    { brand: 'ë¡œë ˆì•Œ', products: ['ê³¨ë“  ë² ì´ì§€', 'í—ˆë‹ˆ ë¸”ë¡ ë“œ', 'ì¹´ë¼ë©œ ë¸Œë¼ìš´'] },
                    { brand: 'ì›°ë¼', products: ['ë¼ì´íŠ¸ ê³¨ë“ ', 'ì›œ ë² ì´ì§€', 'ì†Œí”„íŠ¸ ë¸Œë¼ìš´'] },
                    { brand: 'Shiseido', products: ['ê³¨ë“  ë² ì´ì§€', 'ì¹´ë¼ë©œ ë¸Œë¼ìš´', 'í—ˆë‹ˆ ê³¨ë“œ'] }
                ],
                'ì—¬ë¦„ ì¿¨í†¤': [
                    { brand: 'ë¡œë ˆì•Œ', products: ['ì• ì‰¬ ë¸”ë¡ ë“œ', 'ì¿¨ ë² ì´ì§€', 'í”Œë˜í‹°ë„˜'] },
                    { brand: 'ì›°ë¼', products: ['ì‹¤ë²„ ì• ì‰¬', 'ì¿¨ ë¸Œë¼ìš´', 'ì•„ì´ì‹œ ë¸”ë¡ ë“œ'] },
                    { brand: 'Shiseido', products: ['ì• ì‰¬ ë¸Œë¼ìš´', 'ì¿¨ ë¸Œë¼ìš´', 'ë°”ì´ì˜¬ë › ì• ì‰¬'] }
                ],
                'ê°€ì„ ì›œí†¤': [
                    { brand: 'ë¡œë ˆì•Œ', products: ['ë¦¬ì¹˜ ë¸Œë¼ìš´', 'ë‹¤í¬ ì´ˆì½œë¦¿', 'ë§ˆí˜¸ê°€ë‹ˆ'] },
                    { brand: 'ì›°ë¼', products: ['ë”¥ ë¸Œë¼ìš´', 'ì²´ìŠ¤íŠ¸ë„›', 'ë‹¤í¬ ì¹´ë¼ë©œ'] },
                    { brand: 'Shiseido', products: ['ë‚´ì¸„ëŸ´ ë¸Œë¼ìš´', 'ë² ì´ì§€ ë¸Œë¼ìš´', 'ë§¤íŠ¸ ë¸Œë¼ìš´'] }
                ],
                'ê²¨ìš¸ ì¿¨í†¤': [
                    { brand: 'ë¡œë ˆì•Œ', products: ['ì œíŠ¸ ë¸”ë™', 'ë¸”ë£¨ ë¸”ë™', 'ë‹¤í¬ ì• ì‰¬'] },
                    { brand: 'ì›°ë¼', products: ['ë¯¸ë“œë‚˜ì‡ ë¸”ë™', 'ì¿¨ ë‹¤í¬', 'í”Œë˜í‹°ë„˜ ì‹¤ë²„'] },
                    { brand: 'Shiseido', products: ['ë”¥ ë¸”ë™', 'ì†Œí”„íŠ¸ ë¸”ë™', 'ë‹¤í¬ ë¸Œë¼ìš´'] }
                ]
            };
            
            const recommendations = defaultRecommendations[season] || defaultRecommendations['ë´„ ì›œí†¤'];
            
            brandSections.innerHTML = recommendations.map(brand => `
                <div class="brand-section" style="margin-bottom: 1.5rem; padding: 1rem; background: #f9f9f9; border-radius: 8px;">
                    <h5 style="color: #E91E63; margin-bottom: 0.5rem;">${brand.brand}</h5>
                    <div class="product-list">
                        ${brand.products.map(product => `
                            <div style="padding: 0.5rem; margin: 0.2rem 0; background: white; border-radius: 4px; border-left: 3px solid #E91E63;">
                                ${product}
                            </div>
                        `).join('')}
                    </div>
                </div>
            `).join('');
        }

        // ========================================
        // ì œë¯¸ë‚˜ì´ ê°€ìƒì²´í—˜ í•¨ìˆ˜ë“¤ (ê°œì„ ëœ ë²„ì „)
        // ========================================
        function captureCurrentFrame() {
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = videoElement.videoWidth;
                canvas.height = videoElement.videoHeight;
                
                ctx.drawImage(videoElement, 0, 0);
                
                const imageData = canvas.toDataURL('image/jpeg', 0.8);
                
                showToast('ì‚¬ì§„ ì´¬ì˜ ì™„ë£Œ', 'success');
                return imageData.split(',')[1];
                
            } catch (error) {
                console.error('í”„ë ˆì„ ìº¡ì²˜ ì‹¤íŒ¨:', error);
                return null;
            }
        }

        function getRecommendedHairColors() {
            const currentResult = getCurrentAnalysisResult();
            const season = currentResult ? currentResult.season : 'ë´„ ì›œí†¤';
            
            let seasonKey = season.toLowerCase()
                .replace(' ì›œí†¤', '')
                .replace(' ì¿¨í†¤', '')
                .replace('ë´„', 'spring')
                .replace('ì—¬ë¦„', 'summer') 
                .replace('ê°€ì„', 'autumn')
                .replace('ê²¨ìš¸', 'winter');
            
            const seasonColors = hairColorData.filter(item => 
                item.season && item.season.toLowerCase() === seasonKey
            );
            
            const brands = ['ë¡œë ˆì•Œ', 'ì›°ë¼', 'ë°€ë³¸', 'Shiseido', 'ì‹œì„¸ì´ë„'];
            const recommendations = [];
            
            brands.forEach(brand => {
                const brandColors = seasonColors.filter(item => 
                    item.brand && item.brand.toLowerCase().includes(brand.toLowerCase())
                );
                
                if (brandColors.length > 0) {
                    const bestColor = brandColors.sort((a, b) => 
                        (b.confidence || 0.8) - (a.confidence || 0.8)
                    )[0];
                    
                    recommendations.push({
                        brand: bestColor.brand,
                        name: bestColor.name,
                        code: bestColor.code,
                        hex: bestColor.hex,
                        description: `${season}ì— ì–´ìš¸ë¦¬ëŠ” ${bestColor.name}`
                    });
                }
            });
            
            while (recommendations.length < 5) {
                const paletteColors = SeasonPalettes[seasonKey]?.colors || SeasonPalettes.spring.colors;
                const randomColor = paletteColors[recommendations.length % paletteColors.length];
                
                recommendations.push({
                    brand: "ì¶”ì²œ",
                    name: `${season} ì»¬ëŸ¬ ${recommendations.length + 1}`,
                    code: `PC${recommendations.length + 1}`,
                    hex: randomColor,
                    description: `${season} í¼ìŠ¤ë„ì»¬ëŸ¬ ì¶”ì²œ`
                });
            }
            
            return recommendations.slice(0, 5);
        }

        function getCurrentAnalysisResult() {
            const seasonResult = document.getElementById('ai-season-result');
            const confidenceResult = document.getElementById('ai-confidence');
            
            if (seasonResult && seasonResult.textContent !== 'ë¶„ì„ ì¤‘...') {
                return {
                    season: seasonResult.textContent,
                    confidence: confidenceResult ? confidenceResult.textContent : '0%'
                };
            }
            
            return null;
        }

        // ê°œì„ ëœ ì œë¯¸ë‚˜ì´ í•¨ìˆ˜ (ìˆœì°¨ ì²˜ë¦¬ + ì•ˆì „í•œ ì˜¤ë¥˜ ì²˜ë¦¬)
        async function sendToGeminiForVirtualTry(imageBase64, colorRecommendations) {
            try {
                showToast('5ê°€ì§€ í—¤ì–´ì»¬ëŸ¬ë¥¼ í•˜ë‚˜ì”© ìƒì„±í•©ë‹ˆë‹¤...', 'info');
                
                // ë¨¼ì € ê¸°ë³¸ ê²°ê³¼ UIë¥¼ í‘œì‹œ
                displayVirtualTryResults(null, colorRecommendations, imageBase64);
                
                // ê° í—¤ì–´ì»¬ëŸ¬ë¥¼ ìˆœì°¨ì ìœ¼ë¡œ ì²˜ë¦¬
                for (let i = 0; i < colorRecommendations.length; i++) {
                    const color = colorRecommendations[i];
                    
                    try {
                        showToast(`${i+1}/5 ${color.name} ìƒì„± ì¤‘...`, 'info');
                        
                        // ë‹¨ì¼ ìƒ‰ìƒì— ëŒ€í•œ í”„ë¡¬í”„íŠ¸
                        const singleColorPrompt = `ì´ ì‚¬ì§„ì—ì„œ ë¨¸ë¦¬ì¹´ë½ì„ ë‹¤ìŒ ìƒ‰ìƒìœ¼ë¡œ ì—¼ìƒ‰í•´ì£¼ì„¸ìš”: ${color.brand} ${color.code} - ${color.name} (í—¥ìŠ¤ì½”ë“œ: ${color.hex}) ìì—°ìŠ¤ëŸ¬ìš´ í—¤ì–´ì»¬ëŸ¬ ë³€ê²½ë§Œ í•´ì£¼ì„¸ìš”.`;

                        // Netlify Functions í”„ë¡ì‹œë¥¼ í†µí•´ API í˜¸ì¶œ
                        const response = await fetch('/.netlify/functions/gemini-proxy', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                prompt: singleColorPrompt,
                                imageBase64: imageBase64,
                                colorRecommendations: [color] // ë‹¨ì¼ ìƒ‰ìƒë§Œ ì „ë‹¬
                            })
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            console.log(`ìƒ‰ìƒ ${i+1} ì‘ë‹µ:`, result);
                            
                            let content = null;
                            
                            // ì•ˆì „í•œ ì‘ë‹µ êµ¬ì¡° ì²˜ë¦¬ (ë‹¤ì–‘í•œ ì‘ë‹µ í˜•íƒœ ëŒ€ì‘)
                            if (result && result.result && result.result.candidates && result.result.candidates[0]) {
                                content = result.result.candidates[0].content.parts;
                            } else if (result && result.candidates && result.candidates[0]) {
                                content = result.candidates[0].content.parts;
                            } else if (result && result.content && result.content.parts) {
                                // ë‹¤ë¥¸ ê°€ëŠ¥í•œ ì‘ë‹µ êµ¬ì¡°
                                content = result.content.parts;
                            } else {
                                console.warn(`ìƒ‰ìƒ ${i+1} ì‘ë‹µ êµ¬ì¡° ì˜¤ë¥˜:`, result);
                                throw new Error('ìœ íš¨í•œ ì´ë¯¸ì§€ ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ');
                            }
                            
                            // ìƒì„±ëœ ì´ë¯¸ì§€ ì²˜ë¦¬
                            if (content && Array.isArray(content)) {
                                let imageProcessed = false;
                                
                                content.forEach((part) => {
                                    // inlineDataì™€ inline_data ëª¨ë‘ ì§€ì›
                                    const imageData = part.inlineData || part.inline_data;
                                    const mimeType = imageData?.mimeType || imageData?.mime_type;
                                    const data = imageData?.data;
                                    
                                    if (imageData && mimeType && mimeType.startsWith('image/') && data) {
                                        const imgElement = document.createElement('img');
                                        imgElement.src = `data:${mimeType};base64,${data}`;
                                        imgElement.style.cssText = 'width: 100%; height: 100%; object-fit: cover; border-radius: 8px;';
                                        
                                        // í•´ë‹¹í•˜ëŠ” ê²°ê³¼ ì»¨í…Œì´ë„ˆì— ì´ë¯¸ì§€ ì‚½ì…
                                        const container = document.getElementById(`virtual-image-${i}`);
                                        if (container) {
                                            container.innerHTML = '';
                                            container.appendChild(imgElement);
                                            imageProcessed = true;
                                        }
                                    }
                                });
                                
                                // ì´ë¯¸ì§€ê°€ ì²˜ë¦¬ë˜ì§€ ì•Šì•˜ìœ¼ë©´ ì˜¤ë¥˜ í‘œì‹œ
                                if (!imageProcessed) {
                                    throw new Error('ì‘ë‹µì—ì„œ ì´ë¯¸ì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ');
                                }
                                
                            } else {
                                throw new Error('ì‘ë‹µ ë‚´ìš©ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŒ');
                            }
                            
                        } else {
                            // HTTP ì˜¤ë¥˜ ì²˜ë¦¬
                            const errorText = await response.text();
                            console.error(`ìƒ‰ìƒ ${i+1} HTTP ì˜¤ë¥˜ (${response.status}):`, errorText);
                            throw new Error(`HTTP ${response.status} ì˜¤ë¥˜`);
                        }
                        
                    } catch (error) {
                        console.error(`ìƒ‰ìƒ ${i+1} ìƒì„± ì‹¤íŒ¨:`, error);
                        
                        // ì‹¤íŒ¨ ì‹œ ìƒ‰ìƒ í”„ë¦¬ë·°ë¡œ í´ë°±
                        const container = document.getElementById(`virtual-image-${i}`);
                        if (container) {
                            container.innerHTML = `
                                <div style="width: 100%; height: 100%; background: ${color.hex}; border-radius: 8px; display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; font-weight: bold;">
                                    <div style="font-size: 1.1em;">${color.name}</div>
                                    <div style="font-size: 0.9em; margin-top: 8px; opacity: 0.8;">ìƒì„± ì‹¤íŒ¨</div>
                                    <div style="font-size: 0.7em; margin-top: 4px; opacity: 0.6;">${error.message}</div>
                                </div>
                            `;
                        }
                    }
                    
                    // ê° ìƒ‰ìƒ ì²˜ë¦¬ í›„ ì§§ì€ ëŒ€ê¸° (ì„œë²„ ë¶€í•˜ ë°©ì§€)
                    if (i < colorRecommendations.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                }
                
                showToast('í—¤ì–´ì»¬ëŸ¬ ê°€ìƒì²´í—˜ ì™„ë£Œ!', 'success');
                
            } catch (error) {
                console.error('ì „ì²´ í”„ë¡œì„¸ìŠ¤ ì‹¤íŒ¨:', error);
                showToast('ê°€ìƒì²´í—˜ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤', 'error');
                
                // ì „ì²´ ì‹¤íŒ¨ ì‹œ ìƒ‰ìƒ í”„ë¦¬ë·° ê²°ê³¼ë¡œ í´ë°±
                displayColorPreviewResults(colorRecommendations, imageBase64);
            }
        }

        function displayVirtualTryResults(geminiResult, colorRecommendations, originalImageBase64) {
            try {
                const resultsSection = document.getElementById('results-section');
                if (!resultsSection) return;
                
                const existingVirtualTry = document.getElementById('virtual-try-results');
                if (existingVirtualTry) {
                    existingVirtualTry.remove();
                }
                
                const virtualTrySection = document.createElement('div');
                virtualTrySection.id = 'virtual-try-results';
                virtualTrySection.innerHTML = `
                    <div class="virtual-try-container" style="margin-top: 2rem; padding: 2rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 15px; color: white;">
                        <h4>ğŸ¤– AI í—¤ì–´ì»¬ëŸ¬ ê°€ìƒì²´í—˜ ê²°ê³¼</h4>
                        <div class="original-section" style="text-align: center; margin-bottom: 2rem;">
                            <h5>ì›ë³¸ ì‚¬ì§„</h5>
                            <img src="data:image/jpeg;base64,${originalImageBase64}" style="max-width: 250px; border-radius: 10px; border: 3px solid white;">
                        </div>
                        <div class="virtual-results-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1.5rem;">
                            ${colorRecommendations.map((color, index) => `
                                <div class="virtual-result-item" style="background: rgba(255,255,255,0.1); padding: 1.5rem; border-radius: 12px; text-align: center;">
                                    <div class="color-info" style="margin-bottom: 1rem;">
                                        <div style="display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 8px;">
                                            <div style="width: 30px; height: 30px; background: ${color.hex}; border-radius: 50%; border: 2px solid white;"></div>
                                            <h6 style="margin: 0;">${color.brand} ${color.code}</h6>
                                        </div>
                                        <p style="margin: 0; font-size: 0.9em; opacity: 0.9;">${color.name}</p>
                                    </div>
                                    <div class="virtual-image-container" id="virtual-image-${index}" style="width: 100%; height: 250px; background: rgba(255,255,255,0.2); border-radius: 8px; display: flex; align-items: center; justify-content: center; border: 2px dashed rgba(255,255,255,0.5);">
                                        <span style="opacity: 0.7;">ğŸ¨ AI ê°€ìƒì²´í—˜ ì´ë¯¸ì§€ ë¡œë”©ì¤‘...</span>
                                    </div>
                                    <div style="margin-top: 1rem; font-size: 0.8em; opacity: 0.8;">
                                        ${color.hex}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
                
                resultsSection.appendChild(virtualTrySection);
                virtualTrySection.scrollIntoView({ behavior: 'smooth' });
                
            } catch (error) {
                console.error('ê°€ìƒì²´í—˜ ê²°ê³¼ í‘œì‹œ ì‹¤íŒ¨:', error);
                displayColorPreviewResults(colorRecommendations, originalImageBase64);
            }
        }

        function displayColorPreviewResults(colorRecommendations, originalImageBase64) {
            const resultsSection = document.getElementById('results-section');
            if (!resultsSection) return;
            
            const existingVirtualTry = document.getElementById('virtual-try-results');
            if (existingVirtualTry) {
                existingVirtualTry.remove();
            }
            
            const virtualTrySection = document.createElement('div');
            virtualTrySection.id = 'virtual-try-results';
            virtualTrySection.innerHTML = `
                <div class="virtual-try-container" style="margin-top: 2rem; padding: 2rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 15px; color: white;">
                    <h4>ğŸ¨ í¼ìŠ¤ë„ì»¬ëŸ¬ ë§ì¶¤ í—¤ì–´ì»¬ëŸ¬ ì¶”ì²œ</h4>
                    <p style="margin-bottom: 2rem;">ê³¼í•™ì  ë¶„ì„ ê²°ê³¼ì— ë”°ë¼ ì„ ì •ëœ 5ê°€ì§€ í—¤ì–´ì»¬ëŸ¬ì…ë‹ˆë‹¤.</p>
                    <div class="virtual-try-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1.5rem;">
                        ${colorRecommendations.map((color, index) => `
                            <div class="virtual-try-item" style="background: rgba(255,255,255,0.1); padding: 1.5rem; border-radius: 12px; text-align: center;">
                                <div class="color-info" style="margin-bottom: 1rem;">
                                    <div style="display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 8px;">
                                        <div style="width: 40px; height: 40px; background: ${color.hex}; border-radius: 50%; border: 3px solid white;"></div>
                                        <h6 style="margin: 0;">${color.brand} ${color.code}</h6>
                                    </div>
                                    <p style="margin: 0; font-size: 0.9em; opacity: 0.9;">${color.name}</p>
                                    <p style="margin: 5px 0 0 0; font-size: 0.8em; opacity: 0.8;">${color.description}</p>
                                </div>
                                <div style="width: 100%; height: 200px; background: ${color.hex}; border-radius: 8px; display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; font-weight: bold; text-align: center;">
                                    <div style="font-size: 1.2em; margin-bottom: 8px;">${color.name}</div>
                                    <div style="font-size: 0.9em; opacity: 0.9;">${color.brand} ${color.code}</div>
                                    <div style="font-size: 0.8em; margin-top: 8px; opacity: 0.8;">ğŸ¨ ìƒ‰ìƒ í”„ë¦¬ë·°</div>
                                </div>
                                <div style="margin-top: 1rem; font-size: 0.8em; opacity: 0.8;">
                                    ${color.hex}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
            
            resultsSection.appendChild(virtualTrySection);
            virtualTrySection.scrollIntoView({ behavior: 'smooth' });
        }

        // ========================================
        // ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
        // ========================================
        function generateExpertAnalysis(season) {
            const analyses = {
                'ë´„ ì›œí†¤': ExpertKnowledge.colorMatching.warm + " ë°ê³  ì„ ëª…í•œ ìƒ‰ìƒì´ ì˜ ì–´ìš¸ë¦½ë‹ˆë‹¤.",
                'ì—¬ë¦„ ì¿¨í†¤': ExpertKnowledge.skinAnalysis.principle + " ë¶€ë“œëŸ¬ìš´ íŒŒìŠ¤í…” í†¤ì„ ì¶”ì²œí•©ë‹ˆë‹¤.",
                'ê°€ì„ ì›œí†¤': "ê¹Šê³  ë”°ëœ»í•œ ìƒ‰ìƒì´ ì í•©í•©ë‹ˆë‹¤. ë¦¬ì¹˜í•œ ë¸Œë¼ìš´ ê³„ì—´ì„ ê¶Œì¥í•©ë‹ˆë‹¤.",
                'ê²¨ìš¸ ì¿¨í†¤': ExpertKnowledge.colorMatching.cool + " ì§„í•˜ê³  ì„ ëª…í•œ ìƒ‰ìƒì´ ì í•©í•©ë‹ˆë‹¤."
            };
            
            return analyses[season] || 'ì „ë¬¸ê°€ ë¶„ì„ ê²°ê³¼ë¥¼ ìƒì„± ì¤‘ì…ë‹ˆë‹¤.';
        }

        function showToast(message, type = 'info', duration = 3000) {
            const existingToast = document.querySelector('.toast');
            if (existingToast) {
                existingToast.remove();
            }
            
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            toast.style.cssText = `
                position: fixed; top: 20px; right: 20px; z-index: 10000;
                background: white; padding: 1rem 1.5rem; border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15); border-left: 4px solid;
                border-left-color: ${type === 'success' ? '#4CAF50' : type === 'error' ? '#F44336' : type === 'warning' ? '#FF9800' : '#2196F3'};
                transform: translateX(100%); transition: transform 0.3s ease;
            `;
            
            document.body.appendChild(toast);
            
            setTimeout(() => toast.style.transform = 'translateX(0)', 100);
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.style.transform = 'translateX(100%)';
                    setTimeout(() => toast.remove(), 300);
                }
            }, duration);
        }

        // ========================================
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        // ========================================
        document.addEventListener('keydown', function(event) {
            if (event.code === 'Space' && currentMode === 'ai' && !analysisInProgress) {
                event.preventDefault();
                analyzeAI();
            }
            
            if (event.key === 'Escape') {
                goHome();
            }
        });

        window.addEventListener('beforeunload', function() {
            cleanupCameraResources();
            stopDrapingCamera();
        });

        console.log('ğŸ¨ HAIRGATOR Personal Color - ê³¼í•™ì  AI ë¶„ì„ ìµœì¢… ë²„ì „ ë¡œë“œ ì™„ë£Œ');
        console.log('ğŸ”¬ Delta E 2000 ìƒ‰ì°¨ ê³„ì‚° ë° LAB ìƒ‰ê³µê°„ ë¶„ì„ ì§€ì›');
        console.log('ğŸ¤– ì œë¯¸ë‚˜ì´ ìˆœì°¨ ì²˜ë¦¬ íƒ€ì„ì•„ì›ƒ ë¬¸ì œ í•´ê²°');
    </script>
</body>
</html>
            } else {
                if (faceDetected) {
                    faceDetected = false;
                    document.getElementById('ai-face-guide').style.display = 'flex';
                    clearSkinToneDisplay();
                }
            }
        }

        function drawFullFaceMesh(ctx, landmarks) {
            const FACE_CONNECTIONS = [
                [10, 338], [338, 297], [297, 332], [332, 284], [284, 251], [251, 389], [389, 356], [356, 454], 
                [454, 323], [323, 361], [361, 288], [288, 397], [397, 365], [365, 379], [379, 378], [378, 400], 
                [400, 377], [377, 152], [152, 148], [148, 176], [176, 149], [149, 150], [150, 136], [136, 172], 
                [172, 58], [58, 132], [132, 93], [93, 234], [234, 127], [127, 162], [162, 21], [21, 54], 
                [54, 103], [103, 67], [67, 109], [109, 10]
            ];
            
            ctx.fillStyle = '#00FF88';
            landmarks.forEach((landmark, index) => {
                const x = landmark.x * canvasElement.width;
                const y = landmark.y * canvasElement.height;
                
                ctx.beginPath();
                ctx.arc(x, y, 1.5, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            ctx.strokeStyle = '#00FF8860';
            ctx.lineWidth = 0.8;
            
            FACE_CONNECTIONS.forEach(connection => {
                const [startIdx, endIdx] = connection;
                
                if (landmarks[startIdx] && landmarks[endIdx]) {
                    const start = landmarks[startIdx];
                    const end = landmarks[endIdx];
                    
                    const startX = start.x * canvasElement.width;
                    const startY = start.y * canvasElement.height;
                    const endX = end.x * canvasElement.width;
                    const endY = end.y * canvasElement.height;
                    
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                }
            });
        }

        function drawSkinTonePoints(ctx, landmarks) {
            const skinPoints = [
                { index: 10, name: 'ì´ë§ˆì¤‘ì•™', color: '#FF6B6B' },
                { index: 151, name: 'ì½”ë', color: '#4ECDC4' },
                { index: 116, name: 'ì¢Œì¸¡ë³¼', color: '#45B7D1' },
                { index: 345, name: 'ìš°ì¸¡ë³¼', color: '#96CEB4' },
                { index: 175, name: 'í„±ì¤‘ì•™', color: '#FECA57' }
            ];
            
            skinPoints.forEach((point) => {
                if (landmarks[point.index]) {
                    const landmark = landmarks[point.index];
                    const x = landmark.x * canvasElement.width;
                    const y = landmark.y * canvasElement.height;
                    
                    ctx.strokeStyle = point.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, 2 * Math.PI);
                    ctx.stroke();
                    
                    ctx.fillStyle = point.color + '40';
                    ctx.fill();
                    
                    ctx.fillStyle = point.color;
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });
        }

        function displayRealtimeAnalysis(skinData) {
            if (!skinData) return;
            
            let analysisPanel = document.getElementById('realtime-skin-analysis');
            if (!analysisPanel) {
                analysisPanel = document.createElement('div');
                analysisPanel.id = 'realtime-skin-analysis';
                analysisPanel.style.cssText = `
                    position: absolute; 
                    bottom: 10px; 
                    left: 10px; 
                    right: 10px;
                    background: linear-gradient(135deg, rgba(0,0,0,0.85), rgba(0,50,0,0.8)); 
                    color: white; 
                    padding: 0.4rem 0.8rem; 
                    border-radius: 6px; 
                    font-size: 0.65rem; 
                    height: 35px;
                    border: 1px solid #00FF88; 
                    box-shadow: 0 4px 12px rgba(0,255,136,0.4);
                    backdrop-filter: blur(5px);
                    z-index: 1001;
                `;
                document.querySelector('.video-container').appendChild(analysisPanel);
            }
            
            const hexColor = `#${skinData.rgb.r.toString(16).padStart(2, '0')}${skinData.rgb.g.toString(16).padStart(2, '0')}${skinData.rgb.b.toString(16).padStart(2, '0')}`;
            
            analysisPanel.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: space-between; height: 100%; font-size: 0.6rem;">
                    <span style="color: #00FF88; font-weight: bold;">ğŸ”¬ ê³¼í•™ì  ë¶„ì„</span>
                    <div style="width: 22px; height: 22px; background: ${hexColor}; border-radius: 4px; border: 2px solid white; box-shadow: 0 0 4px rgba(0,0,0,0.3);"></div>
                    <span style="color: white;">ìƒ˜í”Œ:${skinData.totalSamples}</span>
                    <span style="color: #00FF88; font-weight: 600;">RGB(${skinData.rgb.r},${skinData.rgb.g},${skinData.rgb.b})</span>
                    <span style="color: #4CAF50; font-weight: bold;">ì¤€ë¹„ì™„ë£Œ</span>
                </div>
            `;
        }

        function clearSkinToneDisplay() {
            const panel = document.getElementById('realtime-skin-analysis');
            if (panel) panel.remove();
        }

        function stopAICamera() {
            console.log('AI ì¹´ë©”ë¼ ì¤‘ì§€ ìš”ì²­');
            cleanupCameraResources();
            showToast('AI ì¹´ë©”ë¼ê°€ ì •ì§€ë˜ì—ˆìŠµë‹ˆë‹¤', 'info');
        }

        function cleanupCameraResources() {
            console.log('ì¹´ë©”ë¼ ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì‹œì‘...');
            
            try {
                if (mediaPipeCamera) {
                    mediaPipeCamera.stop();
                    mediaPipeCamera = null;
                }
                
                if (faceDetectionInstance) {
                    try {
                        faceDetectionInstance.close();
                    } catch (e) {
                        console.warn('FaceDetection close ì‹¤íŒ¨:', e);
                    }
                    faceDetectionInstance = null;
                }
                
                if (activeVideoStream) {
                    activeVideoStream.getTracks().forEach(track => {
                        track.stop();
                    });
                    activeVideoStream = null;
                }
                
                if (videoElement) {
                    videoElement.srcObject = null;
                    videoElement.pause();
                }
                
                if (canvasCtx && canvasElement) {
                    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                }
                
                faceDetected = false;
                
                const faceGuide = document.getElementById('ai-face-guide');
                if (faceGuide) faceGuide.style.display = 'flex';
                
                const analysisPanel = document.getElementById('realtime-skin-analysis');
                if (analysisPanel) analysisPanel.remove();
                
                if (sharedExtractCanvas) {
                    sharedExtractCanvas = null;
                    sharedExtractCtx = null;
                    console.log('ê³µìœ  Canvas ì •ë¦¬ ì™„ë£Œ');
                }
                
                console.log('ëª¨ë“  ì¹´ë©”ë¼ ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì™„ë£Œ');
                
            } catch (error) {
                console.error('ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì¤‘ ì˜¤ë¥˜:', error);
            }
        }

        // ========================================
        // AI ë¶„ì„ í•¨ìˆ˜ë“¤ (ê³¼í•™ì  ë²„ì „)
        // ========================================
        async function analyzeAI() {
            if (analysisInProgress) return;
            
            if (!videoElement || videoElement.readyState !== 4) {
                showToast('ë¨¼ì € ì¹´ë©”ë¼ë¥¼ ì‹œì‘í•´ì£¼ì„¸ìš”', 'warning');
                return;
            }
            
            if (!faceDetected) {
                showToast('ì–¼êµ´ì´ ê°ì§€ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. í™”ë©´ì— ì–¼êµ´ì„ ë§ì¶°ì£¼ì„¸ìš”', 'warning');
                return;
            }
            
            analysisInProgress = true;
            showToast('ê³¼í•™ì  AI ë¶„ì„ì„ ì‹œì‘í•©ë‹ˆë‹¤...', 'info');
            
            const capturedImage = captureCurrentFrame();
            
            if (capturedImage) {
                await performScientificAnalysisSteps();
                const recommendedColors = getRecommendedHairColors();
                await sendToGeminiForVirtualTry(capturedImage, recommendedColors);
            } else {
                showToast('ì‚¬ì§„ ì´¬ì˜ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.', 'error');
            }
            
            analysisInProgress = false;
        }

        async function performScientificAnalysisSteps() {
            const steps = [
                { id: 'ai-step-1', message: '468í¬ì¸íŠ¸ ì–¼êµ´ ì˜ì—­ ê°ì§€ ì¤‘...' },
                { id: 'ai-step-2', message: 'ë‹¤ì¤‘ ì˜ì—­ í”¼ë¶€í†¤ ë¶„ì„ ì¤‘...' },
                { id: 'ai-step-3', message: 'Delta E 2000 ìƒ‰ì°¨ ê³„ì‚° ì¤‘...' },
                { id: 'ai-step-4', message: 'ê³¼í•™ì  ê²°ê³¼ ìƒì„± ì¤‘...' }
            ];

            for (let i = 0; i < steps.length; i++) {
                const step = steps[i];
                
                document.getElementById(step.id).classList.add('active');
                await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 1000));
                document.getElementById(step.id).classList.remove('active');
                document.getElementById(step.id).classList.add('completed');
            }

            const result = await generateScientificAnalysisResult();
            displayAIAnalysisResult(result);
        }

        async function generateScientificAnalysisResult() {
            try {
                if (!scientificAnalyzer || !faceDetectionInstance) {
                    throw new Error('ê³¼í•™ì  ë¶„ì„ê¸°ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');
                }

                // í˜„ì¬ ì–¼êµ´ ëœë“œë§ˆí¬ë¥¼ ê°€ì ¸ì™€ì„œ ë¶„ì„
                return new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        reject(new Error('ë¶„ì„ ì‹œê°„ ì´ˆê³¼'));
                    }, 10000);

                    const getCurrentLandmarks = () => {
                        if (faceDetectionInstance && videoElement.readyState === 4) {
                            faceDetectionInstance.send({ image: videoElement }).then(() => {
                                // onAdvancedFaceResultsì—ì„œ ê²°ê³¼ë¥¼ ë°›ì„ ë•Œê¹Œì§€ ëŒ€ê¸°
                                const checkResults = () => {
                                    if (window.lastLandmarks) {
                                        clearTimeout(timeout);
                                        try {
                                            const result = scientificAnalyzer.analyzePersonalColor(window.lastLandmarks, videoElement);
                                            resolve(result);
                                        } catch (error) {
                                            reject(error);
                                        }
                                    } else {
                                        setTimeout(checkResults, 100);
                                    }
                                };
                                checkResults();
                            }).catch(reject);
                        } else {
                            reject(new Error('ì–¼êµ´ ê°ì§€ ì‹œìŠ¤í…œì´ ì¤€ë¹„ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤'));
                        }
                    };

                    getCurrentLandmarks();
                });

            } catch (error) {
                console.error('ê³¼í•™ì  ë¶„ì„ ì‹¤íŒ¨:', error);
                // í´ë°±: ê¸°ë³¸ ë¶„ì„ ê²°ê³¼ ìƒì„±
                const seasons = ['ë´„ ì›œí†¤', 'ì—¬ë¦„ ì¿¨í†¤', 'ê°€ì„ ì›œí†¤', 'ê²¨ìš¸ ì¿¨í†¤'];
                const selectedSeason = seasons[Math.floor(Math.random() * seasons.length)];
                
                return {
                    season: selectedSeason,
                    confidence: 75 + Math.floor(Math.random() * 15),
                    skinColor: {
                        r: 150 + Math.floor(Math.random() * 50),
                        g: 120 + Math.floor(Math.random() * 40),
                        b: 100 + Math.floor(Math.random() * 30)
                    },
                    expertAnalysis: 'ê¸°ë³¸ ë¶„ì„ì´ ìˆ˜í–‰ë˜ì—ˆìŠµë‹ˆë‹¤. ê³¼í•™ì  ë¶„ì„ì„ ìœ„í•´ ì–¼êµ´ì„ ë‹¤ì‹œ ì¸ì‹í•´ì£¼ì„¸ìš”.',
                    labValues: { L: 65, a: 10, b: 15 },
                    deltaEScores: {},
                    minDeltaE: 5.0,
                    totalSamples: 1000
                };
            }
        }

        // onAdvancedFaceResults í•¨ìˆ˜ ìˆ˜ì •í•˜ì—¬ ëœë“œë§ˆí¬ ì €ì¥
        function onAdvancedFaceResults(results) {
            if (!canvasCtx || !videoElement) return;
            
            canvasElement.width = videoElement.videoWidth || 640;
            canvasElement.height = videoElement.videoHeight || 480;
            
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                
                // ì „ì—­ ë³€ìˆ˜ì— ëœë“œë§ˆí¬ ì €ì¥
                window.lastLandmarks = landmarks;
                
                drawFullFaceMesh(canvasCtx, landmarks);
                drawSkinTonePoints(canvasCtx, landmarks);
                
                if (scientificAnalyzer) {
                    try {
                        const analysisData = scientificAnalyzer.extractSkinColor(landmarks, videoElement);
                        displayRealtimeAnalysis(analysisData);
                    } catch (error) {
                        console.warn('ì‹¤ì‹œê°„ ë¶„ì„ ì˜¤ë¥˜:', error);
                    }
                }
