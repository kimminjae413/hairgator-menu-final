<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>HAIRGATOR Personal Color</title>

    <!-- MediaPipe CDN -->
    <script crossorigin="anonymous" src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script crossorigin="anonymous"
        src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script crossorigin="anonymous"
        src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script crossorigin="anonymous"
        src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/face_mesh.js"></script>

    <link rel="stylesheet" href="styles.css">
    <!-- ë‹¤êµ­ì–´ ì‹œìŠ¤í…œ -->
    <script src="../js/i18n.js"></script>
    <style>
        @keyframes flashFade {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        /* ì•±ìš© í—¤ë” ìŠ¤íƒ€ì¼ */
        #ai-analysis.active .section-nav,
        #draping-mode.active .section-nav {
            position: sticky !important;
            top: 0 !important;
            z-index: 100 !important;
            background: #1a1c2e !important;
            margin: 0 -20px 0 -20px !important;
            padding: 70px 20px 25px 20px !important;
            padding-top: calc(70px + env(safe-area-inset-top, 0px)) !important;
            border-radius: 0 !important;
            border-bottom: 2px solid #2d1f3d !important;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5) !important;
        }
    </style>
</head>

<body>
    <script>
        // URL íŒŒë¼ë¯¸í„°ì—ì„œ ì„±ë³„ ì½ì–´ì„œ í…Œë§ˆ ì ìš©
        (function() {
            const urlParams = new URLSearchParams(window.location.search);
            const gender = urlParams.get('gender');
            if (gender === 'male') {
                document.body.classList.add('male-theme');
            }
        })();
    </script>
    <!-- ë¡œë”© í™”ë©´ -->
    <div class="loading-screen" id="loading-screen">
        <div class="loading-content">
            <img src="/ë¡œê³ .png" alt="HAIRGATOR" class="loading-logo">
            <h2 class="loading-title">HAIRGATOR</h2>
            <p class="loading-text" id="loading-text">ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì¤‘...</p>
            <div class="loading-progress">
                <div class="loading-bar" id="loading-bar"></div>
            </div>
        </div>
    </div>

    <!-- ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ -->
    <div class="main-app" id="main-app">
        <!-- ë‹«ê¸° ë²„íŠ¼ë§Œ (í—¤ë” ì œê±°) -->
        <button class="close-btn-floating" onclick="closePersonalColor()" title="ë‹«ê¸°" data-i18n="common.close">ë‹«ê¸°</button>

        <main class="main-content">
            <!-- ëª¨ë“œ ì„ íƒ ì„¹ì…˜ -->
            <section class="section active" id="mode-selection">
                <div class="mode-cards">
                    <!-- AI ë¶„ì„ ì¹´ë“œ -->
                    <div class="mode-card mode-card-image" onclick="selectMode('ai')">
                        <div class="mode-card-img-wrapper">
                            <img src="images/ai-analysis.jpeg" alt="AI Personal Color Analysis" class="mode-card-img">
                        </div>
                        <div class="mode-description-bubble" data-i18n="personalColor.aiMode.description">
                            ì‹¤ì‹œê°„ ì¹´ë©”ë¼ë¡œ AIê°€ í”¼ë¶€í†¤ì„ ë¶„ì„í•©ë‹ˆë‹¤. ì •í™•í•œ ì§„ë‹¨ì„ ìœ„í•´ í™”ì¥ê¸° ì—†ëŠ” ë§¨ì–¼êµ´ë¡œ, ìì—°ê´‘ì—ì„œ ì´¬ì˜í•´ì£¼ì„¸ìš”.
                        </div>
                        <button class="mode-btn" data-i18n="personalColor.aiMode.startBtn">AI ë¶„ì„ ì‹œì‘</button>
                    </div>

                    <!-- ë“œë˜ì´í•‘ ì¹´ë“œ -->
                    <div class="mode-card mode-card-image" onclick="selectMode('draping')">
                        <div class="mode-card-img-wrapper">
                            <img src="images/draping.jpeg" alt="Expert Draping" class="mode-card-img">
                        </div>
                        <div class="mode-description-bubble" data-i18n="personalColor.drapingMode.description">
                            ë´„, ì—¬ë¦„, ê°€ì„, ê²¨ìš¸ 4ê³„ì ˆ ì»¬ëŸ¬ë¥¼ ì–¼êµ´ì— ëŒ€ë³´ë©° ê°€ì¥ ì˜ ì–´ìš¸ë¦¬ëŠ” ìƒ‰ìƒì„ ì§ì ‘ ì°¾ì•„ë³´ì„¸ìš”.
                        </div>
                        <button class="mode-btn" data-i18n="personalColor.drapingMode.startBtn">ë“œë˜ì´í•‘ ì‹œì‘</button>
                    </div>
                </div>
            </section>

            <!-- AI ë¶„ì„ ëª¨ë“œ -->
            <section class="section" id="ai-analysis">
                <div class="section-nav">
                    <button class="nav-btn" onclick="goHome()" data-i18n="personalColor.aiMode.backHome">â† í™ˆìœ¼ë¡œ</button>
                    <h2 class="section-title" data-i18n="personalColor.aiMode.title">AI í¼ìŠ¤ë„ì»¬ëŸ¬ ë¶„ì„</h2>
                </div>

                <div class="analysis-grid">
                    <!-- ì¹´ë©”ë¼ ì˜ì—­ -->
                    <div class="camera-container">
                        <div class="video-container">
                            <video id="camera-feed" autoplay muted playsinline style="display:none;"></video>
                            <canvas id="camera-canvas" style="width: 100%; max-width: 640px; border-radius: 8px;"></canvas>
                            <div class="face-guide" id="ai-face-guide" data-i18n-html="personalColor.aiMode.faceGuide">
                                ì–¼êµ´ì„ í™”ë©´ ì¤‘ì•™ì—<br>ìœ„ì¹˜ì‹œì¼œì£¼ì„¸ìš”
                            </div>
                        </div>
                        <div class="camera-controls">
                            <button class="control-btn" id="start-camera" onclick="startAICamera()" data-i18n="personalColor.aiMode.startCamera">ğŸ“¹ ì¹´ë©”ë¼ ì‹œì‘</button>
                            <button class="control-btn" id="capture-btn" onclick="captureAndAnalyze()" style="display: none; background: linear-gradient(135deg, #FF6B6B, #FF8E53);" data-i18n="personalColor.aiMode.capture">ğŸ“¸ ì´¬ì˜í•˜ê¸°</button>
                            <button class="control-btn" id="retry-btn" onclick="retryCapture()" style="display: none; background: linear-gradient(135deg, #6B7FFF, #53A8FF);" data-i18n="personalColor.aiMode.retry">ğŸ”„ ë‹¤ì‹œ ì´¬ì˜</button>
                        </div>

                        <!-- ì´¬ì˜ ì•ˆë‚´ ë©”ì‹œì§€ -->
                        <div id="capture-guide" style="display: none; margin-top: 15px; padding: 12px; background: rgba(255,180,0,0.15); border: 1px solid rgba(255,180,0,0.3); border-radius: 8px; text-align: center;">
                            <span style="color: #FFB400; font-size: 14px;" data-i18n-html="personalColor.aiMode.captureGuide">âœ¨ ì–¼êµ´ì´ ì¸ì‹ë˜ì—ˆìŠµë‹ˆë‹¤! <b>ì´¬ì˜í•˜ê¸°</b> ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”</span>
                        </div>

                        <!-- â­ ë¶„ì„ ê²°ê³¼ í‘œì‹œ (ì´¬ì˜ í›„) -->
                        <div class="realtime-results" style="margin-top: 20px; padding: 20px; background: rgba(255,255,255,0.05); border-radius: 8px; display: none;" id="realtime-results-container">
                            <h4 style="margin: 0 0 15px 0; color: #fff;">ğŸ¨ í¼ìŠ¤ë„ì»¬ëŸ¬ ë¶„ì„ ê²°ê³¼</h4>
                            <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 6px; margin-bottom: 10px;">
                                <div style="font-size: 24px; font-weight: bold; margin-bottom: 8px;" id="realtime-season">ë¶„ì„ ì¤‘...</div>
                                <div style="font-size: 14px; line-height: 1.6; color: #ccc;" id="realtime-skin-info"></div>
                            </div>
                            <div style="font-size: 14px; line-height: 1.8; color: #eee;" id="realtime-recommendation"></div>
                        </div>
                    </div>

                    <!-- ë¶„ì„ íŒ¨ë„ -->
                    <div class="analysis-panel">
                        <h3 data-i18n="personalColor.aiMode.steps.title">AI ë¶„ì„ ì§„í–‰ìƒí™©</h3>
                        <div class="analysis-steps">
                            <div class="analysis-step" id="ai-step-1">
                                <div class="step-number">1</div>
                                <div class="step-content">
                                    <h4 data-i18n="personalColor.aiMode.steps.step1">ì–¼êµ´ ì¸ì‹</h4>
                                    <p data-i18n="personalColor.aiMode.steps.step1Desc">MediaPipeë¡œ ì–¼êµ´ ì˜ì—­ì„ ê°ì§€í•©ë‹ˆë‹¤</p>
                                </div>
                            </div>

                            <div class="analysis-step" id="ai-step-2">
                                <div class="step-number">2</div>
                                <div class="step-content">
                                    <h4 data-i18n="personalColor.aiMode.steps.step2">í”¼ë¶€í†¤ ë¶„ì„</h4>
                                    <p data-i18n="personalColor.aiMode.steps.step2Desc">RGB â†’ LAB ìƒ‰ê³µê°„ ë³€í™˜ ë° ìƒ‰ìƒ ì¶”ì¶œ</p>
                                </div>
                            </div>

                            <div class="analysis-step" id="ai-step-3">
                                <div class="step-number">3</div>
                                <div class="step-content">
                                    <h4 data-i18n="personalColor.aiMode.steps.step3">Delta E ê³„ì‚°</h4>
                                    <p data-i18n="personalColor.aiMode.steps.step3Desc">ìƒ‰ì°¨ ì¸¡ì • ë° ì •í™•ë„ ì‚°ì¶œ</p>
                                </div>
                            </div>

                            <div class="analysis-step" id="ai-step-4">
                                <div class="step-number">4</div>
                                <div class="step-content">
                                    <h4 data-i18n="personalColor.aiMode.steps.step4">ê²°ê³¼ ìƒì„±</h4>
                                    <p data-i18n="personalColor.aiMode.steps.step4Desc">ì „ë¬¸ê°€ ë…¸í•˜ìš° ê¸°ë°˜ ìµœì¢… ì§„ë‹¨</p>
                                </div>
                            </div>
                        </div>

                        <div class="analysis-results" id="ai-analysis-results" style="display: none;">
                            <h4>ë¶„ì„ ê²°ê³¼</h4>
                            <div class="result-summary">
                                <div class="season-result" id="ai-season-result">ë¶„ì„ ì¤‘...</div>
                                <div class="confidence-score" id="ai-confidence">-</div>
                            </div>
                            <div class="color-analysis-data" id="ai-analysis-data">
                                <!-- ìƒì„¸ ë°ì´í„°ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤ -->
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- ë“œë˜ì´í•‘ ëª¨ë“œ -->
            <section class="section" id="draping-mode">
                <div class="section-nav">
                    <button class="nav-btn" onclick="goHome()">â† í™ˆìœ¼ë¡œ</button>
                    <h2 class="section-title">ì „ë¬¸ê°€ ë“œë˜ì´í•‘ ëª¨ë“œ</h2>
                </div>

                <div class="draping-layout">
                    <!-- ë“œë˜ì´í•‘ ì¹´ë©”ë¼ -->
                    <div class="draping-camera-section">
                        <div class="video-container">
                            <video id="draping-camera" autoplay muted playsinline></video>
                            <canvas id="draping-overlay"></canvas>
                            <div class="face-guide" id="draping-face-guide">
                                ì–¼êµ´ì„ ê°€ì´ë“œë¼ì¸ì—<br>ë§ì¶°ì£¼ì„¸ìš”
                            </div>
                        </div>

                        <div class="camera-controls">
                            <button class="control-btn" onclick="startDrapingCamera()">ì¹´ë©”ë¼ ì‹œì‘</button>
                            <button class="control-btn" onclick="saveCurrentColor()">í˜„ì¬ ìƒ‰ìƒ ì €ì¥</button>
                        </div>
                    </div>

                    <!-- ìƒ‰ìƒ íŒ”ë ˆíŠ¸ -->
                    <div class="color-palette-section">
                        <h3>4ê³„ì ˆ ìƒ‰ìƒ íŒ”ë ˆíŠ¸</h3>

                        <!-- ê³„ì ˆ íƒ­ -->
                        <div class="season-tabs">
                            <button class="season-tab active" data-season="spring"
                                onclick="selectSeason('spring')">ë´„</button>
                            <button class="season-tab" data-season="summer" onclick="selectSeason('summer')">ì—¬ë¦„</button>
                            <button class="season-tab" data-season="autumn" onclick="selectSeason('autumn')">ê°€ì„</button>
                            <button class="season-tab" data-season="winter" onclick="selectSeason('winter')">ê²¨ìš¸</button>
                        </div>

                        <!-- ìƒ‰ìƒ ê·¸ë¦¬ë“œ -->
                        <div class="color-grid" id="color-grid">
                            <!-- ë™ì ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤ -->
                        </div>

                        <!-- ì„¸ë¶€ ì¡°ì • -->
                        <div class="color-adjustments">
                            <h4>ìƒ‰ìƒ ì„¸ë¶€ ì¡°ì •</h4>

                            <div class="adjustment-slider">
                                <label>ëª…ë„</label>
                                <input type="range" id="lightness-slider" min="-30" max="30" value="0"
                                    oninput="adjustColor()">
                                <span id="lightness-value">0</span>
                            </div>

                            <div class="adjustment-slider">
                                <label>ì±„ë„</label>
                                <input type="range" id="saturation-slider" min="-50" max="50" value="0"
                                    oninput="adjustColor()">
                                <span id="saturation-value">0</span>
                            </div>

                            <div class="adjustment-slider">
                                <label>ì˜¨ë„ê°</label>
                                <input type="range" id="warmth-slider" min="-40" max="40" value="0"
                                    oninput="adjustColor()">
                                <span id="warmth-value">0</span>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- ê³µí†µ ê²°ê³¼ ì„¹ì…˜ -->
            <div class="results-section" id="results-section" style="display: none;">
                <h3>í¼ìŠ¤ë„ì»¬ëŸ¬ ì§„ë‹¨ ê²°ê³¼</h3>
                <div class="final-results" id="final-results">
                    <!-- ê²°ê³¼ ë‚´ìš©ì´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤ -->
                </div>

                <div class="product-recommendations" id="product-recommendations">
                    <h4>ì¶”ì²œ í—¤ì–´ì»¬ëŸ¬ ì œí’ˆ</h4>
                    <div class="brand-sections" id="brand-sections">
                        <!-- ë¸Œëœë“œë³„ ì œí’ˆ ì¶”ì²œì´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤ -->
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // ë¶€ëª¨ ì°½ì—ì„œ t() í•¨ìˆ˜ ê°€ì ¸ì˜¤ê¸°
        function t(key) {
            try {
                // ë¶€ëª¨ ì°½ì˜ t í•¨ìˆ˜ ì‚¬ìš©
                if (parent && parent.t && typeof parent.t === 'function') {
                    return parent.t(key);
                }
                // ìì²´ HAIRGATOR_I18N ì‚¬ìš©
                if (typeof HAIRGATOR_I18N !== 'undefined' && currentLang) {
                    const keys = key.split('.');
                    let result = HAIRGATOR_I18N[currentLang];
                    for (const k of keys) {
                        if (result && result[k]) {
                            result = result[k];
                        } else {
                            return null;
                        }
                    }
                    return typeof result === 'string' ? result : null;
                }
                return null;
            } catch (e) {
                return null;
            }
        }

        // ì „ì—­ ë³€ìˆ˜ ì •ì˜
        let currentMode = null;
        let analysisInProgress = false;
        let faceDetected = false;
        let hairColorData = [];
        let videoElement = null;
        let canvasElement = null;
        let canvasCtx = null;
        let currentSeason = 'spring';
        let selectedColor = null;
        let savedColors = [];
        let activeVideoStream = null;
        let mediaPipeCamera = null;
        let faceDetectionInstance = null;
        let sharedExtractCanvas = null;    // ì—¬ê¸°ë¡œ ì´ë™
        let sharedExtractCtx = null;       // ì—¬ê¸°ë¡œ ì´ë™

        // ì „ë¬¸ê°€ ë…¸í•˜ìš° ë°ì´í„°
        const ExpertKnowledge = {
            colorTheory: {
                warmCool: "ì£¼í™©ìƒ‰ì€ ì›œí†¤ì˜ ëŒ€í‘œì ì¸ ìƒ‰ìƒì´ë©° ì¿¨í†¤ìœ¼ë¡œ ë³€í™˜ì´ ì–´ë µìŠµë‹ˆë‹¤",
                foundation: "íŒŒìš´ë°ì´ì…˜ 21-23í˜¸ëŒ€ëŠ” ë¹„ìŠ·í•œ ëª…ë„ì˜ í—¤ì–´ì»¬ëŸ¬ì™€ ë§¤ì¹˜í•  ë•Œ ì£¼ì˜ê°€ í•„ìš”í•©ë‹ˆë‹¤"
            },
            skinAnalysis: {
                redness: "í™ì¡° í”¼ë¶€ëŠ” ë¯¸ë“œë‚˜ì‡ ì»¬ëŸ¬ë¡œ ì¤‘í™”ì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤",
                principle: "ëª…ë„ì™€ ì±„ë„ì˜ ì¡°í•©ì´ ìƒ‰ìƒ ì´ë¦„ë³´ë‹¤ ì¤‘ìš”í•©ë‹ˆë‹¤"
            },
            colorMatching: {
                warm: "ì•„ì´ë³´ë¦¬ í”¼ë¶€ì—ëŠ” ì½”í† ë¦¬ë² ì´ì§€ë‚˜ ì˜¤ë Œì§€ë¸Œë¼ìš´ì´ ì˜ ì–´ìš¸ë¦½ë‹ˆë‹¤",
                cool: "í™”ì´íŠ¸ í”¼ë¶€ì—ëŠ” ë¸”ë£¨ë¸”ë™ì´ë‚˜ ì• ì‰¬ë¸”ë£¨ê°€ ì í•©í•©ë‹ˆë‹¤"
            }
        };

        // ê³„ì ˆë³„ ìƒ‰ìƒ íŒ”ë ˆíŠ¸
        const SeasonPalettes = {
            spring: {
                colors: ['#FFB6C1', '#FFA07A', '#F0E68C', '#98FB98', '#FFE4B5', '#DDA0DD'],
                characteristics: ['ë°ê³  ë”°ëœ»í•œ ìƒ‰ìƒ', 'ë†’ì€ ì±„ë„', 'ë…¸ë€ ì–¸ë”í†¤']
            },
            summer: {
                colors: ['#B0E0E6', '#DDA0DD', '#C8B2DB', '#AFEEEE', '#F0F8FF', '#E6E6FA'],
                characteristics: ['ë¶€ë“œëŸ½ê³  ì°¨ê°€ìš´ ìƒ‰ìƒ', 'ì¤‘ê°„ ì±„ë„', 'íŒŒë€ ì–¸ë”í†¤']
            },
            autumn: {
                colors: ['#D2691E', '#CD853F', '#A0522D', '#8B4513', '#B22222', '#800000'],
                characteristics: ['ê¹Šê³  ë”°ëœ»í•œ ìƒ‰ìƒ', 'ë‚®ì€ ì±„ë„', 'ë…¸ë€ ì–¸ë”í†¤']
            },
            winter: {
                colors: ['#000080', '#4B0082', '#8B008B', '#191970', '#2F4F4F', '#708090'],
                characteristics: ['ì§„í•˜ê³  ì°¨ê°€ìš´ ìƒ‰ìƒ', 'ë†’ì€ ëŒ€ë¹„', 'íŒŒë€ ì–¸ë”í†¤']
            }
        };

        // ========================================
        // ğŸ¯ ìƒˆë¡œìš´ 4ë‹¨ê³„ íŒŒì´í”„ë¼ì¸ ì‹œìŠ¤í…œ
        // ========================================

        // ì „ì—­ ì¡°ëª… ë©”íƒ€ë°ì´í„° ì €ì¥
        window.lastLightingMeta = null;

        // ========== 1ë‹¨ê³„: í”¼ë¶€Â·ì¡°ëª… ë¶„ì„ ==========
        function analyzeSkinAndLighting(rgb, imageData = null) {
            console.log('ğŸ“Š 1ë‹¨ê³„: í”¼ë¶€Â·ì¡°ëª… ë¶„ì„ ì‹œì‘...');

            let lightingMeta = {
                avgY: 0,           // ì „ì²´ ë°ê¸°
                channelStd: 0,     // R,G,B ì±„ë„ ê°„ í¸ì°¨
                highlightRatio: 0, // í•˜ì´ë¼ì´íŠ¸ ë¹„ìœ¨
                shadowRatio: 0,    // ê·¸ë¦¼ì ë¹„ìœ¨
                colorTemp: 'neutral', // ìƒ‰ì˜¨ë„ (warm/neutral/cool)
                lightingQuality: 0.5  // ì¡°ëª… í’ˆì§ˆ ì ìˆ˜ (0-1)
            };

            if (imageData && imageData.data) {
                const data = imageData.data;
                let rSum = 0, gSum = 0, bSum = 0;
                let highlightCount = 0, shadowCount = 0;
                let pixelCount = 0;

                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i], g = data[i+1], b = data[i+2];
                    const y = (r + g + b) / 3;

                    rSum += r; gSum += g; bSum += b;
                    pixelCount++;

                    if (y > 220) highlightCount++;
                    if (y < 35) shadowCount++;
                }

                if (pixelCount > 0) {
                    const avgR = rSum / pixelCount;
                    const avgG = gSum / pixelCount;
                    const avgB = bSum / pixelCount;
                    lightingMeta.avgY = (avgR + avgG + avgB) / 3;

                    // ì±„ë„ ê°„ í‘œì¤€í¸ì°¨
                    const channelAvg = (avgR + avgG + avgB) / 3;
                    lightingMeta.channelStd = Math.sqrt(
                        (Math.pow(avgR - channelAvg, 2) +
                         Math.pow(avgG - channelAvg, 2) +
                         Math.pow(avgB - channelAvg, 2)) / 3
                    );

                    lightingMeta.highlightRatio = highlightCount / pixelCount;
                    lightingMeta.shadowRatio = shadowCount / pixelCount;

                    // ìƒ‰ì˜¨ë„ íŒë‹¨
                    const rgRatio = avgR / Math.max(1, avgG);
                    if (rgRatio > 1.1) lightingMeta.colorTemp = 'warm';
                    else if (rgRatio < 0.95) lightingMeta.colorTemp = 'cool';
                    else lightingMeta.colorTemp = 'neutral';

                    // ì¡°ëª… í’ˆì§ˆ ê³„ì‚° (0-1)
                    // ì¢‹ì€ ì¡°ëª…: ë°ê¸° ì ë‹¹(80-180), ì±„ë„í¸ì°¨ ë‚®ìŒ(<20), í•˜ì´ë¼ì´íŠ¸/ì„€ë„ìš° ì ìŒ
                    let qualityScore = 1.0;

                    // ë°ê¸° í˜ë„í‹°
                    if (lightingMeta.avgY < 60 || lightingMeta.avgY > 200) qualityScore -= 0.3;
                    else if (lightingMeta.avgY < 80 || lightingMeta.avgY > 180) qualityScore -= 0.15;

                    // ì±„ë„ í¸ì°¨ í˜ë„í‹° (ìƒ‰í¸í–¥)
                    if (lightingMeta.channelStd > 30) qualityScore -= 0.25;
                    else if (lightingMeta.channelStd > 20) qualityScore -= 0.1;

                    // í•˜ì´ë¼ì´íŠ¸/ì„€ë„ìš° í˜ë„í‹°
                    if (lightingMeta.highlightRatio > 0.15) qualityScore -= 0.15;
                    if (lightingMeta.shadowRatio > 0.2) qualityScore -= 0.15;

                    lightingMeta.lightingQuality = Math.max(0.2, Math.min(1.0, qualityScore));
                }
            } else {
                // imageData ì—†ìœ¼ë©´ í”¼ë¶€í†¤ìœ¼ë¡œ ê°„ì ‘ ì¶”ì •
                const avgBrightness = (rgb.r + rgb.g + rgb.b) / 3;
                lightingMeta.avgY = avgBrightness;
                lightingMeta.lightingQuality = 0.5; // ê¸°ë³¸ê°’

                const rgRatio = rgb.r / Math.max(1, rgb.g);
                if (rgRatio > 1.15) lightingMeta.colorTemp = 'warm';
                else if (rgRatio < 0.95) lightingMeta.colorTemp = 'cool';
            }

            // Gray World í™”ì´íŠ¸ë°¸ëŸ°ìŠ¤ ë³´ì •
            let correctedRgb = { ...rgb };
            if (imageData && imageData.data) {
                const data = imageData.data;
                let rSum = 0, gSum = 0, bSum = 0, count = 0;
                for (let i = 0; i < data.length; i += 4) {
                    rSum += data[i]; gSum += data[i+1]; bSum += data[i+2]; count++;
                }
                if (count > 0) {
                    const avgR = rSum/count, avgG = gSum/count, avgB = bSum/count;
                    const grayTarget = 128;
                    const strength = 0.4 * lightingMeta.lightingQuality; // ì¡°ëª… ì¢‹ì„ìˆ˜ë¡ ì ê²Œ ë³´ì •

                    correctedRgb = {
                        r: Math.min(255, Math.max(0, Math.round(rgb.r * (1 + (grayTarget/avgR - 1) * strength)))),
                        g: Math.min(255, Math.max(0, Math.round(rgb.g * (1 + (grayTarget/avgG - 1) * strength)))),
                        b: Math.min(255, Math.max(0, Math.round(rgb.b * (1 + (grayTarget/avgB - 1) * strength))))
                    };
                }
            }

            window.lastLightingMeta = lightingMeta;

            console.log('ğŸ“Š ì¡°ëª… ë©”íƒ€:', lightingMeta);
            console.log(`ğŸ“Š ë³´ì •: (${rgb.r},${rgb.g},${rgb.b}) â†’ (${correctedRgb.r},${correctedRgb.g},${correctedRgb.b})`);

            return {
                originalRgb: rgb,
                correctedRgb: correctedRgb,
                lightingMeta: lightingMeta
            };
        }

        // ========== 2ë‹¨ê³„: í¼ìŠ¤ë„ì»¬ëŸ¬ ì‹œì¦Œ/ì„œë¸Œíƒ€ì… ê²°ì • ==========
        function classifyPersonalColor(correctedRgb, lightingMeta) {
            console.log('ğŸ¨ 2ë‹¨ê³„: í¼ìŠ¤ë„ì»¬ëŸ¬ ë¶„ë¥˜ ì‹œì‘...');

            const lab = rgbToLab(correctedRgb.r, correctedRgb.g, correctedRgb.b);
            const lq = lightingMeta?.lightingQuality || 0.5;

            // ì¡°ëª…ì— ë”°ë¥¸ bê°’ ë³´ì • (ì¡°ëª… ë‚˜ì˜ë©´ ë…¸ë€ê¸° ê³¼ëŒ€í‰ê°€ ë°©ì§€)
            const effectiveB = lab.b * (0.6 + 0.4 * lq);
            // aê°’ë„ ì¡°ëª… ë³´ì • (ì¼ê´€ì„± ìœ ì§€)
            const effectiveA = lab.a * (0.8 + 0.2 * lq);

            // âœ… ê°œì„ : LAB ê¸°ë°˜ ì ìˆ˜ì— ë” ë†’ì€ ê°€ì¤‘ì¹˜ (ë¯¸ìš©ì‹¤ ì¡°ëª…ì€ ì£¼ë¡œ ë…¸ë€ìƒ‰ì´ë¯€ë¡œ LABì´ ë” ì‹ ë¢°ì„± ë†’ìŒ)
            let labScore = 0;  // LAB ê¸°ë°˜ ì ìˆ˜ (ê°€ì¤‘ì¹˜ ë†’ìŒ)
            let rgbScore = 0;  // RGB ê¸°ë°˜ ì ìˆ˜ (ë³´ì¡°)

            // LAB ê¸°ë°˜ ì ìˆ˜ (effectiveB, effectiveA ì‚¬ìš©)
            const labWarmScore = effectiveB - (effectiveA * 0.5);
            if (labWarmScore > 12) labScore = 4;
            else if (labWarmScore > 8) labScore = 3;
            else if (labWarmScore > 4) labScore = 2;
            else if (labWarmScore > 0) labScore = 1;
            else if (labWarmScore < -8) labScore = -3;
            else if (labWarmScore < -4) labScore = -2;
            else if (labWarmScore < 0) labScore = -1;

            // RGB ë¹„ìœ¨ ê¸°ë°˜ (ë³´ì¡° ì ìˆ˜, ê°€ì¤‘ì¹˜ ë‚®ì¶¤)
            const yellowIndex = (correctedRgb.r * 0.5 + correctedRgb.g) - correctedRgb.b * 1.2;
            const pinkIndex = (correctedRgb.r + correctedRgb.b * 0.8) - correctedRgb.g * 1.1;

            if (yellowIndex > pinkIndex + 35) rgbScore = 2;
            else if (yellowIndex > pinkIndex + 20) rgbScore = 1;
            else if (pinkIndex > yellowIndex + 35) rgbScore = -2;
            else if (pinkIndex > yellowIndex + 20) rgbScore = -1;

            // âœ… ìµœì¢… warmScore: LAB 70% + RGB 30% ê°€ì¤‘ í•©ì‚°
            const warmScore = Math.round(labScore * 0.7 + rgbScore * 0.3);

            // ì±„ë„ ê³„ì‚°
            const max = Math.max(correctedRgb.r, correctedRgb.g, correctedRgb.b);
            const min = Math.min(correctedRgb.r, correctedRgb.g, correctedRgb.b);
            const chroma = max - min;

            // ì‹œì¦Œ ë° ì„œë¸Œíƒ€ì… ê²°ì •
            const L = lab.L;
            const C = chroma;
            let season, subtype, seasonKr, emoji, color, undertone;

            // âœ… ìµœì¢… ê°œì„ : ì–¸ë”í†¤ ê²°ì • + ë‰´íŠ¸ëŸ´ ì •ë°€í™”
            // í™•ì‹¤í•œ ì›œ/ì¿¨ (warmScore Â±2 ì´ìƒ)
            if (warmScore >= 2) {
                undertone = 'Warm';
            } else if (warmScore <= -2) {
                undertone = 'Cool';
            } else {
                // âœ… ë‰´íŠ¸ëŸ´ ì˜ì—­ (-1 ~ 1): effectiveBì™€ Lë¡œ ë¯¸ì„¸ êµ¬ë¶„
                undertone = 'Neutral';
            }

            // ì‹œì¦Œ ê²°ì •
            if (undertone === 'Warm') {
                if (L >= 70) {
                    season = 'spring'; seasonKr = 'ë´„ ì›œ';
                    if (C > 45) { subtype = 'bright'; emoji = 'ğŸŒ¸'; color = '#FF6B6B'; }
                    else { subtype = 'light'; emoji = 'ğŸŒ·'; color = '#FFB7C5'; }
                } else if (L >= 60) {
                    season = 'autumn'; seasonKr = 'ê°€ì„ ì›œ';
                    if (C > 45) { subtype = 'soft'; emoji = 'ğŸ‚'; color = '#CD853F'; }
                    else { subtype = 'muted'; emoji = 'ğŸ'; color = '#D2691E'; }
                } else {
                    season = 'autumn'; seasonKr = 'ê°€ì„ ì›œ';
                    if (C > 45) { subtype = 'deep'; emoji = 'ğŸ‚'; color = '#8B4513'; }
                    else { subtype = 'muted'; emoji = 'ğŸ'; color = '#A0522D'; }
                }
            } else if (undertone === 'Cool') {
                if (L >= 65) {
                    season = 'summer'; seasonKr = 'ì—¬ë¦„ ì¿¨';
                    if (C > 40) { subtype = 'bright'; emoji = 'ğŸŒŠ'; color = '#4169E1'; }
                    else { subtype = 'light'; emoji = 'ğŸ’œ'; color = '#87CEEB'; }
                } else if (L >= 50) {
                    season = 'summer'; seasonKr = 'ì—¬ë¦„ ì¿¨';
                    subtype = 'muted'; emoji = 'ğŸŒ™'; color = '#9370DB';
                } else {
                    season = 'winter'; seasonKr = 'ê²¨ìš¸ ì¿¨';
                    if (C > 40) { subtype = 'deep'; emoji = 'â„ï¸'; color = '#191970'; }
                    else { subtype = 'muted'; emoji = 'ğŸŒ™'; color = '#4169E1'; }
                }
            } else {
                // âœ… ë‰´íŠ¸ëŸ´: effectiveBì™€ Lë¡œ ì •ë°€ ë¶„ë¥˜
                // effectiveB > 0: ë¯¸ì„¸ ì›œ ì„±í–¥, effectiveB <= 0: ë¯¸ì„¸ ì¿¨ ì„±í–¥
                if (L >= 65) {
                    // ë°ì€ ë‰´íŠ¸ëŸ´
                    if (effectiveB > 0) {
                        // ë¯¸ì„¸ ì›œ -> ê°€ì„ ì†Œí”„íŠ¸ (ë”°ëœ»í•˜ë©´ì„œ ë°ì€ ëŠë‚Œ)
                        season = 'autumn'; seasonKr = 'ë‰´íŠ¸ëŸ´ ì›œ';
                        subtype = 'soft'; emoji = 'ğŸ‚'; color = '#C4A484';
                    } else {
                        // ë¯¸ì„¸ ì¿¨ -> ì—¬ë¦„ ë¼ì´íŠ¸ (ì‹œì›í•˜ë©´ì„œ ë°ì€ ëŠë‚Œ)
                        season = 'summer'; seasonKr = 'ë‰´íŠ¸ëŸ´ ì¿¨';
                        subtype = 'light'; emoji = 'ğŸ’œ'; color = '#B0C4DE';
                    }
                } else if (L >= 50) {
                    // ì¤‘ê°„ ë°ê¸° ë‰´íŠ¸ëŸ´
                    if (effectiveB > 0) {
                        season = 'autumn'; seasonKr = 'ë‰´íŠ¸ëŸ´ ì›œ';
                        subtype = 'muted'; emoji = 'ğŸ'; color = '#BC8F8F';
                    } else {
                        season = 'summer'; seasonKr = 'ë‰´íŠ¸ëŸ´ ì¿¨';
                        subtype = 'muted'; emoji = 'ğŸŒ™'; color = '#9370DB';
                    }
                } else {
                    // ì–´ë‘ìš´ ë‰´íŠ¸ëŸ´ (L < 50)
                    if (effectiveB > 0) {
                        season = 'autumn'; seasonKr = 'ë‰´íŠ¸ëŸ´ ì›œ';
                        subtype = 'deep'; emoji = 'ğŸ‚'; color = '#8B4513';
                    } else {
                        // ì–´ë‘ìš´ ì¿¨ ë‰´íŠ¸ëŸ´ -> ê²¨ìš¸ ì„±í–¥
                        season = L < 45 ? 'winter' : 'summer';
                        seasonKr = L < 45 ? 'ë‰´íŠ¸ëŸ´ ì¿¨' : 'ë‰´íŠ¸ëŸ´ ì¿¨';
                        subtype = L < 45 ? 'deep' : 'muted';
                        emoji = L < 45 ? 'â„ï¸' : 'ğŸŒ™';
                        color = L < 45 ? '#4169E1' : '#9370DB';
                    }
                }
            }

            // confidence ê³„ì‚° (ì¡°ëª… í’ˆì§ˆ ë°˜ì˜)
            let baseConfidence = 65;
            baseConfidence += Math.abs(labScore) * 4; // LAB í™•ì‹ ë„ì— ë”°ë¼ ì¦ê°€
            baseConfidence = baseConfidence * (0.6 + 0.4 * lq); // ì¡°ëª… í’ˆì§ˆ ë°˜ì˜

            // ì¡°ëª… ë‚˜ì˜ë©´ ì°¸ê³ ìš© í”Œë˜ê·¸
            const isReference = lq < 0.4;
            if (isReference) baseConfidence = Math.min(baseConfidence, 65);

            const confidence = Math.min(98, Math.max(55, Math.round(baseConfidence)));

            const fullSeason = `${seasonKr} ${subtype === 'bright' ? 'ë¸Œë¼ì´íŠ¸' : subtype === 'light' ? 'ë¼ì´íŠ¸' : subtype === 'soft' ? 'ì†Œí”„íŠ¸' : subtype === 'muted' ? 'ë®¤íŠ¸' : 'ë”¥'}`;

            console.log('ğŸ¨ ë¶„ë¥˜ ê²°ê³¼:', {
                undertone, labScore, rgbScore, warmScore, L: L.toFixed(1), C,
                season, subtype, confidence, isReference
            });

            return {
                undertone,
                warmScore,
                labScore,
                season,
                seasonKr,
                subtype,
                fullSeason,
                emoji,
                color,
                lab,
                effectiveB,
                chroma: C,
                confidence,
                isReference,
                toneMeta: { undertone, L, C }
            };
        }

        // ========== 3ë‹¨ê³„: í—¤ì–´ì»¬ëŸ¬ ë§¤í•‘ ê·œì¹™ ==========
        // âœ… chromaMin ì™„í™”: í•„í„°ë§ ì¡°ê±´ì´ ì•„ë‹Œ ë³´ë„ˆìŠ¤ ì ìˆ˜ë¡œë§Œ ì‚¬ìš©
        const HAIR_COLOR_MAPPING_RULES = {
            'spring-bright': { levelRange: [7, 10], tones: ['warm', 'gold', 'orange', 'copper'], chromaBonus: 30 },
            'spring-light': { levelRange: [8, 10], tones: ['warm', 'gold', 'beige', 'honey'], chromaBonus: 20 },
            'autumn-soft': { levelRange: [5, 8], tones: ['warm', 'beige', 'caramel', 'brown'], chromaBonus: 15 },
            'autumn-muted': { levelRange: [4, 7], tones: ['warm', 'olive', 'khaki', 'brown', 'neutral'], chromaBonus: 10 },
            'autumn-deep': { levelRange: [3, 6], tones: ['warm', 'red', 'copper', 'chocolate'], chromaBonus: 25 },
            'summer-bright': { levelRange: [6, 9], tones: ['cool', 'ash', 'pink', 'lavender'], chromaBonus: 25 },
            'summer-light': { levelRange: [7, 10], tones: ['cool', 'ash', 'beige', 'pink'], chromaBonus: 15 },
            'summer-muted': { levelRange: [5, 8], tones: ['cool', 'ash', 'gray', 'lavender', 'neutral'], chromaBonus: 10 },
            'winter-deep': { levelRange: [1, 4], tones: ['cool', 'ash', 'blue', 'violet'], chromaBonus: 30 },
            'winter-muted': { levelRange: [2, 5], tones: ['cool', 'ash', 'gray', 'charcoal'], chromaBonus: 15 }
        };

        // ì¸ì ‘ ì‹œì¦Œ ì •ì˜
        const ADJACENT_SEASONS = {
            'spring': ['autumn'],
            'autumn': ['spring'],
            'summer': ['winter'],
            'winter': ['summer']
        };

        function filterHairColorCandidates(personalColorResult, hairColors) {
            console.log('ğŸ’‡ 3ë‹¨ê³„: í—¤ì–´ì»¬ëŸ¬ í›„ë³´ í•„í„°ë§...');

            const { season, subtype } = personalColorResult;
            const ruleKey = `${season}-${subtype}`;
            const rule = HAIR_COLOR_MAPPING_RULES[ruleKey] || HAIR_COLOR_MAPPING_RULES[`${season}-muted`];

            if (!rule) {
                console.warn('ë§¤í•‘ ê·œì¹™ ì—†ìŒ:', ruleKey);
                return { primary: hairColors.slice(0, 10), secondary: [] };
            }

            const primary = [];   // ê°™ì€ ì‹œì¦Œ
            const secondary = []; // ì¸ì ‘ ì‹œì¦Œ
            const adjacentSeasons = ADJACENT_SEASONS[season] || [];

            hairColors.forEach(color => {
                const level = color.level || estimateLevelFromHex(color.hex);
                const toneTag = color.toneTag || guessToneFromName(color.name);
                const colorSeason = color.season || guessSeasonFromHex(color.hex);

                // ë ˆë²¨ ë§¤ì¹­ ì²´í¬
                const levelMatch = level >= rule.levelRange[0] && level <= rule.levelRange[1];
                const levelNear = level >= rule.levelRange[0] - 1 && level <= rule.levelRange[1] + 1; // Â±1 í—ˆìš©
                // í†¤ ë§¤ì¹­ ì²´í¬
                const toneMatch = rule.tones.some(t => toneTag.includes(t));

                // âœ… ê°œì„ ëœ ìš°ì„ ìˆœìœ„ ì²´ê³„
                // 1ìˆœìœ„: Level O + Tone O (Best)
                // 2ìˆœìœ„: Level O + Tone X (ëª…ë„ëŠ” ë§ìœ¼ë‹ˆ ì–¼êµ´ ë°ê¸°ëŠ” ì‚´ë ¤ì¤Œ)
                // 3ìˆœìœ„: Level â–³(Â±1) + Tone O (í†¤ì€ ë§ìœ¼ë‹ˆ ë¶„ìœ„ê¸°ëŠ” ì‚´ë ¤ì¤Œ)
                // 4ìˆœìœ„: ì¸ì ‘ ì‹œì¦Œ
                // 5ìˆœìœ„: ê·¸ ì™¸

                if (colorSeason === season) {
                    if (levelMatch && toneMatch) {
                        // 1ìˆœìœ„: ë ˆë²¨ O + í†¤ O
                        primary.push({ ...color, level, toneTag, toneMatch: true, levelMatch: true, priority: 1 });
                    } else if (levelMatch && !toneMatch) {
                        // 2ìˆœìœ„: ë ˆë²¨ O + í†¤ X
                        primary.push({ ...color, level, toneTag, toneMatch: false, levelMatch: true, priority: 2 });
                    } else if (levelNear && toneMatch) {
                        // 3ìˆœìœ„: ë ˆë²¨ â–³ + í†¤ O
                        primary.push({ ...color, level, toneTag, toneMatch: true, levelMatch: false, priority: 3 });
                    } else if (levelNear) {
                        // ë ˆë²¨ ê·¼ì ‘ì€ í¬í•¨
                        primary.push({ ...color, level, toneTag, toneMatch: false, levelMatch: false, priority: 4 });
                    }
                } else if (adjacentSeasons.includes(colorSeason)) {
                    // 4ìˆœìœ„: ì¸ì ‘ ì‹œì¦Œ
                    secondary.push({ ...color, level, toneTag, toneMatch, levelMatch: levelNear, priority: 5 });
                }
            });

            // ìš°ì„ ìˆœìœ„ë³„ ì •ë ¬
            primary.sort((a, b) => a.priority - b.priority);
            secondary.sort((a, b) => a.priority - b.priority);

            console.log(`ğŸ’‡ ê°™ì€ ì‹œì¦Œ: ${primary.length}ê°œ, ì¸ì ‘ ì‹œì¦Œ: ${secondary.length}ê°œ`);
            console.log(`ğŸ’‡ ìš°ì„ ìˆœìœ„ ë¶„í¬: P1=${primary.filter(c=>c.priority===1).length}, P2=${primary.filter(c=>c.priority===2).length}, P3=${primary.filter(c=>c.priority===3).length}`);

            return { primary, secondary };
        }

        // í—¬í¼ í•¨ìˆ˜ë“¤
        function estimateLevelFromHex(hex) {
            const rgb = hexToRgb(hex);
            if (!rgb) return 5;
            const brightness = (rgb.r + rgb.g + rgb.b) / 3;
            return Math.round(brightness / 25.5); // 0-10 ë ˆë²¨
        }

        function guessToneFromName(name) {
            if (!name) return 'neutral';
            const n = name.toLowerCase();
            if (n.includes('ì• ì‰¬') || n.includes('ash') || n.includes('ê·¸ë ˆì´') || n.includes('gray')) return 'cool,ash';
            if (n.includes('ê³¨ë“œ') || n.includes('gold') || n.includes('honey')) return 'warm,gold';
            if (n.includes('ë ˆë“œ') || n.includes('red') || n.includes('copper')) return 'warm,red';
            if (n.includes('ë² ì´ì§€') || n.includes('beige')) return 'warm,beige';
            if (n.includes('ë¸Œë¼ìš´') || n.includes('brown')) return 'neutral,brown';
            if (n.includes('ë¸”ë£¨') || n.includes('blue') || n.includes('ë°”ì´ì˜¬ë ›')) return 'cool,blue';
            return 'neutral';
        }

        function guessSeasonFromHex(hex) {
            const rgb = hexToRgb(hex);
            if (!rgb) return 'autumn';

            const warmth = rgb.r - rgb.b;
            const brightness = (rgb.r + rgb.g + rgb.b) / 3;

            if (warmth > 30 && brightness > 150) return 'spring';
            if (warmth > 30 && brightness <= 150) return 'autumn';
            if (warmth <= 30 && brightness > 120) return 'summer';
            return 'winter';
        }

        function hexToRgb(hex) {
            if (!hex) return null;
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        // ========== 4ë‹¨ê³„: Delta E + ì‹¤ë¬´ ê°€ì¤‘ì¹˜ ìµœì¢… ì¶”ì²œ ==========
        function calculateFinalRecommendations(skinLab, candidates, personalColorResult, lightingMeta) {
            console.log('ğŸ† 4ë‹¨ê³„: ìµœì¢… ì¶”ì²œ ê³„ì‚°...');

            const lq = lightingMeta?.lightingQuality || 0.5;
            const results = [];

            const allCandidates = [...(candidates.primary || []), ...(candidates.secondary || [])];

            allCandidates.forEach(color => {
                const colorRgb = hexToRgb(color.hex);
                if (!colorRgb) return;

                const colorLab = rgbToLab(colorRgb.r, colorRgb.g, colorRgb.b);

                // Delta E 2000 ê³„ì‚° (ê°„ëµ ë²„ì „)
                const deltaE = Math.sqrt(
                    Math.pow(skinLab.L - colorLab.L, 2) +
                    Math.pow(skinLab.a - colorLab.a, 2) +
                    Math.pow(skinLab.b - colorLab.b, 2)
                );

                // Harmony Score ê³„ì‚°
                let harmonyScore = 100;

                // 1. í†¤ ì¡°í™” (ì–¸ë”í†¤ ë§¤ì¹­)
                const toneBonus = color.toneMatch ? 15 : 0;
                harmonyScore += toneBonus;

                // 2. ëª…ë„ ëŒ€ë¹„ ì¡°í™” (ì ë‹¹í•œ ëŒ€ë¹„ê°€ ì¢‹ìŒ)
                const contrastL = Math.abs(skinLab.L - colorLab.L);
                if (contrastL >= 20 && contrastL <= 40) harmonyScore += 10;
                else if (contrastL > 50) harmonyScore -= 10;

                // 3. ì±„ë„ ì¡°í™”
                const skinC = personalColorResult.chroma || 50;
                const colorC = Math.sqrt(colorLab.a*colorLab.a + colorLab.b*colorLab.b);
                if (Math.abs(skinC - colorC) < 30) harmonyScore += 5;

                // 4. ìš°ì„ ìˆœìœ„ ë³´ë„ˆìŠ¤
                if (color.priority === 1) harmonyScore += 20;
                else if (color.priority === 2) harmonyScore += 10;

                // 5. ë¸Œëœë“œ ì‹ ë¢°ë„ (ìˆìœ¼ë©´)
                if (color.brand && ['ë¡œë ˆì•Œ', 'ì›°ë¼', 'Shiseido', 'ë°€ë³¸'].includes(color.brand)) {
                    harmonyScore += 5;
                }

                // ì¡°ëª… í’ˆì§ˆì— ë”°ë¥¸ ìƒí•œ ì¡°ì •
                const maxScore = 100 + (lq * 50);
                harmonyScore = Math.min(harmonyScore, maxScore);

                // Delta Eê°€ ë„ˆë¬´ í¬ë©´ ê°ì 
                if (deltaE > 80) harmonyScore -= 20;
                else if (deltaE > 60) harmonyScore -= 10;

                results.push({
                    ...color,
                    deltaE: deltaE.toFixed(1),
                    harmonyScore: Math.round(harmonyScore),
                    colorLab
                });
            });

            // ì •ë ¬
            results.sort((a, b) => b.harmonyScore - a.harmonyScore);

            // ë¶„ë¥˜
            const recommended1st = results.slice(0, 3);  // ê°•ì¶”ì²œ
            const recommended2nd = results.slice(3, 6);  // ë¬´ë‚œ

            // í”¼í•´ì•¼ í•  ì»¬ëŸ¬ ê·œì¹™
            const avoidRules = getAvoidColorRules(personalColorResult);

            console.log('ğŸ† ì¶”ì²œ ì™„ë£Œ:', {
                '1ìˆœìœ„': recommended1st.length,
                '2ìˆœìœ„': recommended2nd.length,
                'í”¼í•´ì•¼í• ': avoidRules
            });

            return {
                recommended1st,
                recommended2nd,
                avoidRules,
                allScored: results
            };
        }

        function getAvoidColorRules(personalColorResult) {
            const { season, subtype, undertone } = personalColorResult;
            const rules = [];

            if (undertone === 'Warm') {
                rules.push('ë¸”ë£¨ë¸”ë™, ì• ì‰¬ë¸”ë£¨ ë“± ì°¨ê°€ìš´ í†¤ì€ ì–¼êµ´ì´ ì¹™ì¹™í•´ ë³´ì¼ ìˆ˜ ìˆìŒ');
                if (subtype === 'light' || subtype === 'bright') {
                    rules.push('3ë ˆë²¨ ì´í•˜ ì–´ë‘ìš´ ìƒ‰ìƒì€ í”¼ë¶€ê°€ ì–´ë‘ì›Œ ë³´ì¼ ìˆ˜ ìˆìŒ');
                }
            } else if (undertone === 'Cool') {
                rules.push('ê³¨ë“œ, ì˜¤ë Œì§€, êµ¬ë¦¬ìƒ‰ ë“± ë”°ëœ»í•œ í†¤ì€ í”¼ë¶€ê°€ ë…¸ë—ê²Œ ë³´ì¼ ìˆ˜ ìˆìŒ');
                if (subtype === 'light') {
                    rules.push('ì„ ëª…í•œ ë ˆë“œ, ì˜¤ë Œì§€ ê³„ì—´ì€ í”¼í•  ê²ƒ');
                }
            } else {
                rules.push('ë„ˆë¬´ ê·¹ë‹¨ì ì¸ ì›œ/ì¿¨ í†¤ë³´ë‹¤ëŠ” ë‰´íŠ¸ëŸ´ ê³„ì—´ ì¶”ì²œ');
            }

            if (subtype === 'muted' || subtype === 'soft') {
                rules.push('ì±„ë„ê°€ ë„ˆë¬´ ë†’ì€ ë¹„ë¹„ë“œ ì»¬ëŸ¬ëŠ” í”¼ë¶€í†¤ê³¼ ì¶©ëŒí•  ìˆ˜ ìˆìŒ');
            }

            return rules;
        }

        // ========== ì „ë¬¸ê°€ í”¼ë“œë°± í•¨ìˆ˜ (PDF ì´ë¡  ê¸°ë°˜) ==========
        const EXPERT_GUIDE_DB = {
            'spring-bright': {
                toneKeyword: ['ì½”ë„', 'í”¼ì¹˜', 'ì˜¤ë Œì§€ê³¨ë“œ', 'ì›œë¸Œë¼ìš´'],
                recommendLevel: '7~10ë ˆë²¨',
                undercoatTip: 'ê³¨ë“œ ê³„ì—´ ì–¸ë”í†¤ ìœ ì§€, ì˜¤ë Œì§€ ë² ì´ìŠ¤ íƒˆìƒ‰ ê¶Œì¥',
                textureTip: 'ê´‘íƒê° ìˆëŠ” ë§ˆë¬´ë¦¬ë¡œ ìƒê¸° ìˆëŠ” ëŠë‚Œ ì—°ì¶œ',
                avoidColors: ['ì• ì‰¬', 'ë¸”ë£¨ë¸”ë™', 'ê·¸ë ˆì´'],
                seasonalAdvice: 'ë´„ ì›œ ë¸Œë¼ì´íŠ¸ëŠ” ì„ ëª…í•˜ê³  ë°ì€ ì»¬ëŸ¬ê°€ í¬ì¸íŠ¸ì…ë‹ˆë‹¤. ë„ˆë¬´ íƒí•˜ê±°ë‚˜ ì–´ë‘ìš´ ìƒ‰ì€ í”¼í•˜ì„¸ìš”.',
                consultingTip: 'ì²«ì¸ìƒì´ ë°ê³  í™”ì‚¬í•˜ë¯€ë¡œ, í™œê¸°ì°¬ ì»¬ëŸ¬ë¡œ ê°•ì ì„ ì‚´ë ¤ì£¼ì„¸ìš”.'
            },
            'spring-light': {
                toneKeyword: ['ë² ì´ì§€', 'ë°€í¬í‹°', 'ì‚´êµ¬', 'ë¼ì´íŠ¸ë¸Œë¼ìš´'],
                recommendLevel: '8~10ë ˆë²¨',
                undercoatTip: 'ì˜ë¡œìš°~ì˜¤ë Œì§€ ê³„ì—´ ì–¸ë”í†¤, ê³¼íƒˆìƒ‰ ì£¼ì˜',
                textureTip: 'ìì—°ìŠ¤ëŸ½ê³  ë¶€ë“œëŸ¬ìš´ ì§ˆê°ì´ ì˜ ì–´ìš¸ë¦¼',
                avoidColors: ['ë‹¤í¬ë¸Œë¼ìš´', 'ë¸”ë™', 'ì• ì‰¬ê·¸ë ˆì´'],
                seasonalAdvice: 'ë´„ ì›œ ë¼ì´íŠ¸ëŠ” ë§‘ê³  ì—°í•œ í†¤ì´ í•µì‹¬ì…ë‹ˆë‹¤. ë„ˆë¬´ ì§„í•œ ìƒ‰ì€ ì–¼êµ´ì„ ë‹µë‹µí•˜ê²Œ ë§Œë“¤ì–´ìš”.',
                consultingTip: 'ì²­ìˆœí•˜ê³  ë‚´ì¶”ëŸ´í•œ ì´ë¯¸ì§€ë¥¼ ê°•ì¡°í•˜ëŠ” ì»¬ëŸ¬ ì¶”ì²œë“œë¦½ë‹ˆë‹¤.'
            },
            'autumn-deep': {
                toneKeyword: ['ë‹¤í¬ë¸Œë¼ìš´', 'ë²„ê±´ë””', 'ì´ˆì½œë¦¿', 'ì¹´í‚¤'],
                recommendLevel: '4~6ë ˆë²¨',
                undercoatTip: 'ë ˆë“œ~ì˜¤ë Œì§€ ì–¸ë”í†¤, íƒˆìƒ‰ ì—†ì´ ë°”ë¡œ ì ìš© ê°€ëŠ¥',
                textureTip: 'ë§¤íŠ¸í•˜ê±°ë‚˜ ì„¸ë¯¸ë§¤íŠ¸ ë§ˆë¬´ë¦¬ë¡œ ê¹Šì´ê° ì—°ì¶œ',
                avoidColors: ['í”Œë˜í‹°ë„˜', 'ì• ì‰¬', 'íŒŒìŠ¤í…”'],
                seasonalAdvice: 'ê°€ì„ ì›œ ë”¥ì€ ê¹Šê³  í’ë¶€í•œ ìƒ‰ê°ì´ ì–´ìš¸ë¦½ë‹ˆë‹¤. ë„ˆë¬´ ë°ê±°ë‚˜ íƒí•œ ìƒ‰ì€ í”¼í•˜ì„¸ìš”.',
                consultingTip: 'ê³ ê¸‰ìŠ¤ëŸ½ê³  ì„±ìˆ™í•œ ì´ë¯¸ì§€ë¥¼ ê°•ì¡°í•´ì£¼ì„¸ìš”.'
            },
            'autumn-muted': {
                toneKeyword: ['ì¹´ë©œ', 'í…Œë¼ì½”íƒ€', 'ë¨¸ìŠ¤íƒ€ë“œ', 'ì˜¬ë¦¬ë¸Œ'],
                recommendLevel: '5~7ë ˆë²¨',
                undercoatTip: 'ì˜ë¡œìš°~ì˜¤ë Œì§€ ë² ì´ìŠ¤, ì±„ë„ ë‚®ê²Œ ìœ ì§€',
                textureTip: 'ìì—°ìŠ¤ëŸ½ê³  ì°¨ë¶„í•œ ì§ˆê°, ê´‘íƒ ìµœì†Œí™”',
                avoidColors: ['ë¹„ë¹„ë“œ ë ˆë“œ', 'ë„¤ì˜¨', 'ë¸”ë£¨ë¸”ë™'],
                seasonalAdvice: 'ê°€ì„ ì›œ ë®¤íŠ¸ëŠ” íƒí•˜ê³  ìì—°ìŠ¤ëŸ¬ìš´ ìƒ‰ê°ì´ í¬ì¸íŠ¸ì…ë‹ˆë‹¤. ì„ ëª…í•œ ìƒ‰ì€ í”¼í•˜ì„¸ìš”.',
                consultingTip: 'ë‚´ì¶”ëŸ´í•˜ê³  ì„¸ë ¨ëœ ë¶„ìœ„ê¸°ë¥¼ ì—°ì¶œí•´ì£¼ì„¸ìš”.'
            },
            'autumn-soft': {
                toneKeyword: ['ëª¨ì¹´', 'ë°€í¬ì´ˆì½”', 'ë”ìŠ¤í‹°í•‘í¬', 'ë² ì´ì§€ë¸Œë¼ìš´'],
                recommendLevel: '6~8ë ˆë²¨',
                undercoatTip: 'ì›œ ë² ì´ì§€ ì–¸ë”í†¤, ë¶€ë“œëŸ¬ìš´ ê·¸ë¼ë°ì´ì…˜ ê¶Œì¥',
                textureTip: 'ë¶€ë“œëŸ½ê³  ë”°ëœ»í•œ ì§ˆê°, ìì—°ìŠ¤ëŸ¬ìš´ ê´‘íƒ',
                avoidColors: ['ë¸”ë™', 'ì• ì‰¬ë¸”ë£¨', 'ë¹„ë¹„ë“œ ì˜¤ë Œì§€'],
                seasonalAdvice: 'ê°€ì„ ì›œ ì†Œí”„íŠ¸ëŠ” ë¶€ë“œëŸ½ê³  ì€ì€í•œ ìƒ‰ì´ ì˜ ì–´ìš¸ë ¤ìš”. ê·¹ë‹¨ì ì¸ ìƒ‰ì€ í”¼í•˜ì„¸ìš”.',
                consultingTip: 'ë”°ëœ»í•˜ê³  í¸ì•ˆí•œ ëŠë‚Œì„ ì£¼ëŠ” ì»¬ëŸ¬ë¥¼ ì¶”ì²œí•©ë‹ˆë‹¤.'
            },
            'summer-bright': {
                toneKeyword: ['ë¡œì¦ˆ', 'ë¼ë²¤ë”', 'ì¿¨í•‘í¬', 'ì²­í¬ë„'],
                recommendLevel: '7~9ë ˆë²¨',
                undercoatTip: 'ì• ì‰¬~í•‘í¬ ê³„ì—´ ì–¸ë”í†¤, ë…¸ë€ê¸° ì œê±° í•„ìˆ˜',
                textureTip: 'ì²­ëŸ‰í•˜ê³  ê¹¨ë—í•œ ê´‘íƒê° ì—°ì¶œ',
                avoidColors: ['ê³¨ë“œ', 'ì˜¤ë Œì§€', 'ë¨¸ìŠ¤íƒ€ë“œ'],
                seasonalAdvice: 'ì—¬ë¦„ ì¿¨ ë¸Œë¼ì´íŠ¸ëŠ” ì„ ëª…í•˜ê³  ì‹œì›í•œ ìƒ‰ì´ ì–´ìš¸ë ¤ìš”. ë”°ëœ»í•œ í†¤ì€ í”¼í•˜ì„¸ìš”.',
                consultingTip: 'ì²­ì•„í•˜ê³  ì‹œì›í•œ ì´ë¯¸ì§€ë¥¼ ì‚´ë ¤ì£¼ì„¸ìš”.'
            },
            'summer-light': {
                toneKeyword: ['ë¼ì´íŠ¸ì• ì‰¬', 'ë¡œì¦ˆë² ì´ì§€', 'ë¼ë²¤ë”ê·¸ë ˆì´', 'ë°€í¬í‹°ì• ì‰¬'],
                recommendLevel: '8~10ë ˆë²¨',
                undercoatTip: 'í•‘í¬~ë°”ì´ì˜¬ë › ì–¸ë”í†¤, ë¶€ë“œëŸ¬ìš´ íƒˆìƒ‰',
                textureTip: 'ì†Œí”„íŠ¸í•˜ê³  ìš°ì•„í•œ ì§ˆê°, íŒŒìŠ¤í…” ëŠë‚Œ',
                avoidColors: ['ë‹¤í¬ë¸Œë¼ìš´', 'ê³¨ë“œ', 'ì˜¤ë Œì§€'],
                seasonalAdvice: 'ì—¬ë¦„ ì¿¨ ë¼ì´íŠ¸ëŠ” ì—°í•˜ê³  ë¶€ë“œëŸ¬ìš´ ì¿¨í†¤ì´ í•µì‹¬ì´ì—ìš”. ì§„í•˜ê±°ë‚˜ ë”°ëœ»í•œ ìƒ‰ì€ í”¼í•˜ì„¸ìš”.',
                consultingTip: 'ìš°ì•„í•˜ê³  ì—¬ì„±ìŠ¤ëŸ¬ìš´ ë¶„ìœ„ê¸°ë¥¼ ê°•ì¡°í•´ì£¼ì„¸ìš”.'
            },
            'winter-deep': {
                toneKeyword: ['ë¸”ë£¨ë¸”ë™', 'ë²„ê±´ë””', 'ë‹¤í¬ë„¤ì´ë¹„', 'í”ŒëŸ¼'],
                recommendLevel: '3~5ë ˆë²¨',
                undercoatTip: 'ì¿¨í†¤ ë² ì´ìŠ¤ ìœ ì§€, ë…¸ë€ê¸° ì™„ì „ ì œê±°',
                textureTip: 'ì„ ëª…í•˜ê³  ê°•ë ¬í•œ ê´‘íƒ, ë˜ëŠ” ì™„ì „ ë§¤íŠ¸',
                avoidColors: ['ë² ì´ì§€', 'ê³¨ë“œ', 'ì¹´ë©œ'],
                seasonalAdvice: 'ê²¨ìš¸ ì¿¨ ë”¥ì€ ê°•ë ¬í•˜ê³  ì„ ëª…í•œ ìƒ‰ì´ ì–´ìš¸ë ¤ìš”. ë”°ëœ»í•˜ê±°ë‚˜ íƒí•œ ìƒ‰ì€ í”¼í•˜ì„¸ìš”.',
                consultingTip: 'ë„ì‹œì ì´ê³  ëª¨ë˜í•œ ëŠë‚Œì„ ì‚´ë ¤ì£¼ì„¸ìš”.'
            },
            'winter-muted': {
                toneKeyword: ['ì°¨ì½œ', 'ê·¸ë ˆì´', 'ë‹¤í¬ì• ì‰¬', 'ìŠ¤ëª¨í‚¤'],
                recommendLevel: '4~6ë ˆë²¨',
                undercoatTip: 'ê·¸ë ˆì´~ì• ì‰¬ ë² ì´ìŠ¤, ì±„ë„ ìµœì†Œí™”',
                textureTip: 'ë§¤íŠ¸í•˜ê³  ì°¨ë¶„í•œ ì§ˆê°',
                avoidColors: ['ê³¨ë“œ', 'ì˜¤ë Œì§€', 'ì½”ë„'],
                seasonalAdvice: 'ê²¨ìš¸ ì¿¨ ë®¤íŠ¸ëŠ” ë¬´ì±„ìƒ‰ ê³„ì—´ì´ ì˜ ì–´ìš¸ë ¤ìš”. í™”ë ¤í•œ ìƒ‰ì€ í”¼í•˜ì„¸ìš”.',
                consultingTip: 'ì„¸ë ¨ë˜ê³  ì°¨ë¶„í•œ ë¶„ìœ„ê¸°ë¥¼ ì—°ì¶œí•´ì£¼ì„¸ìš”.'
            },
            'neutral-light': {
                toneKeyword: ['ë°€í¬í‹°', 'ë¡œì¦ˆë² ì´ì§€', 'ë¼ì´íŠ¸ëª¨ì¹´', 'ë”ìŠ¤í‹°í•‘í¬'],
                recommendLevel: '7~9ë ˆë²¨',
                undercoatTip: 'ë‰´íŠ¸ëŸ´ ë² ì´ì§€ ë² ì´ìŠ¤, ê·¹ë‹¨ì ì¸ ì›œ/ì¿¨ í”¼í•˜ê¸°',
                textureTip: 'ìì—°ìŠ¤ëŸ½ê³  ë¶€ë“œëŸ¬ìš´ ì§ˆê°',
                avoidColors: ['ë¹„ë¹„ë“œ ì˜¤ë Œì§€', 'ë¸”ë£¨ë¸”ë™', 'ë„¤ì˜¨'],
                seasonalAdvice: 'ë‰´íŠ¸ëŸ´ ë¼ì´íŠ¸ëŠ” ì¤‘ê°„ í†¤ì˜ ë¶€ë“œëŸ¬ìš´ ìƒ‰ì´ ì˜ ì–´ìš¸ë ¤ìš”.',
                consultingTip: 'ë‹¤ì–‘í•œ ì»¬ëŸ¬ê°€ ì–´ìš¸ë¦¬ë‹ˆ ê³ ê° ì·¨í–¥ì— ë§ê²Œ ì¡°ì ˆí•´ì£¼ì„¸ìš”.'
            },
            'neutral-deep': {
                toneKeyword: ['ì´ˆì½œë¦¿', 'ë²„ê±´ë””', 'ë‹¤í¬ëª¨ì¹´', 'ì—ìŠ¤í”„ë ˆì†Œ'],
                recommendLevel: '4~6ë ˆë²¨',
                undercoatTip: 'ë‰´íŠ¸ëŸ´ ë¸Œë¼ìš´ ë² ì´ìŠ¤',
                textureTip: 'ê¹Šì´ê° ìˆëŠ” ìì—°ìŠ¤ëŸ¬ìš´ ë§ˆë¬´ë¦¬',
                avoidColors: ['í”Œë˜í‹°ë„˜', 'ì• ì‰¬ë¸”ë£¨', 'ë¹„ë¹„ë“œ í•‘í¬'],
                seasonalAdvice: 'ë‰´íŠ¸ëŸ´ ë”¥ì€ ê¹Šê³  ìì—°ìŠ¤ëŸ¬ìš´ ìƒ‰ì´ ì˜ ì–´ìš¸ë ¤ìš”.',
                consultingTip: 'ì„¸ë ¨ë˜ê³  ì„±ìˆ™í•œ ëŠë‚Œì„ ì—°ì¶œí•´ì£¼ì„¸ìš”.'
            }
        };

        function generateAdvancedExpertFeedback(season, subtype, skinData) {
            const key = `${season}-${subtype}`;
            const guide = EXPERT_GUIDE_DB[key];

            if (!guide) {
                return {
                    toneKeywords: [],
                    levelTip: '',
                    undercoatTip: '',
                    textureTip: '',
                    avoidColors: [],
                    seasonalAdvice: '',
                    consultingTip: ''
                };
            }

            // í”¼ë¶€ ëª…ë„ì— ë”°ë¥¸ ì¶”ê°€ ì¡°ì–¸
            let brightnessAdvice = '';
            if (skinData && skinData.L) {
                if (skinData.L >= 70) {
                    brightnessAdvice = 'ë°ì€ í”¼ë¶€í†¤ì´ì‹œë„¤ìš”. ë ˆë²¨ì„ ì¡°ê¸ˆ ë†’ì—¬ë„ ìì—°ìŠ¤ëŸ¬ì›Œìš”.';
                } else if (skinData.L >= 55) {
                    brightnessAdvice = 'ì¤‘ê°„ ë°ê¸° í”¼ë¶€í†¤ì´ì—ìš”. ì¶”ì²œ ë ˆë²¨ ë²”ìœ„ê°€ ê°€ì¥ ì˜ ì–´ìš¸ë ¤ìš”.';
                } else {
                    brightnessAdvice = 'ì–´ë‘ìš´ í”¼ë¶€í†¤ì´ì‹œë„¤ìš”. ë„ˆë¬´ ë°ì€ ë ˆë²¨ì€ ë¶€ìì—°ìŠ¤ëŸ¬ìš¸ ìˆ˜ ìˆì–´ìš”.';
                }
            }

            return {
                toneKeywords: guide.toneKeyword,
                levelTip: guide.recommendLevel,
                undercoatTip: guide.undercoatTip,
                textureTip: guide.textureTip,
                avoidColors: guide.avoidColors,
                seasonalAdvice: guide.seasonalAdvice,
                consultingTip: guide.consultingTip,
                brightnessAdvice
            };
        }

        // í—¤ì–´ì»¬ëŸ¬ ì‹œìˆ  ë‚œì´ë„ íŒì • í•¨ìˆ˜
        function getColorDifficulty(color, personalColorResult) {
            const skinL = personalColorResult.lab?.L || 60;
            const colorLevel = color.level || 6;

            // íƒˆìƒ‰ í•„ìš” ì—¬ë¶€ (ì¼ë°˜ì ìœ¼ë¡œ 7ë ˆë²¨ ì´ìƒì€ íƒˆìƒ‰ í•„ìš”)
            const needsBleaching = colorLevel >= 7;

            // ë‚œì´ë„ ê³„ì‚°
            let difficulty = 'easy';
            let difficultyLabel = 'ì†ì‰¬ì›€';
            let difficultyIcon = 'âœ…';
            let difficultyTip = '';

            if (needsBleaching) {
                if (colorLevel >= 9) {
                    difficulty = 'hard';
                    difficultyLabel = 'ê³ ë‚œë„';
                    difficultyIcon = 'âš ï¸';
                    difficultyTip = '2íšŒ ì´ìƒ íƒˆìƒ‰ í•„ìš”, ëª¨ë°œ ì†ìƒ ì£¼ì˜';
                } else {
                    difficulty = 'medium';
                    difficultyLabel = 'íƒˆìƒ‰ í•„ìš”';
                    difficultyIcon = 'ğŸ”†';
                    difficultyTip = '1íšŒ íƒˆìƒ‰ í›„ ì—¼ìƒ‰';
                }
            } else {
                difficultyTip = 'íƒˆìƒ‰ ì—†ì´ ë°”ë¡œ ì ìš© ê°€ëŠ¥';
            }

            return {
                difficulty,
                label: difficultyLabel,
                icon: difficultyIcon,
                tip: difficultyTip,
                needsBleaching
            };
        }

        // ìš°ì„ ìˆœìœ„ ë±ƒì§€ ìƒì„± í•¨ìˆ˜
        function getPriorityBadge(priority) {
            switch(priority) {
                case 1:
                    return { icon: 'â­', label: 'Best Match', color: '#FFD700' };
                case 2:
                    return { icon: 'â˜€ï¸', label: 'Level OK', color: '#FF9800' };
                case 3:
                    return { icon: 'ğŸ¨', label: 'Tone OK', color: '#4CAF50' };
                case 4:
                    return { icon: 'ğŸ‘', label: 'Good', color: '#2196F3' };
                default:
                    return { icon: 'ğŸ’«', label: 'Option', color: '#9E9E9E' };
            }
        }

        // ========== í†µí•© íŒŒì´í”„ë¼ì¸ ì‹¤í–‰ ==========
        function runPersonalColorPipeline(skinRgb, imageData = null) {
            console.log('ğŸš€ í¼ìŠ¤ë„ì»¬ëŸ¬ ë¶„ì„ íŒŒì´í”„ë¼ì¸ ì‹œì‘...');
            console.log('ì…ë ¥ RGB:', skinRgb);

            // 1ë‹¨ê³„: í”¼ë¶€Â·ì¡°ëª… ë¶„ì„
            const step1 = analyzeSkinAndLighting(skinRgb, imageData);

            // 2ë‹¨ê³„: í¼ìŠ¤ë„ì»¬ëŸ¬ ë¶„ë¥˜
            const step2 = classifyPersonalColor(step1.correctedRgb, step1.lightingMeta);

            // 3ë‹¨ê³„: í—¤ì–´ì»¬ëŸ¬ í›„ë³´ í•„í„°ë§
            const step3 = filterHairColorCandidates(step2, hairColorData || []);

            // 4ë‹¨ê³„: ìµœì¢… ì¶”ì²œ
            const step4 = calculateFinalRecommendations(
                step2.lab,
                step3,
                step2,
                step1.lightingMeta
            );

            const result = {
                // í”¼ë¶€ ë¶„ì„
                originalRgb: step1.originalRgb,
                correctedRgb: step1.correctedRgb,
                lightingMeta: step1.lightingMeta,

                // í¼ìŠ¤ë„ì»¬ëŸ¬
                personalColor: step2,

                // í—¤ì–´ì»¬ëŸ¬ ì¶”ì²œ
                hairRecommendations: step4,

                // ë©”íƒ€
                pipelineVersion: '2.0',
                timestamp: new Date().toISOString()
            };

            console.log('ğŸš€ íŒŒì´í”„ë¼ì¸ ì™„ë£Œ:', result);
            return result;
        }

        // ì „ì—­ ë…¸ì¶œ
        window.runPersonalColorPipeline = runPersonalColorPipeline;
        window.analyzeSkinAndLighting = analyzeSkinAndLighting;
        window.classifyPersonalColor = classifyPersonalColor;

        // ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', function () {
            console.log('HAIRGATOR Personal Color ì‹œìŠ¤í…œ ì‹œì‘...');
            initializeSystem();
        });

        async function initializeSystem() {
            const timeoutId = setTimeout(() => {
                console.warn('ë¡œë”© íƒ€ì„ì•„ì›ƒ - ê°•ì œë¡œ ì•± í‘œì‹œ');
                document.getElementById('loading-screen').style.display = 'none';
                document.getElementById('main-app').classList.add('loaded');
                showToast('ì‹œìŠ¤í…œì´ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤', 'warning');
            }, 5000);

            try {
                console.log('ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹œì‘...');

                updateLoadingProgress(20, t('personalColor.loadingSteps.hairColorData') || 'í—¤ì–´ì»¬ëŸ¬ ë°ì´í„° ë¡œë“œ ì¤‘...');
                await loadHairColorData();

                updateLoadingProgress(40, t('personalColor.loadingSteps.uiSetup') || 'UI ì»´í¬ë„ŒíŠ¸ ì„¤ì • ì¤‘...');
                setupUI();

                updateLoadingProgress(60, t('personalColor.loadingSteps.aiEngine') || 'AI ì–¼êµ´ ì¸ì‹ ì—”ì§„ ì¤€ë¹„ ì¤‘...');
                // Face Mesh ë¯¸ë¦¬ ì´ˆê¸°í™” (ì¹´ë©”ë¼ ì‹œì‘ ì‹œ ë¹ ë¥´ê²Œ ì‘ë™í•˜ë„ë¡)
                await preloadFaceMesh();

                updateLoadingProgress(100, t('personalColor.loadingSteps.ready') || 'ì‹œìŠ¤í…œ ì¤€ë¹„ ì™„ë£Œ!');
                await new Promise(resolve => setTimeout(resolve, 500));

                clearTimeout(timeoutId);

                document.getElementById('loading-screen').style.display = 'none';
                document.getElementById('main-app').classList.add('loaded');

                console.log('HAIRGATOR Personal Color ì¤€ë¹„ ì™„ë£Œ');
                showToast(t('personalColor.loadingSteps.readyToast') || 'í¼ìŠ¤ë„ì»¬ëŸ¬ ì‹œìŠ¤í…œì´ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤!', 'success');

            } catch (error) {
                clearTimeout(timeoutId);
                console.error('ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹¤íŒ¨:', error);

                document.getElementById('loading-screen').style.display = 'none';
                document.getElementById('main-app').classList.add('loaded');
                showToast(t('personalColor.loadingSteps.partialError') || 'ì¼ë¶€ ê¸°ëŠ¥ì— ì œí•œì´ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.', 'warning');
            }
        }

        function updateLoadingProgress(percent, text) {
            const bar = document.getElementById('loading-bar');
            const textEl = document.getElementById('loading-text');
            if (bar) bar.style.width = percent + '%';
            if (textEl) textEl.textContent = text;
        }

        async function loadHairColorData() {
            try {
                if (parent && parent.HAIR_COLOR_614_DATA) {
                    hairColorData = parent.HAIR_COLOR_614_DATA;
                    console.log('ë¶€ëª¨ì°½ì—ì„œ 614ê°œ í—¤ì–´ì»¬ëŸ¬ ë°ì´í„° ë¡œë“œ ì™„ë£Œ');
                    checkShiseidoData();
                    return;
                }

                if (typeof HAIR_COLOR_614_DATA !== 'undefined') {
                    hairColorData = HAIR_COLOR_614_DATA;
                    console.log('ê¸€ë¡œë²Œ ë³€ìˆ˜ì—ì„œ 614ê°œ ë°ì´í„° ë¡œë“œ');
                    checkShiseidoData();
                    return;
                }

                if (parent && parent.hairColorDatabase) {
                    hairColorData = parent.hairColorDatabase;
                    console.log(`ë¶€ëª¨ì°½ ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ${hairColorData.length}ê°œ ë¡œë“œ`);
                    checkShiseidoData();
                    return;
                }

                await loadExternalHairColorData();
                checkShiseidoData();

            } catch (error) {
                console.error('í—¤ì–´ì»¬ëŸ¬ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:', error);
                hairColorData = generateDefaultHairColors();
                checkShiseidoData();
            }
        }

        async function loadExternalHairColorData() {
            try {
                const script = document.createElement('script');
                script.src = 'hair-color-data.js';
                script.onload = () => {
                    if (typeof HAIR_COLOR_614_DATA !== 'undefined') {
                        hairColorData = HAIR_COLOR_614_DATA;
                        console.log('ì™¸ë¶€ ìŠ¤í¬ë¦½íŠ¸ì—ì„œ 614ê°œ ë°ì´í„° ë¡œë“œ');
                    }
                };
                script.onerror = () => {
                    console.warn('ì™¸ë¶€ í—¤ì–´ì»¬ëŸ¬ ë°ì´í„° ìŠ¤í¬ë¦½íŠ¸ ë¡œë“œ ì‹¤íŒ¨');
                    hairColorData = generateDefaultHairColors();
                };

                document.head.appendChild(script);
                await new Promise(resolve => setTimeout(resolve, 3000));

                if (hairColorData.length === 0) {
                    hairColorData = generateDefaultHairColors();
                }

            } catch (error) {
                console.error('ì™¸ë¶€ ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜:', error);
                hairColorData = generateDefaultHairColors();
            }
        }

        function generateDefaultHairColors() {
            const brands = ['ë¡œë ˆì•Œ', 'ì›°ë¼', 'ë°€ë³¸'];
            const seasons = ['spring', 'summer', 'autumn', 'winter'];
            const data = [];

            brands.forEach(brand => {
                seasons.forEach(season => {
                    SeasonPalettes[season].colors.forEach((color, index) => {
                        data.push({
                            brand: brand,
                            name: `${season} Color ${index + 1}`,
                            hex: color,
                            season: season,
                            confidence: 0.8 + Math.random() * 0.2
                        });
                    });
                });
            });

            return data;
        }

        function checkShiseidoData() {
            const shiseidoCount = hairColorData.filter(item =>
                item.brand && (
                    item.brand.toLowerCase().includes('shiseido') ||
                    item.brand.toLowerCase().includes('ì‹œì„¸ì´ë„')
                )
            ).length;

            console.log(`í˜„ì¬ ì‹œì„¸ì´ë„ ë°ì´í„°: ${shiseidoCount}ê°œ`);

            if (shiseidoCount === 0) {
                console.warn('ì‹œì„¸ì´ë„ ë°ì´í„° ì—†ìŒ. ì¶”ê°€í•©ë‹ˆë‹¤...');
                addShiseidoData();
            } else {
                console.log('ì‹œì„¸ì´ë„ ë°ì´í„° í™•ì¸ë¨');
            }

            console.log(`ì´ ë°ì´í„°: ${hairColorData.length}ê°œ`);
        }

        function addShiseidoData() {
            const shiseidoData = [
                { brand: "Shiseido", line: "PRIMIENCE", code: "N5", name: "ë‚´ì¸„ëŸ´ ë¸Œë¼ìš´", hex: "#6B4E37", season: "autumn" },
                { brand: "Shiseido", line: "PRIMIENCE", code: "A6", name: "ì• ì‰¬ ë¸Œë¼ìš´", hex: "#8B7D6B", season: "summer" },
                { brand: "Shiseido", line: "PRIMIENCE", code: "G7", name: "ê³¨ë“  ë² ì´ì§€", hex: "#D2B48C", season: "spring" },
                { brand: "Shiseido", line: "ADENOVITAL", code: "AD01", name: "ë”¥ ë¸”ë™", hex: "#2F2F2F", season: "winter" },
                { brand: "Shiseido", line: "ADENOVITAL", code: "AD02", name: "ì†Œí”„íŠ¸ ë¸”ë™", hex: "#4A4A4A", season: "winter" },
                { brand: "Shiseido", line: "PRIMIENCE", code: "B8", name: "ë² ì´ì§€ ë¸Œë¼ìš´", hex: "#A0826D", season: "autumn" },
                { brand: "Shiseido", line: "PRIMIENCE", code: "M9", name: "ë§¤íŠ¸ ë¸Œë¼ìš´", hex: "#8B6F47", season: "autumn" },
                { brand: "Shiseido", line: "ADENOVITAL", code: "AD03", name: "ë‹¤í¬ ë¸Œë¼ìš´", hex: "#3D2F23", season: "winter" },
                { brand: "Shiseido", line: "ADENOVITAL", code: "AD04", name: "ì¿¨ ë¸Œë¼ìš´", hex: "#5D4E3A", season: "summer" },
                { brand: "Shiseido", line: "PRIMIENCE", code: "C10", name: "ì¹´ë¼ë©œ ë¸Œë¼ìš´", hex: "#B8860B", season: "spring" }
            ];

            hairColorData.push(...shiseidoData);
            console.log(`ì‹œì„¸ì´ë„ ${shiseidoData.length}ê°œ ë°ì´í„° ì¶”ê°€ ì™„ë£Œ`);
        }

        function setupUI() {
            selectSeason('spring');
            console.log('UI ì„¤ì • ì™„ë£Œ');
        }

        // Face Mesh ë¯¸ë¦¬ ë¡œë“œ (í˜ì´ì§€ ë¡œë“œ ì‹œ)
        async function preloadFaceMesh() {
            if (typeof FaceMesh === 'undefined') {
                console.log('FaceMesh ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì•„ì§ ë¡œë“œë˜ì§€ ì•ŠìŒ');
                return;
            }

            if (faceDetectionInstance) {
                console.log('Face Mesh ì´ë¯¸ ì´ˆê¸°í™”ë¨');
                return;
            }

            try {
                console.log('Face Mesh ë¯¸ë¦¬ ë¡œë“œ ì‹œì‘...');
                faceDetectionInstance = new FaceMesh({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/${file}`;
                    }
                });

                faceDetectionInstance.setOptions({
                    maxNumFaces: 1,
                    refineLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                faceDetectionInstance.onResults(onAdvancedFaceResults);

                // ì´ˆê¸°í™” ì™„ë£Œ ëŒ€ê¸° (WASM ë¡œë“œ)
                await faceDetectionInstance.initialize();

                console.log('âœ… Face Mesh ë¯¸ë¦¬ ë¡œë“œ ì™„ë£Œ');
            } catch (error) {
                console.warn('Face Mesh ë¯¸ë¦¬ ë¡œë“œ ì‹¤íŒ¨ (ì¹´ë©”ë¼ ì‹œì‘ ì‹œ ì¬ì‹œë„):', error);
                faceDetectionInstance = null;
            }
        }

        // ëª¨ë“œ ì„ íƒ ë° ì „í™˜ - ì „ì²´í™”ë©´ìœ¼ë¡œ ë³€ê²½
        function selectMode(mode) {
            console.log('ëª¨ë“œ ì„ íƒ:', mode);
            currentMode = mode;

            // ëª¨ë“œ ì„ íƒ í™”ë©´ ì™„ì „íˆ ìˆ¨ê¸°ê¸°
            document.getElementById('mode-selection').style.display = 'none';

            // ëª¨ë“  ì„¹ì…˜ ë¹„í™œì„±í™”
            document.querySelectorAll('.section').forEach(section => {
                section.classList.remove('active');
            });

            if (mode === 'ai') {
                const aiSection = document.getElementById('ai-analysis');
                aiSection.classList.add('active');
                aiSection.style.display = 'block';
                showToast('AI í¼ìŠ¤ë„ì»¬ëŸ¬ ë¶„ì„ ëª¨ë“œê°€ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤', 'success');
            } else if (mode === 'draping') {
                const drapingSection = document.getElementById('draping-mode');
                drapingSection.classList.add('active');
                drapingSection.style.display = 'block';
                showToast('ì „ë¬¸ê°€ ë“œë˜ì´í•‘ ëª¨ë“œê°€ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤', 'success');
            }
        }

        function goHome() {
            // ëª¨ë“  ì„¹ì…˜ ë¹„í™œì„±í™” ë° ìˆ¨ê¸°ê¸°
            document.querySelectorAll('.section').forEach(section => {
                section.classList.remove('active');
                section.style.display = '';  // ìŠ¤íƒ€ì¼ ì´ˆê¸°í™”
            });

            // ëª¨ë“œ ì„ íƒ í™”ë©´ ë‹¤ì‹œ í‘œì‹œ
            const modeSelection = document.getElementById('mode-selection');
            modeSelection.style.display = '';  // ìŠ¤íƒ€ì¼ ì´ˆê¸°í™”
            modeSelection.classList.add('active');

            stopAICamera();
            stopDrapingCamera();
            cleanupCameraResources();

            currentMode = null;
            showToast('í™ˆ í™”ë©´ìœ¼ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤', 'info');
        }

        // X ë²„íŠ¼ í´ë¦­ - í¼ìŠ¤ë„ì»¬ëŸ¬ í˜ì´ì§€ ë‹«ê¸°
        function closePersonalColor() {
            console.log('ğŸ¨ í¼ìŠ¤ë„ì»¬ëŸ¬ í˜ì´ì§€ ë‹«ê¸°');

            // ì¹´ë©”ë¼ ë¦¬ì†ŒìŠ¤ ì •ë¦¬
            stopAICamera();
            stopDrapingCamera();
            cleanupCameraResources();

            // ë¶€ëª¨ ì°½ì´ ìˆìœ¼ë©´ (iframeì¸ ê²½ìš°) ë¶€ëª¨ì—ê²Œ ë‹«ê¸° ìš”ì²­
            if (window.parent !== window) {
                try {
                    window.parent.postMessage({ type: 'CLOSE_PERSONAL_COLOR' }, '*');
                } catch (e) {
                    console.warn('ë¶€ëª¨ ì°½ í†µì‹  ì‹¤íŒ¨:', e);
                }
            }

            // ë©”ì¸ í˜ì´ì§€ë¡œ ì´ë™
            window.location.href = '/';
        }

        // AI ì¹´ë©”ë¼ í•¨ìˆ˜ë“¤
        async function startAICamera() {
            try {
                showToast('ì¹´ë©”ë¼ ê¶Œí•œì„ í™•ì¸í•©ë‹ˆë‹¤...', 'info');
                console.log('ğŸ¥ ì¹´ë©”ë¼ ì‹œì‘ ì‹œë„...');

                // 1. mediaDevices API ì§€ì› í™•ì¸
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('NOT_SUPPORTED: ì´ ë¸Œë¼ìš°ì €/ì•±ì—ì„œ ì¹´ë©”ë¼ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤');
                }

                // 2. ê¶Œí•œ ìƒíƒœ í™•ì¸ (ì§€ì›í•˜ëŠ” ê²½ìš°)
                if (navigator.permissions && navigator.permissions.query) {
                    try {
                        const permissionStatus = await navigator.permissions.query({ name: 'camera' });
                        console.log('ì¹´ë©”ë¼ ê¶Œí•œ ìƒíƒœ:', permissionStatus.state);

                        if (permissionStatus.state === 'denied') {
                            throw new Error('PERMISSION_DENIED: ì¹´ë©”ë¼ ê¶Œí•œì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤. ì•± ì„¤ì •ì—ì„œ ì¹´ë©”ë¼ ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”.');
                        }
                    } catch (permErr) {
                        console.log('ê¶Œí•œ ì¡°íšŒ ë¶ˆê°€ (ì •ìƒì¼ ìˆ˜ ìˆìŒ):', permErr.message);
                    }
                }

                cleanupCameraResources();

                // 3. ì¹´ë©”ë¼ ìŠ¤íŠ¸ë¦¼ ìš”ì²­ (ì—¬ëŸ¬ ì˜µì…˜ ì‹œë„)
                let stream = null;
                const videoConstraints = [
                    { facingMode: 'user', width: { ideal: 640 }, height: { ideal: 480 } },
                    { facingMode: 'user' },
                    { facingMode: { ideal: 'user' } },
                    true  // ê°€ì¥ ê¸°ë³¸ì ì¸ ì˜µì…˜
                ];

                for (const constraints of videoConstraints) {
                    try {
                        console.log('ì¹´ë©”ë¼ ì˜µì…˜ ì‹œë„:', JSON.stringify(constraints));
                        stream = await navigator.mediaDevices.getUserMedia({
                            video: constraints,
                            audio: false
                        });
                        console.log('âœ… ì¹´ë©”ë¼ ìŠ¤íŠ¸ë¦¼ íšë“ ì„±ê³µ');
                        break;
                    } catch (e) {
                        console.log('ì˜µì…˜ ì‹¤íŒ¨:', e.name, e.message);
                        continue;
                    }
                }

                if (!stream) {
                    throw new Error('STREAM_FAILED: ëª¨ë“  ì¹´ë©”ë¼ ì˜µì…˜ì´ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
                }

                activeVideoStream = stream;
                videoElement = document.getElementById('camera-feed');

                if (!videoElement) {
                    throw new Error('VIDEO_ELEMENT: ë¹„ë””ì˜¤ ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                }

                videoElement.srcObject = activeVideoStream;
                videoElement.setAttribute('playsinline', 'true');
                videoElement.setAttribute('autoplay', 'true');
                videoElement.muted = true;

                // ë¹„ë””ì˜¤ ì¬ìƒ ëŒ€ê¸°
                await new Promise((resolve, reject) => {
                    videoElement.onloadedmetadata = () => {
                        videoElement.play()
                            .then(resolve)
                            .catch(reject);
                    };
                    videoElement.onerror = reject;
                    setTimeout(() => reject(new Error('VIDEO_TIMEOUT')), 10000);
                });

                showToast('ì¹´ë©”ë¼ê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤!', 'success');

                canvasElement = document.getElementById('camera-canvas');
                canvasCtx = canvasElement.getContext('2d', { willReadFrequently: true });

                // MediaPipe Face Mesh ì´ˆê¸°í™” ë˜ëŠ” ì¬ì‚¬ìš©
                if (typeof FaceMesh !== 'undefined') {
                    try {
                        // Face Mesh ì¸ìŠ¤í„´ìŠ¤ê°€ ì—†ìœ¼ë©´ ìƒˆë¡œ ìƒì„±
                        if (!faceDetectionInstance) {
                            console.log('ìƒˆ Face Mesh ì¸ìŠ¤í„´ìŠ¤ ìƒì„±');
                            faceDetectionInstance = new FaceMesh({
                                locateFile: (file) => {
                                    return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/${file}`;
                                }
                            });

                            faceDetectionInstance.setOptions({
                                maxNumFaces: 1,
                                refineLandmarks: true,
                                minDetectionConfidence: 0.5,
                                minTrackingConfidence: 0.5
                            });

                            faceDetectionInstance.onResults(onAdvancedFaceResults);
                        } else {
                            console.log('ê¸°ì¡´ Face Mesh ì¸ìŠ¤í„´ìŠ¤ ì¬ì‚¬ìš©');
                            // ê¸°ì¡´ ì¸ìŠ¤í„´ìŠ¤ì—ë„ onResults ë‹¤ì‹œ ì„¤ì •
                            faceDetectionInstance.onResults(onAdvancedFaceResults);
                        }

                        // í”„ë ˆì„ ì¹´ìš´í„° ë¦¬ì…‹
                        frameCount = 0;

                        // MediaPipe CameraëŠ” í•­ìƒ ìƒˆë¡œ ìƒì„±
                        if (typeof Camera !== 'undefined') {
                            mediaPipeCamera = new Camera(videoElement, {
                                onFrame: async () => {
                                    if (faceDetectionInstance && videoElement && videoElement.readyState === 4) {
                                        try {
                                            await faceDetectionInstance.send({ image: videoElement });
                                        } catch (e) {
                                            // send ì‹¤íŒ¨ ì‹œ ë¬´ì‹œ (ì¹´ë©”ë¼ ì¤‘ì§€ ì‹œ ë°œìƒ ê°€ëŠ¥)
                                        }
                                    }
                                },
                                width: 640,
                                height: 480
                            });
                            mediaPipeCamera.start();
                        }

                        console.log('MediaPipe Face Mesh í™œì„±í™”');
                        showToast('ì–¼êµ´ ì¸ì‹ì´ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤', 'success');
                    } catch (error) {
                        console.warn('Face Mesh ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
                        showToast('ê¸°ë³¸ ì¹´ë©”ë¼ ëª¨ë“œë¡œ ì‹œì‘í•©ë‹ˆë‹¤', 'warning');
                    }
                }

                document.getElementById('ai-face-guide').style.display = 'flex';

            } catch (error) {
                console.error('âŒ ì¹´ë©”ë¼ ì‹œì‘ ì‹¤íŒ¨:', error);
                cleanupCameraResources();

                // ìƒì„¸í•œ ì—ëŸ¬ ë©”ì‹œì§€
                let userMessage = 'ì¹´ë©”ë¼ì— ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.';

                if (error.name === 'NotAllowedError' || error.message.includes('PERMISSION_DENIED')) {
                    userMessage = 'ì¹´ë©”ë¼ ê¶Œí•œì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤.\n\nì•± ì„¤ì • > ê¶Œí•œ > ì¹´ë©”ë¼ë¥¼ í—ˆìš©í•´ì£¼ì„¸ìš”.';
                } else if (error.name === 'NotFoundError') {
                    userMessage = 'ì¹´ë©”ë¼ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n\nê¸°ê¸°ì— ì¹´ë©”ë¼ê°€ ìˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.';
                } else if (error.name === 'NotReadableError') {
                    userMessage = 'ì¹´ë©”ë¼ê°€ ë‹¤ë¥¸ ì•±ì—ì„œ ì‚¬ìš© ì¤‘ì…ë‹ˆë‹¤.\n\në‹¤ë¥¸ ì•±ì„ ì¢…ë£Œí•˜ê³  ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.';
                } else if (error.message.includes('NOT_SUPPORTED')) {
                    userMessage = 'ì´ í™˜ê²½ì—ì„œëŠ” ì¹´ë©”ë¼ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.';
                } else if (error.name === 'OverconstrainedError') {
                    userMessage = 'ì¹´ë©”ë¼ ì„¤ì • ì˜¤ë¥˜ì…ë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.';
                }

                showToast(userMessage, 'error');

                // ë””ë²„ê¹…ìš© alert (ê°œë°œ ì¤‘ì—ë§Œ ì‚¬ìš©)
                // alert(`ì¹´ë©”ë¼ ì˜¤ë¥˜ ìƒì„¸:\n\nì´ë¦„: ${error.name}\në©”ì‹œì§€: ${error.message}`);
            }
        }

        // í”„ë ˆì„ ì¹´ìš´í„° (ë””ë²„ê¹…ìš©)
        let frameCount = 0;

        function onAdvancedFaceResults(results) {
            frameCount++;

            // 10í”„ë ˆì„ë§ˆë‹¤ ë¡œê·¸ (ë„ˆë¬´ ë§ì€ ë¡œê·¸ ë°©ì§€)
            if (frameCount % 30 === 1) {
                console.log(`ğŸ¯ Face Results ìˆ˜ì‹  #${frameCount}`, {
                    hasCanvas: !!canvasCtx,
                    hasVideo: !!videoElement,
                    hasFaces: results?.multiFaceLandmarks?.length > 0
                });
            }

            if (!canvasCtx || !videoElement) {
                console.warn('ìº”ë²„ìŠ¤ ë˜ëŠ” ë¹„ë””ì˜¤ ì—†ìŒ');
                return;
            }

            canvasElement.width = videoElement.videoWidth || 640;
            canvasElement.height = videoElement.videoHeight || 480;

            // ë¨¼ì € ë¹„ë””ì˜¤ í”„ë ˆì„ì„ ìº”ë²„ìŠ¤ì— ê·¸ë¦¼ (ë°°ê²½)
            canvasCtx.save();
            canvasCtx.scale(-1, 1); // ê±°ìš¸ ëª¨ë“œ (ì¢Œìš° ë°˜ì „)
            canvasCtx.drawImage(videoElement, -canvasElement.width, 0, canvasElement.width, canvasElement.height);
            canvasCtx.restore();

            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];

                // í˜„ì¬ ëœë“œë§ˆí¬ ì €ì¥ (ì´¬ì˜ ì‹œ ì‚¬ìš©)
                currentLandmarks = landmarks;

                drawFullFaceMesh(canvasCtx, landmarks);
                drawSkinTonePoints(canvasCtx, landmarks);

                // ì´¬ì˜ ëª¨ë“œê°€ ì•„ë‹ ë•Œë§Œ ì´¬ì˜ ë²„íŠ¼ í‘œì‹œ
                if (!isCaptured) {
                    if (!faceDetected) {
                        faceDetected = true;
                        document.getElementById('ai-face-guide').style.display = 'none';

                        // ì´¬ì˜ ë²„íŠ¼ í‘œì‹œ
                        document.getElementById('capture-btn').style.display = 'inline-block';
                        document.getElementById('capture-guide').style.display = 'block';

                        console.log('âœ… ì–¼êµ´ ì¸ì‹ ì™„ë£Œ! ì´¬ì˜ ëŒ€ê¸° ì¤‘...');
                        const pc = HAIRGATOR_I18N[currentLang]?.personalColor?.aiMode;
                        showToast(pc?.faceDetected || 'ì–¼êµ´ì´ ì¸ì‹ë˜ì—ˆìŠµë‹ˆë‹¤! ì´¬ì˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”', 'success');
                    }
                }
            } else {
                if (faceDetected && !isCaptured) {
                    faceDetected = false;
                    document.getElementById('ai-face-guide').style.display = 'flex';

                    // ì´¬ì˜ ë²„íŠ¼ ìˆ¨ê¸°ê¸°
                    document.getElementById('capture-btn').style.display = 'none';
                    document.getElementById('capture-guide').style.display = 'none';
                }
            }
        }

        // í˜„ì¬ ëœë“œë§ˆí¬ ì €ì¥ìš© ë³€ìˆ˜
        let currentLandmarks = null;
        let isCaptured = false;

        // ì´¬ì˜í•˜ê¸° í•¨ìˆ˜
        function captureAndAnalyze() {
            if (!currentLandmarks) {
                const pc = HAIRGATOR_I18N[currentLang]?.personalColor?.aiMode;
                showToast(pc?.faceGuide || 'ì–¼êµ´ì„ ë¨¼ì € ì¸ì‹í•´ì£¼ì„¸ìš”', 'warning');
                return;
            }

            console.log('ğŸ“¸ ì´¬ì˜ ì‹œì‘!');
            isCaptured = true;

            // ë²„íŠ¼ ìƒíƒœ ë³€ê²½
            document.getElementById('capture-btn').style.display = 'none';
            document.getElementById('capture-guide').style.display = 'none';
            document.getElementById('retry-btn').style.display = 'inline-block';

            // ì´¬ì˜ íš¨ê³¼ (í”Œë˜ì‹œ)
            const flash = document.createElement('div');
            flash.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: white;
                z-index: 9999;
                animation: flashFade 0.3s ease-out forwards;
            `;
            document.body.appendChild(flash);
            setTimeout(() => flash.remove(), 300);

            // í”¼ë¶€í†¤ ë¶„ì„
            const skinToneData = extractSkinTone(currentLandmarks);
            console.log('ğŸ§ª ì´¬ì˜ëœ í”¼ë¶€í†¤ ë°ì´í„°:', skinToneData);

            // ë¶„ì„ ê²°ê³¼ í‘œì‹œ
            displayCapturedAnalysis(skinToneData);

            // ë¶„ì„ ì§„í–‰ ë‹¨ê³„ ì• ë‹ˆë©”ì´ì…˜
            animateAnalysisSteps();

            const pc = HAIRGATOR_I18N[currentLang]?.personalColor?.aiMode;
            showToast(pc?.captureComplete || 'ì´¬ì˜ ì™„ë£Œ! ë¶„ì„ ê²°ê³¼ë¥¼ í™•ì¸í•˜ì„¸ìš”', 'success');
        }

        // ë‹¤ì‹œ ì´¬ì˜ í•¨ìˆ˜
        function retryCapture() {
            console.log('ğŸ”„ ë‹¤ì‹œ ì´¬ì˜');
            isCaptured = false;
            currentLandmarks = null;
            faceDetected = false;

            // ë²„íŠ¼ ìƒíƒœ ì´ˆê¸°í™”
            document.getElementById('retry-btn').style.display = 'none';
            document.getElementById('capture-btn').style.display = 'none';
            document.getElementById('capture-guide').style.display = 'none';
            document.getElementById('ai-face-guide').style.display = 'flex';

            // ê²°ê³¼ ìˆ¨ê¸°ê¸°
            document.getElementById('realtime-results-container').style.display = 'none';
            document.getElementById('ai-analysis-results').style.display = 'none';

            // ë¶„ì„ ë‹¨ê³„ ì´ˆê¸°í™”
            resetAnalysisSteps();

            const pc = HAIRGATOR_I18N[currentLang]?.personalColor?.aiMode;
            showToast(pc?.retryMessage || 'ë‹¤ì‹œ ì–¼êµ´ì„ í™”ë©´ì— ë§ì¶°ì£¼ì„¸ìš”', 'info');
        }

        // ë¶„ì„ ë‹¨ê³„ ì• ë‹ˆë©”ì´ì…˜
        function animateAnalysisSteps() {
            const steps = ['ai-step-1', 'ai-step-2', 'ai-step-3', 'ai-step-4'];
            let delay = 0;

            steps.forEach((stepId, index) => {
                setTimeout(() => {
                    const step = document.getElementById(stepId);
                    if (step) {
                        step.classList.add('active');
                        step.style.background = 'rgba(76, 175, 80, 0.2)';
                        step.style.borderColor = '#4CAF50';
                    }

                    // ë§ˆì§€ë§‰ ë‹¨ê³„ ì™„ë£Œ ì‹œ ê²°ê³¼ í‘œì‹œ
                    if (index === steps.length - 1) {
                        setTimeout(() => {
                            document.getElementById('ai-analysis-results').style.display = 'block';
                        }, 300);
                    }
                }, delay);
                delay += 400;
            });
        }

        // ë¶„ì„ ë‹¨ê³„ ì´ˆê¸°í™”
        function resetAnalysisSteps() {
            const steps = ['ai-step-1', 'ai-step-2', 'ai-step-3', 'ai-step-4'];
            steps.forEach(stepId => {
                const step = document.getElementById(stepId);
                if (step) {
                    step.classList.remove('active');
                    step.style.background = '';
                    step.style.borderColor = '';
                }
            });
        }

        // ì´¬ì˜ëœ ë¶„ì„ ê²°ê³¼ í‘œì‹œ (ìƒˆ íŒŒì´í”„ë¼ì¸ ì‚¬ìš©)
        function displayCapturedAnalysis(skinToneData) {
            if (!skinToneData) {
                console.log('âŒ í”¼ë¶€í†¤ ë°ì´í„°ê°€ ì—†ìŒ');
                return;
            }

            // ğŸš€ ìƒˆ íŒŒì´í”„ë¼ì¸ ì‹¤í–‰
            const pipelineResult = runPersonalColorPipeline(skinToneData.rgb, window.lastFullImageData);
            const pc = pipelineResult.personalColor;
            const hairRec = pipelineResult.hairRecommendations;
            const lm = pipelineResult.lightingMeta;

            // i18n í…ìŠ¤íŠ¸ ê°€ì ¸ì˜¤ê¸°
            const undertoneText = getUndertoneText(pc.undertone);
            const seasonText = getSeasonText(pc.fullSeason);
            const seasonDescText = getSeasonDescriptionText(pc.fullSeason);
            const seasonRecommendText = getSeasonRecommendationText(pc.fullSeason);
            const resultTexts = getResultTexts();

            console.log('ğŸ“Š íŒŒì´í”„ë¼ì¸ ë¶„ì„ ê²°ê³¼:', pipelineResult);

            // ì¡°ëª… í’ˆì§ˆ í‘œì‹œ í…ìŠ¤íŠ¸
            const lightingQualityText = lm.lightingQuality >= 0.7 ? 'ì¢‹ìŒ' :
                                        lm.lightingQuality >= 0.5 ? 'ë³´í†µ' : 'ë‚®ìŒ (ì°¸ê³ ìš©)';
            const lightingColor = lm.lightingQuality >= 0.7 ? '#4CAF50' :
                                  lm.lightingQuality >= 0.5 ? '#FF9800' : '#F44336';

            // í—¤ì–´ì»¬ëŸ¬ ì¶”ì²œ HTML ìƒì„± (ì—…ê·¸ë ˆì´ë“œ: ë±ƒì§€ + ë‚œì´ë„ í¬í•¨)
            const hairRecommendHTML = generateHairRecommendHTML(hairRec, pc);

            // ì „ë¬¸ê°€ í”¼ë“œë°± HTML ìƒì„±
            const expertFeedbackHTML = generateExpertFeedbackHTML(pc);

            // ë©”ì¸ ê²°ê³¼ ì»¨í…Œì´ë„ˆ í‘œì‹œ
            const resultsContainer = document.getElementById('realtime-results-container');
            if (resultsContainer) {
                resultsContainer.style.display = 'block';
                resultsContainer.style.background = 'rgba(30, 30, 50, 0.95)';
                resultsContainer.style.padding = '25px';
                resultsContainer.style.borderRadius = '16px';
                resultsContainer.style.border = '2px solid ' + pc.color;
                resultsContainer.style.maxHeight = '70vh';
                resultsContainer.style.overflowY = 'auto';

                // âœ… ì¡°ëª… ë‚®ì„ ë•Œ ëª…ì‹œì  ê²½ê³  ë°°ë„ˆ
                const lightingWarningBanner = lm.lightingQuality < 0.4 ? `
                    <div style="background: linear-gradient(135deg, #FF5722, #E64A19); padding: 15px; border-radius: 10px; margin-bottom: 15px; box-shadow: 0 2px 10px rgba(255,87,34,0.3);">
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                            <span style="font-size: 24px;">âš ï¸</span>
                            <span style="color: #fff; font-weight: bold; font-size: 15px;">ì¡°ëª… í™˜ê²½ ì£¼ì˜</span>
                        </div>
                        <p style="color: rgba(255,255,255,0.9); font-size: 13px; margin: 0; line-height: 1.6;">
                            í˜„ì¬ ì¡°ëª…ì´ ì–´ë‘¡ê±°ë‚˜ ìƒ‰ì˜¨ë„ê°€ ë¶ˆì•ˆì •í•˜ì—¬ <b>ë¶„ì„ ì •í™•ë„ê°€ ë–¨ì–´ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</b><br>
                            ë” ë°ì€ ìì—°ê´‘ ë˜ëŠ” ì£¼ê´‘ìƒ‰ ì¡°ëª…ì—ì„œ ë‹¤ì‹œ ì´¬ì˜í•˜ëŠ” ê²ƒì„ ê¶Œì¥í•©ë‹ˆë‹¤.
                        </p>
                    </div>
                ` : '';

                resultsContainer.innerHTML = `
                    <h4 style="margin: 0 0 20px 0; color: #fff; font-size: 18px; text-align: center;">ğŸ¨ ${resultTexts.title}</h4>

                    <!-- âœ… ì¡°ëª… ê²½ê³  ë°°ë„ˆ (ì¡°ëª… ë‚˜ì  ë•Œë§Œ í‘œì‹œ) -->
                    ${lightingWarningBanner}

                    <!-- ì¡°ëª… ìƒíƒœ í‘œì‹œ -->
                    <div style="background: rgba(255,255,255,0.05); padding: 10px 15px; border-radius: 8px; margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center;">
                        <span style="color: #aaa; font-size: 13px;">ğŸ’¡ ì¡°ëª… ì•ˆì •ë„</span>
                        <span style="color: ${lightingColor}; font-weight: bold; font-size: 13px;">${lightingQualityText} (${Math.round(lm.lightingQuality * 100)}%)</span>
                    </div>

                    <!-- í”¼ë¶€ ë¶„ì„ ì„¹ì…˜ -->
                    <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 12px; margin-bottom: 15px;">
                        <div style="font-size: 14px; color: #aaa; margin-bottom: 8px;">ğŸ“ ${resultTexts.skinAnalysis}</div>
                        <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 12px;">
                            <div style="width: 50px; height: 50px; background: ${skinToneData.hex}; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 10px rgba(0,0,0,0.3);"></div>
                            <div>
                                <div style="font-size: 16px; color: #fff; font-weight: bold;">${resultTexts.skinTone}: ${skinToneData.hex}</div>
                                <div style="font-size: 13px; color: #ccc;">L: ${pc.lab.L.toFixed(1)} / C: ${pc.chroma}</div>
                            </div>
                        </div>
                        <div style="font-size: 16px; color: #fff;">
                            <span style="color: #aaa;">${resultTexts.undertone}:</span>
                            <b style="color: ${pc.color};">${undertoneText}</b>
                        </div>
                    </div>

                    <!-- ì¶”ì²œ í¼ìŠ¤ë„ì»¬ëŸ¬ ì„¹ì…˜ -->
                    <div style="background: linear-gradient(135deg, ${pc.color}33, ${pc.color}11); padding: 20px; border-radius: 12px; border: 2px solid ${pc.color};">
                        <div style="font-size: 14px; color: #aaa; margin-bottom: 8px;">${resultTexts.recommendedSeason || 'âœ¨ ì¶”ì²œ í¼ìŠ¤ë„ì»¬ëŸ¬'}</div>
                        <div style="font-size: 26px; font-weight: bold; color: ${pc.color}; margin-bottom: 10px;">
                            ${pc.emoji} ${seasonText}
                        </div>
                        <div style="font-size: 14px; color: #eee; line-height: 1.8;">
                            ${seasonDescText}
                        </div>
                        ${pc.isReference ? '<div style="margin-top: 10px; padding: 8px; background: rgba(255,152,0,0.2); border-radius: 6px; font-size: 12px; color: #FFB74D;">âš ï¸ ì¡°ëª…ì´ ë¶ˆì•ˆì •í•˜ì—¬ ì°¸ê³ ìš©ìœ¼ë¡œë§Œ í™œìš©í•´ì£¼ì„¸ìš”</div>' : ''}
                    </div>

                    <!-- ì¶”ì²œ ì»¬ëŸ¬ íŒ”ë ˆíŠ¸ -->
                    <div style="margin-top: 15px; background: rgba(255,255,255,0.08); padding: 20px; border-radius: 12px;">
                        <div style="font-size: 14px; color: #aaa; margin-bottom: 12px;">ğŸ’„ ${resultTexts.matchingColors}</div>
                        <div style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 15px;">
                            ${getSeasonColorPalette(pc.fullSeason)}
                        </div>
                        <div style="font-size: 14px; color: #eee; line-height: 1.8;">
                            ${seasonRecommendText}
                        </div>
                    </div>

                    <!-- ğŸ’‡ í—¤ì–´ì»¬ëŸ¬ ì¶”ì²œ ì„¹ì…˜ -->
                    ${hairRecommendHTML}

                    <!-- ğŸ‘©â€ğŸ¨ ë””ìì´ë„ˆ ì „ë¬¸ê°€ ê°€ì´ë“œ ì„¹ì…˜ -->
                    ${expertFeedbackHTML}

                    <!-- âš ï¸ í”¼í•´ì•¼ í•  ì»¬ëŸ¬ -->
                    <div style="margin-top: 15px; background: rgba(244,67,54,0.1); padding: 15px; border-radius: 12px; border: 1px solid rgba(244,67,54,0.3);">
                        <div style="font-size: 14px; color: #F44336; margin-bottom: 10px; font-weight: bold;">âš ï¸ í”¼í•´ì•¼ í•  ì»¬ëŸ¬</div>
                        <ul style="margin: 0; padding-left: 20px; color: #ffcdd2; font-size: 13px; line-height: 1.8;">
                            ${hairRec.avoidRules.map(rule => `<li>${rule}</li>`).join('')}
                        </ul>
                    </div>
                `;
            }

            // ì˜¤ë¥¸ìª½ ë¶„ì„ íŒ¨ë„ ì—…ë°ì´íŠ¸
            const seasonResult = document.getElementById('ai-season-result');
            const confidenceEl = document.getElementById('ai-confidence');
            const analysisData = document.getElementById('ai-analysis-data');

            if (seasonResult) {
                seasonResult.innerHTML = `${pc.emoji} ${seasonText}`;
                seasonResult.style.color = pc.color;
                seasonResult.style.fontSize = '20px';
            }

            if (confidenceEl) {
                confidenceEl.innerHTML = `${resultTexts.confidence}: <b style="color: #00E676;">${pc.confidence}%</b>`;
            }

            if (analysisData) {
                analysisData.innerHTML = `
                    <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 15px;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <div style="width: 24px; height: 24px; background: ${skinToneData.hex}; border-radius: 6px; border: 2px solid #fff;"></div>
                            <span style="color: #fff;">${resultTexts.skinTone}: ${skinToneData.hex}</span>
                        </div>
                        <div style="color: #fff;">${resultTexts.undertone}: <b style="color: ${pc.color};">${undertoneText}</b></div>
                        <div style="color: #aaa; font-size: 12px;">ì¡°ëª…: ${lightingQualityText}</div>
                    </div>
                `;
            }
        }

        // í—¤ì–´ì»¬ëŸ¬ ì¶”ì²œ HTML ìƒì„±
        function generateHairRecommendHTML(hairRec, personalColorResult) {
            if (!hairRec.recommended1st || hairRec.recommended1st.length === 0) {
                return `
                    <div style="margin-top: 15px; background: rgba(255,255,255,0.08); padding: 20px; border-radius: 12px;">
                        <div style="font-size: 14px; color: #aaa;">ğŸ’‡ ì¶”ì²œ í—¤ì–´ì»¬ëŸ¬</div>
                        <div style="color: #ccc; font-size: 13px; margin-top: 10px;">í—¤ì–´ì»¬ëŸ¬ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>
                    </div>
                `;
            }

            // ì—…ê·¸ë ˆì´ë“œëœ ì»¬ëŸ¬ ì•„ì´í…œ ë Œë”ëŸ¬ (ë±ƒì§€ + ë‚œì´ë„ í¬í•¨)
            const renderColorItemAdvanced = (color, rank) => {
                const badge = getPriorityBadge(color.priority || (rank <= 3 ? rank : 4));
                const difficulty = getColorDifficulty(color, personalColorResult || {});

                // ë‚œì´ë„ì— ë”°ë¥¸ ë°°ê²½ìƒ‰
                const diffBgColor = difficulty.difficulty === 'hard' ? 'rgba(255,87,34,0.15)' :
                                    difficulty.difficulty === 'medium' ? 'rgba(255,152,0,0.15)' : 'rgba(76,175,80,0.1)';

                return `
                <div style="display: flex; flex-direction: column; gap: 8px; padding: 12px; background: rgba(255,255,255,0.05); border-radius: 10px; margin-bottom: 10px; border-left: 3px solid ${badge.color};">
                    <!-- ìƒë‹¨: ì»¬ëŸ¬ ìŠ¤ì™€ì¹˜ + ì •ë³´ -->
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <div style="position: relative; flex-shrink: 0;">
                            <div style="width: 45px; height: 45px; background: ${color.hex}; border-radius: 10px; border: 2px solid rgba(255,255,255,0.3);"></div>
                            <!-- ìš°ì„ ìˆœìœ„ ë±ƒì§€ -->
                            <span style="position: absolute; top: -6px; right: -6px; font-size: 14px;" title="${badge.label}">${badge.icon}</span>
                        </div>
                        <div style="flex: 1; min-width: 0;">
                            <div style="font-size: 14px; color: #fff; font-weight: 600; margin-bottom: 2px;">${color.name || 'ì»¬ëŸ¬'}</div>
                            <div style="font-size: 11px; color: #aaa;">${color.brand || ''} ${color.line || ''} ${color.code || ''}</div>
                            ${color.level ? `<div style="font-size: 10px; color: #888; margin-top: 2px;">Level ${color.level}</div>` : ''}
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 13px; color: #4CAF50; font-weight: bold;">${color.harmonyScore}ì </div>
                            <div style="font-size: 10px; color: ${badge.color};">${badge.label}</div>
                        </div>
                    </div>
                    <!-- í•˜ë‹¨: ì‹œìˆ  ë‚œì´ë„ -->
                    <div style="display: flex; align-items: center; gap: 8px; padding: 6px 10px; background: ${diffBgColor}; border-radius: 6px;">
                        <span style="font-size: 14px;">${difficulty.icon}</span>
                        <span style="font-size: 11px; color: #ddd; font-weight: 500;">${difficulty.label}</span>
                        <span style="font-size: 10px; color: #999; flex: 1;">${difficulty.tip}</span>
                    </div>
                </div>
            `;
            };

            let html = `
                <div style="margin-top: 15px; background: rgba(76,175,80,0.1); padding: 20px; border-radius: 12px; border: 1px solid rgba(76,175,80,0.3);">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;">
                        <div style="font-size: 15px; color: #4CAF50; font-weight: bold;">ğŸ’‡ 1ìˆœìœ„ ì¶”ì²œ í—¤ì–´ì»¬ëŸ¬</div>
                        <div style="font-size: 11px; color: #81C784; background: rgba(76,175,80,0.2); padding: 3px 8px; border-radius: 10px;">ê°•ì¶”ì²œ</div>
                    </div>
                    ${hairRec.recommended1st.map((c, i) => renderColorItemAdvanced(c, i+1)).join('')}
                </div>
            `;

            if (hairRec.recommended2nd && hairRec.recommended2nd.length > 0) {
                html += `
                    <div style="margin-top: 15px; background: rgba(255,255,255,0.08); padding: 20px; border-radius: 12px;">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;">
                            <div style="font-size: 15px; color: #aaa; font-weight: bold;">ğŸ’‡ 2ìˆœìœ„ ì¶”ì²œ í—¤ì–´ì»¬ëŸ¬</div>
                            <div style="font-size: 11px; color: #888; background: rgba(255,255,255,0.1); padding: 3px 8px; border-radius: 10px;">ë¬´ë‚œí•¨</div>
                        </div>
                        ${hairRec.recommended2nd.map((c, i) => renderColorItemAdvanced(c, i+4)).join('')}
                    </div>
                `;
            }

            return html;
        }

        // ì „ë¬¸ê°€ í”¼ë“œë°± HTML ìƒì„± í•¨ìˆ˜
        function generateExpertFeedbackHTML(personalColorResult) {
            const { season, subtype, lab } = personalColorResult;
            const feedback = generateAdvancedExpertFeedback(season, subtype, lab);

            if (!feedback.toneKeywords || feedback.toneKeywords.length === 0) {
                return '';
            }

            return `
                <div style="margin-top: 15px; background: linear-gradient(135deg, rgba(156,39,176,0.15), rgba(103,58,183,0.15)); padding: 20px; border-radius: 12px; border: 1px solid rgba(156,39,176,0.3);">
                    <div style="font-size: 15px; color: #CE93D8; margin-bottom: 15px; font-weight: bold;">
                        ğŸ‘©â€ğŸ¨ ë””ìì´ë„ˆ ì „ë¬¸ê°€ ê°€ì´ë“œ
                    </div>

                    <!-- ì¶”ì²œ í†¤ í‚¤ì›Œë“œ -->
                    <div style="margin-bottom: 12px;">
                        <div style="font-size: 12px; color: #B39DDB; margin-bottom: 6px;">ğŸ¨ ì¶”ì²œ í†¤ í‚¤ì›Œë“œ</div>
                        <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                            ${feedback.toneKeywords.map(kw => `
                                <span style="background: rgba(156,39,176,0.3); color: #E1BEE7; padding: 4px 10px; border-radius: 12px; font-size: 12px;">${kw}</span>
                            `).join('')}
                        </div>
                    </div>

                    <!-- ì¶”ì²œ ë ˆë²¨ -->
                    <div style="display: flex; gap: 15px; margin-bottom: 12px; flex-wrap: wrap;">
                        <div style="flex: 1; min-width: 120px; background: rgba(255,255,255,0.05); padding: 10px; border-radius: 8px;">
                            <div style="font-size: 11px; color: #B39DDB; margin-bottom: 4px;">ğŸ“Š ì¶”ì²œ ë ˆë²¨</div>
                            <div style="font-size: 14px; color: #fff; font-weight: bold;">${feedback.levelTip}</div>
                        </div>
                        ${feedback.brightnessAdvice ? `
                        <div style="flex: 1; min-width: 150px; background: rgba(255,255,255,0.05); padding: 10px; border-radius: 8px;">
                            <div style="font-size: 11px; color: #B39DDB; margin-bottom: 4px;">ğŸ’¡ í”¼ë¶€ ë°ê¸° ê¸°ì¤€</div>
                            <div style="font-size: 12px; color: #ddd;">${feedback.brightnessAdvice}</div>
                        </div>
                        ` : ''}
                    </div>

                    <!-- ì–¸ë”ì½”íŠ¸ & ì§ˆê° íŒ -->
                    <div style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 8px; margin-bottom: 12px;">
                        <div style="font-size: 12px; color: #B39DDB; margin-bottom: 6px;">ğŸ§´ ì‹œìˆ  íŒ</div>
                        <div style="font-size: 12px; color: #ddd; line-height: 1.7;">
                            <div style="margin-bottom: 4px;"><b style="color: #CE93D8;">ì–¸ë”ì½”íŠ¸:</b> ${feedback.undercoatTip}</div>
                            <div><b style="color: #CE93D8;">ë§ˆë¬´ë¦¬ ì§ˆê°:</b> ${feedback.textureTip}</div>
                        </div>
                    </div>

                    <!-- ì»¨ì„¤íŒ… ì¡°ì–¸ -->
                    <div style="background: rgba(103,58,183,0.2); padding: 12px; border-radius: 8px;">
                        <div style="font-size: 12px; color: #B39DDB; margin-bottom: 6px;">ğŸ’¬ ì»¨ì„¤íŒ… í¬ì¸íŠ¸</div>
                        <div style="font-size: 12px; color: #E1BEE7; line-height: 1.7;">${feedback.consultingTip}</div>
                        <div style="font-size: 11px; color: #9575CD; margin-top: 8px; font-style: italic;">"${feedback.seasonalAdvice}"</div>
                    </div>

                    <!-- í”¼í•´ì•¼ í•  í†¤ -->
                    ${feedback.avoidColors && feedback.avoidColors.length > 0 ? `
                    <div style="margin-top: 12px; padding: 10px; background: rgba(244,67,54,0.1); border-radius: 8px; border: 1px solid rgba(244,67,54,0.2);">
                        <div style="font-size: 11px; color: #EF9A9A; margin-bottom: 6px;">â›” í”¼í•´ì•¼ í•  í†¤</div>
                        <div style="display: flex; flex-wrap: wrap; gap: 5px;">
                            ${feedback.avoidColors.map(c => `
                                <span style="background: rgba(244,67,54,0.2); color: #FFCDD2; padding: 3px 8px; border-radius: 10px; font-size: 11px;">${c}</span>
                            `).join('')}
                        </div>
                    </div>
                    ` : ''}
                </div>
            `;
        }

        // ì‹œì¦Œë³„ ì„¤ëª… (ê°œì„ ëœ 8íƒ€ì…)
        function getSeasonDescription(season) {
            const descriptions = {
                // ë´„ ì›œ
                'ë´„ ì›œ ë¸Œë¼ì´íŠ¸': 'ìƒê¸° ë„˜ì¹˜ê³  í™”ì‚¬í•œ ì´ë¯¸ì§€! ì„ ëª…í•˜ê³  ë°ì€ ì›œí†¤ ì»¬ëŸ¬ê°€ ì˜ ì–´ìš¸ë¦½ë‹ˆë‹¤.',
                'ë´„ ì›œ ë¼ì´íŠ¸': 'ë§‘ê³  ì²­ìˆœí•œ ì´ë¯¸ì§€! ì—°í•˜ê³  ë¶€ë“œëŸ¬ìš´ ì›œí†¤ ì»¬ëŸ¬ê°€ ì˜ ì–´ìš¸ë¦½ë‹ˆë‹¤.',
                // ê°€ì„ ì›œ
                'ê°€ì„ ì›œ ë”¥': 'ê¹Šê³  ê³ ê¸‰ìŠ¤ëŸ¬ìš´ ì´ë¯¸ì§€! ì§„í•˜ê³  í’ë¶€í•œ ì›œí†¤ ì»¬ëŸ¬ê°€ ì˜ ì–´ìš¸ë¦½ë‹ˆë‹¤.',
                'ê°€ì„ ì›œ ë®¤íŠ¸': 'ë‚´ì¶”ëŸ´í•˜ê³  ì„¸ë ¨ëœ ì´ë¯¸ì§€! ì°¨ë¶„í•˜ê³  ìì—°ìŠ¤ëŸ¬ìš´ ì›œí†¤ ì»¬ëŸ¬ê°€ ì˜ ì–´ìš¸ë¦½ë‹ˆë‹¤.',
                'ê°€ì„ ì›œ ì†Œí”„íŠ¸': 'ë¶€ë“œëŸ½ê³  ë”°ëœ»í•œ ì´ë¯¸ì§€! ì€ì€í•˜ê³  ìì—°ìŠ¤ëŸ¬ìš´ ì›œí†¤ ì»¬ëŸ¬ê°€ ì˜ ì–´ìš¸ë¦½ë‹ˆë‹¤.',
                // ì—¬ë¦„ ì¿¨
                'ì—¬ë¦„ ì¿¨ ë¸Œë¼ì´íŠ¸': 'ì²­ì•„í•˜ê³  ì‹œì›í•œ ì´ë¯¸ì§€! ì„ ëª…í•˜ê³  ê¹¨ë—í•œ ì¿¨í†¤ ì»¬ëŸ¬ê°€ ì˜ ì–´ìš¸ë¦½ë‹ˆë‹¤.',
                'ì—¬ë¦„ ì¿¨ ë¼ì´íŠ¸': 'ìš°ì•„í•˜ê³  ë¶€ë“œëŸ¬ìš´ ì´ë¯¸ì§€! íŒŒìŠ¤í…”í†¤ì˜ ì¿¨ ì»¬ëŸ¬ê°€ ì˜ ì–´ìš¸ë¦½ë‹ˆë‹¤.',
                // ê²¨ìš¸ ì¿¨
                'ê²¨ìš¸ ì¿¨ ë”¥': 'ê°•ë ¬í•˜ê³  ë„ì‹œì ì¸ ì´ë¯¸ì§€! ì„ ëª…í•˜ê³  ì§„í•œ ì¿¨í†¤ ì»¬ëŸ¬ê°€ ì˜ ì–´ìš¸ë¦½ë‹ˆë‹¤.',
                'ê²¨ìš¸ ì¿¨ ë®¤íŠ¸': 'ì°¨ë¶„í•˜ê³  ì„¸ë ¨ëœ ì´ë¯¸ì§€! ë¬´ì±„ìƒ‰ ê³„ì—´ê³¼ ì €ì±„ë„ ì¿¨ ì»¬ëŸ¬ê°€ ì˜ ì–´ìš¸ë¦½ë‹ˆë‹¤.',
                // ë‰´íŠ¸ëŸ´
                'ë‰´íŠ¸ëŸ´ ë¼ì´íŠ¸': 'ë‹¤ì–‘í•œ ì»¬ëŸ¬ê°€ ì–´ìš¸ë¦¬ëŠ” íƒ€ì…! ë°ì€ í†¤ì˜ ë¶€ë“œëŸ¬ìš´ ì»¬ëŸ¬ë¥¼ ì¶”ì²œí•©ë‹ˆë‹¤.',
                'ë‰´íŠ¸ëŸ´ ë”¥': 'ë‹¤ì–‘í•œ ì»¬ëŸ¬ê°€ ì–´ìš¸ë¦¬ëŠ” íƒ€ì…! ê¹Šì€ í†¤ì˜ ì„¸ë ¨ëœ ì»¬ëŸ¬ë¥¼ ì¶”ì²œí•©ë‹ˆë‹¤.'
            };
            return descriptions[season] || '';
        }

        // ì‹œì¦Œë³„ ì»¬ëŸ¬ íŒ”ë ˆíŠ¸ (ê°œì„ ëœ 8íƒ€ì…)
        function getSeasonColorPalette(season) {
            const palettes = {
                // ë´„ ì›œ
                'ë´„ ì›œ ë¸Œë¼ì´íŠ¸': ['#FF6347', '#FF7F50', '#FFD700', '#00CED1', '#FF69B4'],
                'ë´„ ì›œ ë¼ì´íŠ¸': ['#FFDAB9', '#FFE4B5', '#F5DEB3', '#98FB98', '#FFB6C1'],
                // ê°€ì„ ì›œ
                'ê°€ì„ ì›œ ë”¥': ['#8B4513', '#A0522D', '#800000', '#556B2F', '#8B0000'],
                'ê°€ì„ ì›œ ë®¤íŠ¸': ['#CD853F', '#D2691E', '#BDB76B', '#808000', '#BC8F8F'],
                'ê°€ì„ ì›œ ì†Œí”„íŠ¸': ['#C4A484', '#D2B48C', '#DEB887', '#8B7355', '#A67B5B'],
                // ì—¬ë¦„ ì¿¨
                'ì—¬ë¦„ ì¿¨ ë¸Œë¼ì´íŠ¸': ['#FF69B4', '#9370DB', '#00CED1', '#20B2AA', '#BA55D3'],
                'ì—¬ë¦„ ì¿¨ ë¼ì´íŠ¸': ['#E6E6FA', '#D8BFD8', '#B0E0E6', '#AFEEEE', '#FFB6C1'],
                // ê²¨ìš¸ ì¿¨
                'ê²¨ìš¸ ì¿¨ ë”¥': ['#000080', '#8B008B', '#006400', '#C71585', '#000000'],
                'ê²¨ìš¸ ì¿¨ ë®¤íŠ¸': ['#708090', '#778899', '#2F4F4F', '#696969', '#4682B4'],
                // ë‰´íŠ¸ëŸ´
                'ë‰´íŠ¸ëŸ´ ë¼ì´íŠ¸': ['#DDA0DD', '#FFB7C5', '#E6E6FA', '#FFDEAD', '#B0E0E6'],
                'ë‰´íŠ¸ëŸ´ ë”¥': ['#8B4513', '#4169E1', '#556B2F', '#800000', '#483D8B']
            };
            const colors = palettes[season] || [];
            return colors.map(c => `<div style="width: 36px; height: 36px; background: ${c}; border-radius: 8px; border: 2px solid rgba(255,255,255,0.3);"></div>`).join('');
        }

        function drawFullFaceMesh(ctx, landmarks) {
            const FACE_CONNECTIONS = [
                [10, 338], [338, 297], [297, 332], [332, 284], [284, 251], [251, 389], [389, 356], [356, 454], [454, 323], [323, 361], [361, 288], [288, 397], [397, 365], [365, 379], [379, 378], [378, 400], [400, 377], [377, 152], [152, 148], [148, 176], [176, 149], [149, 150], [150, 136], [136, 172], [172, 58], [58, 132], [132, 93], [93, 234], [234, 127], [127, 162], [162, 21], [21, 54], [54, 103], [103, 67], [67, 109], [109, 10],
                [33, 7], [7, 163], [163, 144], [144, 145], [145, 153], [153, 154], [154, 155], [155, 133], [133, 173], [173, 157], [157, 158], [158, 159], [159, 160], [160, 161], [161, 246], [246, 33],
                [362, 382], [382, 381], [381, 380], [380, 374], [374, 373], [373, 390], [390, 249], [249, 263], [263, 466], [466, 388], [388, 387], [387, 386], [386, 385], [385, 384], [384, 398], [398, 362]
            ];

            ctx.fillStyle = '#00FF88';
            landmarks.forEach((landmark, index) => {
                // ì¢Œìš° ë°˜ì „ (ê±°ìš¸ ëª¨ë“œ)
                const x = (1 - landmark.x) * canvasElement.width;
                const y = landmark.y * canvasElement.height;

                ctx.beginPath();
                ctx.arc(x, y, 1.5, 0, 2 * Math.PI);
                ctx.fill();
            });

            ctx.strokeStyle = '#00FF8860';
            ctx.lineWidth = 0.8;

            FACE_CONNECTIONS.forEach(connection => {
                const [startIdx, endIdx] = connection;

                if (landmarks[startIdx] && landmarks[endIdx]) {
                    const start = landmarks[startIdx];
                    const end = landmarks[endIdx];

                    // ì¢Œìš° ë°˜ì „ (ê±°ìš¸ ëª¨ë“œ)
                    const startX = (1 - start.x) * canvasElement.width;
                    const startY = start.y * canvasElement.height;
                    const endX = (1 - end.x) * canvasElement.width;
                    const endY = end.y * canvasElement.height;

                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                }
            });
        }

        function drawSkinTonePoints(ctx, landmarks) {
            const skinPoints = [
                { index: 10, name: 'ì´ë§ˆì¤‘ì•™', color: '#FF6B6B' },
                { index: 151, name: 'ì½”ë', color: '#4ECDC4' },
                { index: 116, name: 'ì¢Œì¸¡ë³¼', color: '#45B7D1' },
                { index: 345, name: 'ìš°ì¸¡ë³¼', color: '#96CEB4' },
                { index: 175, name: 'í„±ì¤‘ì•™', color: '#FECA57' }
            ];

            skinPoints.forEach((point) => {
                if (landmarks[point.index]) {
                    const landmark = landmarks[point.index];
                    // ì¢Œìš° ë°˜ì „ (ê±°ìš¸ ëª¨ë“œ)
                    const x = (1 - landmark.x) * canvasElement.width;
                    const y = landmark.y * canvasElement.height;

                    ctx.strokeStyle = point.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, 2 * Math.PI);
                    ctx.stroke();

                    ctx.fillStyle = point.color + '40';
                    ctx.fill();

                    ctx.fillStyle = point.color;
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });
        }

        function extractSkinTone(landmarks) {
            // ê³µìœ  Canvas ì´ˆê¸°í™” (í•œ ë²ˆë§Œ)
            if (!sharedExtractCanvas) {
                sharedExtractCanvas = document.createElement('canvas');
                sharedExtractCtx = sharedExtractCanvas.getContext('2d', { willReadFrequently: true });
                console.log('ê³µìœ  Canvas ìƒì„±ë¨');
            }

            // Canvas í¬ê¸° ì„¤ì •
            sharedExtractCanvas.width = videoElement.videoWidth;
            sharedExtractCanvas.height = videoElement.videoHeight;

            sharedExtractCtx.drawImage(videoElement, 0, 0);

            // âœ… ê°œì„ ëœ í”¼ë¶€ìƒ‰ ì¶”ì¶œ í¬ì¸íŠ¸ (ê·¸ë¦¼ì/í•˜ì´ë¼ì´íŠ¸ ì˜í–¥ ì ì€ ë¶€ìœ„)
            // ì´ë§ˆ ì¤‘ì•™(10), ì–‘ìª½ ë³¼ ì¤‘ì•™(116, 345), ì½” ì˜†(203, 423), í„± ì–‘ìª½(136, 365)
            const skinPoints = [
                { index: 10, weight: 1.5 },   // ì´ë§ˆ ì¤‘ì•™ (ì¤‘ìš”)
                { index: 116, weight: 2.0 },  // ì™¼ìª½ ë³¼ ì¤‘ì•™ (ê°€ì¥ ì¤‘ìš” - í”¼ë¶€ìƒ‰ ëŒ€í‘œ)
                { index: 345, weight: 2.0 },  // ì˜¤ë¥¸ìª½ ë³¼ ì¤‘ì•™ (ê°€ì¥ ì¤‘ìš”)
                { index: 203, weight: 1.0 },  // ì™¼ìª½ ì½” ì˜†
                { index: 423, weight: 1.0 },  // ì˜¤ë¥¸ìª½ ì½” ì˜†
                { index: 136, weight: 1.0 },  // ì™¼ìª½ í„±
                { index: 365, weight: 1.0 },  // ì˜¤ë¥¸ìª½ í„±
                { index: 168, weight: 1.5 }   // ì½” ì¤‘ê°„ (ë°ì€ ë¶€ë¶„)
            ];

            let totalR = 0, totalG = 0, totalB = 0;
            let totalWeight = 0;
            const samples = [];

            skinPoints.forEach(point => {
                const landmark = landmarks[point.index];
                if (!landmark) return;

                const x = Math.floor(landmark.x * sharedExtractCanvas.width);
                const y = Math.floor(landmark.y * sharedExtractCanvas.height);

                // 5x5 ì˜ì—­ ìƒ˜í”Œë§
                let pointR = 0, pointG = 0, pointB = 0;
                let pointSamples = 0;

                for (let dx = -2; dx <= 2; dx++) {
                    for (let dy = -2; dy <= 2; dy++) {
                        const pixelX = Math.max(0, Math.min(sharedExtractCanvas.width - 1, x + dx));
                        const pixelY = Math.max(0, Math.min(sharedExtractCanvas.height - 1, y + dy));

                        const imageData = sharedExtractCtx.getImageData(pixelX, pixelY, 1, 1);
                        const [r, g, b] = imageData.data;

                        // ë„ˆë¬´ ì–´ë‘¡ê±°ë‚˜ ë°ì€ í”½ì…€ ì œì™¸ (ê·¸ë¦¼ì/í•˜ì´ë¼ì´íŠ¸)
                        const brightness = (r + g + b) / 3;
                        if (brightness > 40 && brightness < 240) {
                            pointR += r;
                            pointG += g;
                            pointB += b;
                            pointSamples++;
                        }
                    }
                }

                if (pointSamples > 0) {
                    const avgR = pointR / pointSamples;
                    const avgG = pointG / pointSamples;
                    const avgB = pointB / pointSamples;

                    totalR += avgR * point.weight;
                    totalG += avgG * point.weight;
                    totalB += avgB * point.weight;
                    totalWeight += point.weight;

                    samples.push({ r: avgR, g: avgG, b: avgB });
                }
            });

            if (totalWeight === 0) return null;

            const avgR = Math.round(totalR / totalWeight);
            const avgG = Math.round(totalG / totalWeight);
            const avgB = Math.round(totalB / totalWeight);

            // âœ… ê°œì„ ëœ ë¶„ì„
            const labColor = rgbToLab(avgR, avgG, avgB);
            const undertoneAnalysis = analyzeUndertoneAdvanced(avgR, avgG, avgB, labColor);

            return {
                rgb: { r: avgR, g: avgG, b: avgB },
                hex: `#${avgR.toString(16).padStart(2, '0')}${avgG.toString(16).padStart(2, '0')}${avgB.toString(16).padStart(2, '0')}`,
                undertone: undertoneAnalysis.undertone,
                undertoneScore: undertoneAnalysis.score,
                lab: labColor,
                brightness: labColor.L,
                chroma: undertoneAnalysis.chroma,
                samples: samples.length
            };
        }

        // RGBë¥¼ LAB ìƒ‰ê³µê°„ìœ¼ë¡œ ë³€í™˜ (ë” ì •í™•í•œ ìƒ‰ìƒ ë¶„ì„ìš©)
        function rgbToLab(r, g, b) {
            // RGB to XYZ
            let rr = r / 255, gg = g / 255, bb = b / 255;

            rr = rr > 0.04045 ? Math.pow((rr + 0.055) / 1.055, 2.4) : rr / 12.92;
            gg = gg > 0.04045 ? Math.pow((gg + 0.055) / 1.055, 2.4) : gg / 12.92;
            bb = bb > 0.04045 ? Math.pow((bb + 0.055) / 1.055, 2.4) : bb / 12.92;

            const x = (rr * 0.4124 + gg * 0.3576 + bb * 0.1805) / 0.95047;
            const y = (rr * 0.2126 + gg * 0.7152 + bb * 0.0722) / 1.00000;
            const z = (rr * 0.0193 + gg * 0.1192 + bb * 0.9505) / 1.08883;

            // XYZ to LAB
            const fx = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + 16/116;
            const fy = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + 16/116;
            const fz = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + 16/116;

            const L = (116 * fy) - 16;        // ëª…ë„ (0-100)
            const a = 500 * (fx - fy);        // ë¹¨ê°•-ì´ˆë¡ ì¶• (+a = ë¹¨ê°•, -a = ì´ˆë¡)
            const b_lab = 200 * (fy - fz);    // ë…¸ë‘-íŒŒë‘ ì¶• (+b = ë…¸ë‘, -b = íŒŒë‘)

            return { L, a, b: b_lab };
        }

        // âœ… ê°œì„ ëœ ì–¸ë”í†¤ ë¶„ì„ (LAB ìƒ‰ê³µê°„ í™œìš©)
        function analyzeUndertoneAdvanced(r, g, b, lab) {
            // ë°©ë²• 1: LAB ìƒ‰ê³µê°„ì—ì„œ a*, b* ê°’ ë¶„ì„
            // a* > 0: ë¹¨ê°„ê¸° (ì¿¨í†¤ ê²½í–¥)
            // b* > 0: ë…¸ë€ê¸° (ì›œí†¤ ê²½í–¥)
            const labWarmScore = lab.b - (lab.a * 0.5);  // ë…¸ë€ê¸°ê°€ ê°•í•˜ê³  ë¹¨ê°„ê¸°ê°€ ì•½í•˜ë©´ ì›œ

            // ë°©ë²• 2: RGB ë¹„ìœ¨ ë¶„ì„
            const total = r + g + b;
            const rRatio = r / total;
            const gRatio = g / total;
            const bRatio = b / total;

            // ì›œí†¤: Rê³¼ Gê°€ ë†’ê³ , íŠ¹íˆ G-B ì°¨ì´ê°€ í¼ (ë…¸ë€ê¸°)
            // ì¿¨í†¤: Rê³¼ Bê°€ ë†’ê³ , Gê°€ ìƒëŒ€ì ìœ¼ë¡œ ë‚®ìŒ (í•‘í¬/ë¸”ë£¨ ê¸°ìš´)
            const yellowIndex = (r * 0.5 + g) - b * 1.2;  // ë…¸ë€ê¸° ì§€ìˆ˜
            const pinkIndex = (r + b * 0.8) - g * 1.1;    // í•‘í¬ê¸° ì§€ìˆ˜

            // ë°©ë²• 3: í”¼ë¶€ìƒ‰ íŠ¹ì„± ë¶„ì„
            // ì›œí†¤ í”¼ë¶€: í™©ê¸ˆë¹›, ë³µìˆ­ì•„ë¹›, ì˜¬ë¦¬ë¸Œë¹›
            // ì¿¨í†¤ í”¼ë¶€: í•‘í¬ë¹›, ë¶‰ì€ë¹›, íŒŒë€ë¹›
            const goldenRatio = (r - b) / (r + b + 1);    // ê³¨ë“  ë¹„ìœ¨ (ì›œí†¤ ì§€í‘œ)
            const rosyRatio = (r - g) / (r + g + 1);       // ë¡œì§€ ë¹„ìœ¨ (ì¿¨í†¤ ì§€í‘œ)

            // ì¢…í•© ì ìˆ˜ ê³„ì‚°
            let warmScore = 0;
            let coolScore = 0;

            // LAB ê¸°ë°˜ ì ìˆ˜
            if (labWarmScore > 10) warmScore += 3;
            else if (labWarmScore > 5) warmScore += 2;
            else if (labWarmScore > 0) warmScore += 1;
            else if (labWarmScore < -5) coolScore += 2;
            else if (labWarmScore < 0) coolScore += 1;

            // RGB ë¹„ìœ¨ ê¸°ë°˜ ì ìˆ˜
            if (yellowIndex > pinkIndex + 30) warmScore += 3;
            else if (yellowIndex > pinkIndex + 15) warmScore += 2;
            else if (yellowIndex > pinkIndex) warmScore += 1;
            else if (pinkIndex > yellowIndex + 30) coolScore += 3;
            else if (pinkIndex > yellowIndex + 15) coolScore += 2;
            else if (pinkIndex > yellowIndex) coolScore += 1;

            // ê³¨ë“ /ë¡œì§€ ë¹„ìœ¨ ì ìˆ˜
            if (goldenRatio > 0.15) warmScore += 2;
            else if (goldenRatio > 0.08) warmScore += 1;
            if (rosyRatio > 0.08 && goldenRatio < 0.1) coolScore += 2;
            else if (rosyRatio > 0.04) coolScore += 1;

            // ì±„ë„ ê³„ì‚°
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const chroma = max - min;

            // ìµœì¢… íŒì • (ë” ì—„ê²©í•œ ê¸°ì¤€ - ë‰´íŠ¸ëŸ´ ë²”ìœ„ ì¶•ì†Œ)
            const scoreDiff = warmScore - coolScore;
            let undertone, score;

            // ê¸°ì¡´: >=3 ì›œ, <=-3 ì¿¨, ë‚˜ë¨¸ì§€ ë‰´íŠ¸ëŸ´ (ë„ˆë¬´ ë„“ìŒ)
            // ê°œì„ : >=2 ì›œ, <=-2 ì¿¨, -1~1ë§Œ ë‰´íŠ¸ëŸ´ (ì¢ì€ ë²”ìœ„)
            if (scoreDiff >= 2) {
                undertone = 'Warm';
                score = scoreDiff;
            } else if (scoreDiff <= -2) {
                undertone = 'Cool';
                score = Math.abs(scoreDiff);
            } else {
                // ì •ë§ ì• ë§¤í•œ ê²½ìš°ë§Œ ë‰´íŠ¸ëŸ´
                undertone = 'Neutral';
                score = Math.abs(scoreDiff);
            }

            console.log('ğŸ”¬ ì–¸ë”í†¤ ë¶„ì„:', {
                labWarmScore: labWarmScore.toFixed(2),
                yellowIndex: yellowIndex.toFixed(2),
                pinkIndex: pinkIndex.toFixed(2),
                goldenRatio: goldenRatio.toFixed(3),
                rosyRatio: rosyRatio.toFixed(3),
                warmScore, coolScore,
                result: undertone
            });

            return { undertone, score, chroma };
        }

        // âœ… ê°œì„ ëœ í¼ìŠ¤ë„ì»¬ëŸ¬ ì‹œì¦Œ ê²°ì • (ì—„ê²©í•œ ê¸°ì¤€)
        function getPersonalColorSeason(undertone, brightness, chroma) {
            // brightness: LABì˜ Lê°’ (0-100) ë˜ëŠ” RGB í‰ê·  (0-255)
            // chroma: ì±„ë„ (0-255)

            // brightnessê°€ 255 ìŠ¤ì¼€ì¼ì´ë©´ 100 ìŠ¤ì¼€ì¼ë¡œ ë³€í™˜
            const L = brightness > 100 ? (brightness / 255) * 100 : brightness;
            const C = chroma || 50; // ê¸°ë³¸ê°’

            // ì‹œì¦Œ ê²°ì • ê¸°ì¤€ (ì—„ê²©í•˜ê²Œ ì¡°ì •):
            // ë´„ ì›œ: ì •ë§ ë°ê³ (L>=70) + ì›œí†¤
            // ê°€ì„ ì›œ: ì¤‘ê°„~ì–´ë‘ìš´(L<70) + ì›œí†¤
            // ì—¬ë¦„ ì¿¨: ë°ê³ (L>=65) + ì¿¨í†¤
            // ê²¨ìš¸ ì¿¨: ì¤‘ê°„~ì–´ë‘ìš´(L<65) + ì¿¨í†¤

            console.log(`ğŸ¨ ì‹œì¦Œ ê²°ì •: L=${L.toFixed(1)}, C=${C}, undertone=${undertone}`);

            if (undertone === 'Warm') {
                if (L >= 70) {
                    // ì •ë§ ë°ì€ ì›œí†¤ = ë´„
                    if (C > 50) {
                        return { season: 'ë´„ ì›œ ë¸Œë¼ì´íŠ¸', emoji: 'ğŸŒ¸', color: '#FF6B6B', subtype: 'bright' };
                    } else {
                        return { season: 'ë´„ ì›œ ë¼ì´íŠ¸', emoji: 'ğŸŒ·', color: '#FFB7C5', subtype: 'light' };
                    }
                } else if (L >= 60) {
                    // ì¤‘ê°„ ë°ê¸° ì›œí†¤ = ê°€ì„ ì†Œí”„íŠ¸/ë®¤íŠ¸
                    if (C > 50) {
                        return { season: 'ê°€ì„ ì›œ ì†Œí”„íŠ¸', emoji: 'ğŸ‚', color: '#CD853F', subtype: 'soft' };
                    } else {
                        return { season: 'ê°€ì„ ì›œ ë®¤íŠ¸', emoji: 'ğŸ', color: '#D2691E', subtype: 'muted' };
                    }
                } else {
                    // ì–´ë‘ìš´ ì›œí†¤ = ê°€ì„ ë”¥
                    if (C > 50) {
                        return { season: 'ê°€ì„ ì›œ ë”¥', emoji: 'ğŸ‚', color: '#8B4513', subtype: 'deep' };
                    } else {
                        return { season: 'ê°€ì„ ì›œ ë®¤íŠ¸', emoji: 'ğŸ', color: '#A0522D', subtype: 'muted' };
                    }
                }
            } else if (undertone === 'Cool') {
                if (L >= 65) {
                    // ë°ì€ ì¿¨í†¤ = ì—¬ë¦„
                    if (C > 45) {
                        return { season: 'ì—¬ë¦„ ì¿¨ ë¸Œë¼ì´íŠ¸', emoji: 'ğŸŒŠ', color: '#4169E1', subtype: 'bright' };
                    } else {
                        return { season: 'ì—¬ë¦„ ì¿¨ ë¼ì´íŠ¸', emoji: 'ğŸ’œ', color: '#87CEEB', subtype: 'light' };
                    }
                } else if (L >= 50) {
                    // ì¤‘ê°„ ë°ê¸° ì¿¨í†¤ = ì—¬ë¦„ ë®¤íŠ¸
                    return { season: 'ì—¬ë¦„ ì¿¨ ë®¤íŠ¸', emoji: 'ğŸŒ™', color: '#9370DB', subtype: 'muted' };
                } else {
                    // ì–´ë‘ìš´ ì¿¨í†¤ = ê²¨ìš¸
                    if (C > 45) {
                        return { season: 'ê²¨ìš¸ ì¿¨ ë”¥', emoji: 'â„ï¸', color: '#191970', subtype: 'deep' };
                    } else {
                        return { season: 'ê²¨ìš¸ ì¿¨ ë®¤íŠ¸', emoji: 'ğŸŒ™', color: '#4169E1', subtype: 'muted' };
                    }
                }
            } else {
                // Neutral - ë°ê¸°ë¡œ êµ¬ë¶„
                if (L >= 65) {
                    return { season: 'ë‰´íŠ¸ëŸ´ ë¼ì´íŠ¸', emoji: 'ğŸŒ·', color: '#DDA0DD', subtype: 'light' };
                } else {
                    return { season: 'ë‰´íŠ¸ëŸ´ ì†Œí”„íŠ¸', emoji: 'ğŸ', color: '#BC8F8F', subtype: 'soft' };
                }
            }
        }

        // ì‹œì¦Œë³„ ì¶”ì²œ ì •ë³´ (ê°œì„ ëœ 8íƒ€ì… ì‹œìŠ¤í…œ)
        function getSeasonRecommendations(season) {
            const recs = {
                // ë´„ ì›œ íƒ€ì…
                'ë´„ ì›œ ë¸Œë¼ì´íŠ¸': 'ğŸ’„ ì¶”ì²œ ì»¬ëŸ¬: ë¹„ë¹„ë“œ ì½”ë„, ì˜¤ë Œì§€ë ˆë“œ, ì„ ëª…í•œ í”¼ì¹˜<br>ğŸ’ ì¶”ì²œ ë©”íƒˆ: ì˜ë¡œìš° ê³¨ë“œ, ë¸Œë¼ì´íŠ¸ ê³¨ë“œ',
                'ë´„ ì›œ ë¼ì´íŠ¸': 'ğŸ’„ ì¶”ì²œ ì»¬ëŸ¬: ì‚´êµ¬ìƒ‰, ë¼ì´íŠ¸ ì½”ë„, ì•„ì´ë³´ë¦¬, í¬ë¦¼<br>ğŸ’ ì¶”ì²œ ë©”íƒˆ: ë¡œì¦ˆê³¨ë“œ, ìƒ´í˜ì¸ ê³¨ë“œ',
                // ê°€ì„ ì›œ íƒ€ì…
                'ê°€ì„ ì›œ ë”¥': 'ğŸ’„ ì¶”ì²œ ì»¬ëŸ¬: ë²„ê±´ë””, ì´ˆì½œë¦¿ë¸Œë¼ìš´, ë”¥ í…Œë¼ì½”íƒ€<br>ğŸ’ ì¶”ì²œ ë©”íƒˆ: ì•¤í‹± ê³¨ë“œ, ë¸Œë¡ ì¦ˆ',
                'ê°€ì„ ì›œ ë®¤íŠ¸': 'ğŸ’„ ì¶”ì²œ ì»¬ëŸ¬: ë¨¸ìŠ¤íƒ€ë“œ, ì˜¬ë¦¬ë¸Œ, ì¹´í‚¤, í…Œë¼ì½”íƒ€<br>ğŸ’ ì¶”ì²œ ë©”íƒˆ: ê³¨ë“œ, ë¸Œë¼ìŠ¤',
                'ê°€ì„ ì›œ ì†Œí”„íŠ¸': 'ğŸ’„ ì¶”ì²œ ì»¬ëŸ¬: ì¹´ë©œ, ë² ì´ì§€ë¸Œë¼ìš´, ì½”ì½”ì•„, ì›œë² ì´ì§€<br>ğŸ’ ì¶”ì²œ ë©”íƒˆ: ë¡œì¦ˆê³¨ë“œ, ìƒ´í˜ì¸ê³¨ë“œ',
                // ì—¬ë¦„ ì¿¨ íƒ€ì…
                'ì—¬ë¦„ ì¿¨ ë¸Œë¼ì´íŠ¸': 'ğŸ’„ ì¶”ì²œ ì»¬ëŸ¬: ë¡œì¦ˆí•‘í¬, ë¼ë²¤ë”, ìŠ¤ì¹´ì´ë¸”ë£¨<br>ğŸ’ ì¶”ì²œ ë©”íƒˆ: í™”ì´íŠ¸ê³¨ë“œ, ë¡œì¦ˆê³¨ë“œ',
                'ì—¬ë¦„ ì¿¨ ë¼ì´íŠ¸': 'ğŸ’„ ì¶”ì²œ ì»¬ëŸ¬: ì†Œí”„íŠ¸ í•‘í¬, ë¼ì¼ë½, íŒŒìš°ë”ë¸”ë£¨<br>ğŸ’ ì¶”ì²œ ë©”íƒˆ: ì‹¤ë²„, í™”ì´íŠ¸ê³¨ë“œ',
                // ê²¨ìš¸ ì¿¨ íƒ€ì…
                'ê²¨ìš¸ ì¿¨ ë”¥': 'ğŸ’„ ì¶”ì²œ ì»¬ëŸ¬: ì™€ì¸, ë¡œì–„ë¸”ë£¨, ì—ë©”ë„ë“œ, ë¸”ë™<br>ğŸ’ ì¶”ì²œ ë©”íƒˆ: í”Œë˜í‹°ë„˜, í™”ì´íŠ¸ê³¨ë“œ',
                'ê²¨ìš¸ ì¿¨ ë®¤íŠ¸': 'ğŸ’„ ì¶”ì²œ ì»¬ëŸ¬: ì°¨ì½œ, ë„¤ì´ë¹„, ë²„ê±´ë””, ë‹¤í¬ê·¸ë ˆì´<br>ğŸ’ ì¶”ì²œ ë©”íƒˆ: ì‹¤ë²„, ê±´ë©”íƒˆ',
                // ë‰´íŠ¸ëŸ´ íƒ€ì…
                'ë‰´íŠ¸ëŸ´ ë¼ì´íŠ¸': 'ğŸ’„ ì¶”ì²œ ì»¬ëŸ¬: ë”ìŠ¤í‹° í•‘í¬, ì†Œí”„íŠ¸ ë² ì´ì§€, ë¼ì´íŠ¸ ëª¨ë¸Œ<br>ğŸ’ ì¶”ì²œ ë©”íƒˆ: ë¡œì¦ˆê³¨ë“œ, ì†Œí”„íŠ¸ ì‹¤ë²„',
                'ë‰´íŠ¸ëŸ´ ë”¥': 'ğŸ’„ ì¶”ì²œ ì»¬ëŸ¬: í† í”„, ë¨¸ë¸Œ, ë‹¤í¬ë¸Œë¼ìš´, ì˜¬ë¦¬ë¸Œ<br>ğŸ’ ì¶”ì²œ ë©”íƒˆ: í˜¼í•© ë©”íƒˆ, ì•¤í‹± ì‹¤ë²„'
            };
            return recs[season] || 'ë¶„ì„ ì¤‘...';
        }

        function clearSkinToneDisplay() {
            const panel = document.getElementById('realtime-skin-analysis');
            if (panel) panel.remove();
        }

        function stopAICamera() {
            console.log('AI ì¹´ë©”ë¼ ì¤‘ì§€ ìš”ì²­');
            cleanupCameraResources();
            showToast('AI ì¹´ë©”ë¼ê°€ ì •ì§€ë˜ì—ˆìŠµë‹ˆë‹¤', 'info');
        }

        function cleanupCameraResources() {
            console.log('ì¹´ë©”ë¼ ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì‹œì‘...');

            try {
                // MediaPipe ì¹´ë©”ë¼ë§Œ ì¤‘ì§€ (Face Mesh ì¸ìŠ¤í„´ìŠ¤ëŠ” ì¬ì‚¬ìš©)
                if (mediaPipeCamera) {
                    try {
                        mediaPipeCamera.stop();
                    } catch (e) {
                        console.warn('MediaPipe Camera stop ì‹¤íŒ¨:', e);
                    }
                    mediaPipeCamera = null;
                }

                // âš ï¸ faceDetectionInstanceëŠ” closeí•˜ì§€ ì•ŠìŒ - WASM ì¬ì‚¬ìš© ë¬¸ì œ
                // í˜ì´ì§€ë¥¼ ë– ë‚  ë•Œë§Œ ì •ë¦¬ë¨

                if (activeVideoStream) {
                    activeVideoStream.getTracks().forEach(track => {
                        track.stop();
                    });
                    activeVideoStream = null;
                }

                if (videoElement) {
                    videoElement.srcObject = null;
                    videoElement.pause();
                }

                if (canvasCtx && canvasElement) {
                    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                }

                faceDetected = false;

                const faceGuide = document.getElementById('ai-face-guide');
                if (faceGuide) faceGuide.style.display = 'flex';

                const analysisPanel = document.getElementById('realtime-skin-analysis');
                if (analysisPanel) analysisPanel.remove();

                // ê³µìœ  CanvasëŠ” ìœ ì§€ (ì¬ì‚¬ìš© ê°€ëŠ¥)
                // sharedExtractCanvas, sharedExtractCtx ìœ ì§€

                console.log('ì¹´ë©”ë¼ ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì™„ë£Œ (Face Mesh ì¸ìŠ¤í„´ìŠ¤ ìœ ì§€)');

            } catch (error) {
                console.error('ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì¤‘ ì˜¤ë¥˜:', error);
            }
        }
        async function analyzeAI() {
            if (analysisInProgress) return;

            if (!videoElement || videoElement.readyState !== 4) {
                showToast('ë¨¼ì € ì¹´ë©”ë¼ë¥¼ ì‹œì‘í•´ì£¼ì„¸ìš”', 'warning');
                return;
            }

            analysisInProgress = true;
            showToast('AI ë¶„ì„ì„ ì‹œì‘í•©ë‹ˆë‹¤...', 'info');

            await performAIAnalysisSteps();

            analysisInProgress = false;
        }

        async function performAIAnalysisSteps() {
            const steps = [
                { id: 'ai-step-1', message: 'ì–¼êµ´ ì˜ì—­ ê°ì§€ ì¤‘...' },
                { id: 'ai-step-2', message: 'í”¼ë¶€í†¤ ìƒ‰ìƒ ë¶„ì„ ì¤‘...' },
                { id: 'ai-step-3', message: 'Delta E 2000 ê³„ì‚° ì¤‘...' },
                { id: 'ai-step-4', message: 'ìµœì¢… ê²°ê³¼ ìƒì„± ì¤‘...' }
            ];

            for (let i = 0; i < steps.length; i++) {
                const step = steps[i];

                document.getElementById(step.id).classList.add('active');
                await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 1000));
                document.getElementById(step.id).classList.remove('active');
                document.getElementById(step.id).classList.add('completed');
            }

            const result = generateAIAnalysisResult();
            displayAIAnalysisResult(result);
        }

        function generateAIAnalysisResult() {
            const seasons = ['ë´„ ì›œí†¤', 'ì—¬ë¦„ ì¿¨í†¤', 'ê°€ì„ ì›œí†¤', 'ê²¨ìš¸ ì¿¨í†¤'];
            const selectedSeason = seasons[Math.floor(Math.random() * seasons.length)];
            const confidence = 80 + Math.floor(Math.random() * 15);

            const skinColor = {
                r: 150 + Math.floor(Math.random() * 50),
                g: 120 + Math.floor(Math.random() * 40),
                b: 100 + Math.floor(Math.random() * 30)
            };

            return {
                season: selectedSeason,
                confidence: confidence,
                skinColor: skinColor,
                expertAnalysis: generateExpertAnalysis(selectedSeason)
            };
        }

        function displayAIAnalysisResult(result) {
            document.getElementById('ai-season-result').textContent = result.season;
            document.getElementById('ai-confidence').textContent = `ì‹ ë¢°ë„: ${result.confidence}%`;

            const analysisData = document.getElementById('ai-analysis-data');
            analysisData.innerHTML = `
                <div class="color-data">
                    <h5>ì¶”ì¶œëœ í”¼ë¶€ìƒ‰</h5>
                    <div class="skin-color-sample" style="background: rgb(${result.skinColor.r}, ${result.skinColor.g}, ${result.skinColor.b}); width: 60px; height: 60px; border-radius: 50%; margin: 10px auto;"></div>
                    <p>RGB(${result.skinColor.r}, ${result.skinColor.g}, ${result.skinColor.b})</p>
                </div>
                <div class="expert-analysis">
                    <h5>ì „ë¬¸ê°€ ë¶„ì„</h5>
                    <p>${result.expertAnalysis}</p>
                </div>
            `;

            document.getElementById('ai-analysis-results').style.display = 'block';

            displayFinalResults(result);

            showToast(`AI ë¶„ì„ ì™„ë£Œ: ${result.season}`, 'success');
        }

        // ë“œë˜ì´í•‘ ëª¨ë“œ í•¨ìˆ˜ë“¤
        async function startDrapingCamera() {
            try {
                showToast('ë“œë˜ì´í•‘ ì¹´ë©”ë¼ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤...', 'info');

                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: 640, height: 480 }
                });

                const drapingVideo = document.getElementById('draping-camera');
                drapingVideo.srcObject = stream;

                document.getElementById('draping-face-guide').style.display = 'flex';

                showToast('ë“œë˜ì´í•‘ ì¹´ë©”ë¼ê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤', 'success');

            } catch (error) {
                console.error('ë“œë˜ì´í•‘ ì¹´ë©”ë¼ ì‹œì‘ ì‹¤íŒ¨:', error);
                showToast('ì¹´ë©”ë¼ì— ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤', 'error');
            }
        }

        function stopDrapingCamera() {
            const drapingVideo = document.getElementById('draping-camera');
            if (drapingVideo && drapingVideo.srcObject) {
                const tracks = drapingVideo.srcObject.getTracks();
                tracks.forEach(track => track.stop());
                drapingVideo.srcObject = null;
            }

            showToast('ë“œë˜ì´í•‘ ì¹´ë©”ë¼ê°€ ì •ì§€ë˜ì—ˆìŠµë‹ˆë‹¤', 'info');
        }

        function selectSeason(season) {
            currentSeason = season;

            document.querySelectorAll('.season-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelector(`[data-season="${season}"]`).classList.add('active');

            updateColorGrid(season);

            showToast(`${season} ê³„ì ˆ ìƒ‰ìƒì„ ì„ íƒí–ˆìŠµë‹ˆë‹¤`, 'info');
        }

        function updateColorGrid(season) {
            const colorGrid = document.getElementById('color-grid');

            const seasonColors = hairColorData.filter(item =>
                item.season && item.season.toLowerCase() === season.toLowerCase()
            );

            colorGrid.innerHTML = '';

            if (seasonColors.length === 0) {
                const defaultColors = SeasonPalettes[season].colors;
                defaultColors.forEach(color => {
                    const colorItem = document.createElement('div');
                    colorItem.className = 'color-item';
                    colorItem.style.background = color;
                    colorItem.onclick = () => selectColor(color);
                    colorGrid.appendChild(colorItem);
                });
                return;
            }

            const representativeColors = seasonColors
                .sort((a, b) => (b.confidence || 0.8) - (a.confidence || 0.8))
                .slice(0, 12)
                .map(item => ({
                    hex: item.hex,
                    name: item.name,
                    brand: item.brand,
                    code: item.code
                }));

            representativeColors.forEach(colorData => {
                const colorItem = document.createElement('div');
                colorItem.className = 'color-item';
                colorItem.style.background = colorData.hex;
                colorItem.title = `${colorData.brand} ${colorData.code} - ${colorData.name}`;
                colorItem.onclick = () => selectColor(colorData.hex, colorData);
                colorGrid.appendChild(colorItem);
            });
        }

        function selectColor(color, colorData = null) {
            selectedColor = color;

            document.querySelectorAll('.color-item').forEach(item => {
                item.style.border = '3px solid transparent';
            });
            event.target.style.border = '3px solid #E91E63';

            applyDrapingColor(color);

            let toastMessage = `ìƒ‰ìƒ ${color}ë¥¼ ì„ íƒí–ˆìŠµë‹ˆë‹¤`;

            if (colorData) {
                toastMessage = `${colorData.brand} ${colorData.code} - ${colorData.name} ì„ íƒë¨`;
            }

            showToast(toastMessage, 'info');
        }

        function applyDrapingColor(color) {
            const overlay = document.getElementById('draping-overlay');
            const ctx = overlay.getContext('2d');

            if (overlay.width === 0) {
                overlay.width = 640;
                overlay.height = 480;
            }

            ctx.clearRect(0, 0, overlay.width, overlay.height);

            ctx.fillStyle = color;
            ctx.globalAlpha = 0.8;
            ctx.fillRect(0, 0, overlay.width, overlay.height / 4);
            ctx.globalAlpha = 1.0;
        }

        function adjustColor() {
            if (!selectedColor) return;

            const lightness = parseInt(document.getElementById('lightness-slider').value);
            const saturation = parseInt(document.getElementById('saturation-slider').value);
            const warmth = parseInt(document.getElementById('warmth-slider').value);

            document.getElementById('lightness-value').textContent = lightness;
            document.getElementById('saturation-value').textContent = saturation;
            document.getElementById('warmth-value').textContent = warmth;

            const adjustedColor = adjustColorValues(selectedColor, lightness, saturation, warmth);
            applyDrapingColor(adjustedColor);
        }

        function adjustColorValues(hexColor, lightness, saturation, warmth) {
            const r = parseInt(hexColor.substr(1, 2), 16);
            const g = parseInt(hexColor.substr(3, 2), 16);
            const b = parseInt(hexColor.substr(5, 2), 16);

            let newR = Math.max(0, Math.min(255, r + lightness + warmth));
            let newG = Math.max(0, Math.min(255, g + lightness));
            let newB = Math.max(0, Math.min(255, b + lightness - warmth));

            const gray = (newR + newG + newB) / 3;
            const saturationFactor = 1 + (saturation / 100);
            newR = Math.max(0, Math.min(255, gray + (newR - gray) * saturationFactor));
            newG = Math.max(0, Math.min(255, gray + (newG - gray) * saturationFactor));
            newB = Math.max(0, Math.min(255, gray + (newB - gray) * saturationFactor));

            return `#${Math.round(newR).toString(16).padStart(2, '0')}${Math.round(newG).toString(16).padStart(2, '0')}${Math.round(newB).toString(16).padStart(2, '0')}`;
        }

        // function togglePreview() {
        //     showToast('ë¯¸ë¦¬ë³´ê¸°ê°€ í† ê¸€ë˜ì—ˆìŠµë‹ˆë‹¤', 'info');
        // }

        function saveCurrentColor() {
            if (!selectedColor) {
                showToast('ë¨¼ì € ìƒ‰ìƒì„ ì„ íƒí•´ì£¼ì„¸ìš”', 'warning');
                return;
            }

            const colorData = {
                color: selectedColor,
                season: currentSeason,
                timestamp: new Date().toISOString()
            };

            savedColors.push(colorData);

            showToast('í˜„ì¬ ìƒ‰ìƒì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤', 'success');
        }

        // ê³µí†µ ê²°ê³¼ í‘œì‹œ
        function displayFinalResults(result) {
            const resultsSection = document.getElementById('results-section');
            const finalResults = document.getElementById('final-results');

            let colors = [];
            let season = 'ë¶„ì„ ì¤‘';
            let confidence = 0;

            if (result && typeof result === 'object') {
                season = result.season || 'ë¶„ì„ ì¤‘';
                confidence = result.confidence || 0;

                if (season && season !== 'ë¶„ì„ ì¤‘') {
                    const seasonKey = season.toLowerCase()
                        .replace(' ì›œí†¤', '')
                        .replace(' ì¿¨í†¤', '')
                        .replace('ë´„', 'spring')
                        .replace('ì—¬ë¦„', 'summer')
                        .replace('ê°€ì„', 'autumn')
                        .replace('ê²¨ìš¸', 'winter');

                    colors = SeasonPalettes[seasonKey]?.colors || ['#8B4513', '#A0522D', '#CD853F'];
                } else {
                    colors = ['#8B4513', '#A0522D', '#CD853F'];
                }
            } else {
                colors = ['#8B4513', '#A0522D', '#CD853F'];
            }

            finalResults.innerHTML = `
                <div class="result-header">
                    <h3>${season}</h3>
                    <div class="confidence">ì‹ ë¢°ë„: ${confidence}%</div>
                </div>
                <div class="result-colors">
                    ${colors.slice(0, 8).map(color =>
                `<div class="result-color" style="background: ${color}; width: 50px; height: 50px; border-radius: 50%; display: inline-block; margin: 5px;" title="${color}"></div>`
            ).join('')}
                </div>
                <div class="result-description">
                    <p>${season}ì— ì–´ìš¸ë¦¬ëŠ” ${colors.length}ê°€ì§€ ìƒ‰ìƒì„ í‘œì‹œí•©ë‹ˆë‹¤.</p>
                </div>
            `;

            if (season && season !== 'ë¶„ì„ ì¤‘') {
                displayProductRecommendations(season);
            }

            resultsSection.style.display = 'block';
            resultsSection.scrollIntoView({ behavior: 'smooth' });
        }

        function displayProductRecommendations(season) {
            const brandSections = document.getElementById('brand-sections');

            if (!brandSections) {
                console.warn('brand-sections ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                return;
            }

            const defaultRecommendations = {
                'ë´„ ì›œí†¤': [
                    { brand: 'ë¡œë ˆì•Œ', products: ['ê³¨ë“  ë² ì´ì§€', 'í—ˆë‹ˆ ë¸”ë¡ ë“œ', 'ì¹´ë¼ë©œ ë¸Œë¼ìš´'] },
                    { brand: 'ì›°ë¼', products: ['ë¼ì´íŠ¸ ê³¨ë“ ', 'ì›œ ë² ì´ì§€', 'ì†Œí”„íŠ¸ ë¸Œë¼ìš´'] },
                    { brand: 'Shiseido', products: ['ê³¨ë“  ë² ì´ì§€', 'ì¹´ë¼ë©œ ë¸Œë¼ìš´', 'í—ˆë‹ˆ ê³¨ë“œ'] }
                ],
                'ì—¬ë¦„ ì¿¨í†¤': [
                    { brand: 'ë¡œë ˆì•Œ', products: ['ì• ì‰¬ ë¸”ë¡ ë“œ', 'ì¿¨ ë² ì´ì§€', 'í”Œë˜í‹°ë„˜'] },
                    { brand: 'ì›°ë¼', products: ['ì‹¤ë²„ ì• ì‰¬', 'ì¿¨ ë¸Œë¼ìš´', 'ì•„ì´ì‹œ ë¸”ë¡ ë“œ'] },
                    { brand: 'Shiseido', products: ['ì• ì‰¬ ë¸Œë¼ìš´', 'ì¿¨ ë¸Œë¼ìš´', 'ë°”ì´ì˜¬ë › ì• ì‰¬'] }
                ],
                'ê°€ì„ ì›œí†¤': [
                    { brand: 'ë¡œë ˆì•Œ', products: ['ë¦¬ì¹˜ ë¸Œë¼ìš´', 'ë‹¤í¬ ì´ˆì½œë¦¿', 'ë§ˆí˜¸ê°€ë‹ˆ'] },
                    { brand: 'ì›°ë¼', products: ['ë”¥ ë¸Œë¼ìš´', 'ì²´ìŠ¤íŠ¸ë„›', 'ë‹¤í¬ ì¹´ë¼ë©œ'] },
                    { brand: 'Shiseido', products: ['ë‚´ì¸„ëŸ´ ë¸Œë¼ìš´', 'ë² ì´ì§€ ë¸Œë¼ìš´', 'ë§¤íŠ¸ ë¸Œë¼ìš´'] }
                ],
                'ê²¨ìš¸ ì¿¨í†¤': [
                    { brand: 'ë¡œë ˆì•Œ', products: ['ì œíŠ¸ ë¸”ë™', 'ë¸”ë£¨ ë¸”ë™', 'ë‹¤í¬ ì• ì‰¬'] },
                    { brand: 'ì›°ë¼', products: ['ë¯¸ë“œë‚˜ì‡ ë¸”ë™', 'ì¿¨ ë‹¤í¬', 'í”Œë˜í‹°ë„˜ ì‹¤ë²„'] },
                    { brand: 'Shiseido', products: ['ë”¥ ë¸”ë™', 'ì†Œí”„íŠ¸ ë¸”ë™', 'ë‹¤í¬ ë¸Œë¼ìš´'] }
                ]
            };

            const recommendations = defaultRecommendations[season] || defaultRecommendations['ë´„ ì›œí†¤'];

            brandSections.innerHTML = recommendations.map(brand => `
                <div class="brand-section" style="margin-bottom: 1.5rem; padding: 1rem; background: #f9f9f9; border-radius: 8px;">
                    <h5 style="color: #E91E63; margin-bottom: 0.5rem;">${brand.brand}</h5>
                    <div class="product-list">
                        ${brand.products.map(product => `
                            <div style="padding: 0.5rem; margin: 0.2rem 0; background: white; border-radius: 4px; border-left: 3px solid #E91E63;">
                                ${product}
                            </div>
                        `).join('')}
                    </div>
                </div>
            `).join('');
        }

        // ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
        function generateExpertAnalysis(season) {
            const analyses = {
                'ë´„ ì›œí†¤': ExpertKnowledge.colorMatching.warm + " ë°ê³  ì„ ëª…í•œ ìƒ‰ìƒì´ ì˜ ì–´ìš¸ë¦½ë‹ˆë‹¤.",
                'ì—¬ë¦„ ì¿¨í†¤': ExpertKnowledge.skinAnalysis.principle + " ë¶€ë“œëŸ¬ìš´ íŒŒìŠ¤í…” í†¤ì„ ì¶”ì²œí•©ë‹ˆë‹¤.",
                'ê°€ì„ ì›œí†¤': "ê¹Šê³  ë”°ëœ»í•œ ìƒ‰ìƒì´ ì í•©í•©ë‹ˆë‹¤. ë¦¬ì¹˜í•œ ë¸Œë¼ìš´ ê³„ì—´ì„ ê¶Œì¥í•©ë‹ˆë‹¤.",
                'ê²¨ìš¸ ì¿¨í†¤': ExpertKnowledge.colorMatching.cool + " ì§„í•˜ê³  ì„ ëª…í•œ ìƒ‰ìƒì´ ì í•©í•©ë‹ˆë‹¤."
            };

            return analyses[season] || 'ì „ë¬¸ê°€ ë¶„ì„ ê²°ê³¼ë¥¼ ìƒì„± ì¤‘ì…ë‹ˆë‹¤.';
        }

        function showToast(message, type = 'info', duration = 3000) {
            const existingToast = document.querySelector('.toast');
            if (existingToast) {
                existingToast.remove();
            }

            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            toast.style.cssText = `
                position: fixed; top: 20px; right: 20px; z-index: 10000;
                background: white; padding: 1rem 1.5rem; border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15); border-left: 4px solid;
                border-left-color: ${type === 'success' ? '#4CAF50' : type === 'error' ? '#F44336' : type === 'warning' ? '#FF9800' : '#2196F3'};
                transform: translateX(100%); transition: transform 0.3s ease;
            `;

            document.body.appendChild(toast);

            setTimeout(() => toast.style.transform = 'translateX(0)', 100);
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.style.transform = 'translateX(100%)';
                    setTimeout(() => toast.remove(), 300);
                }
            }, duration);
        }

        // í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤
        document.addEventListener('keydown', function (event) {
            if (event.code === 'Space' && currentMode === 'ai' && !analysisInProgress) {
                event.preventDefault();
                analyzeAI();
            }

            if (event.key === 'Escape') {
                goHome();
            }
        });

        // í˜ì´ì§€ ì–¸ë¡œë“œ ì‹œ ì •ë¦¬
        window.addEventListener('beforeunload', function () {
            cleanupCameraResources();
            stopDrapingCamera();
        });

        // ========== ë‹¤êµ­ì–´ ì‹œìŠ¤í…œ ==========

        // ë©”ì¸ì—ì„œ ì €ì¥ëœ ì–¸ì–´ ì„¤ì • ê°€ì ¸ì˜¤ê¸° (localStorage)
        let currentLang = localStorage.getItem('hairgator_language') || 'ko';

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ë©”ì¸ì—ì„œ ì„¤ì •í•œ ì–¸ì–´ ì ìš©
        function initLanguage() {
            const savedLang = localStorage.getItem('hairgator_language') || 'ko';
            currentLang = savedLang;
            applyTranslations();
            console.log(`ğŸŒ ë©”ì¸ì—ì„œ ì„¤ì •ëœ ì–¸ì–´ ì ìš©: ${savedLang}`);
        }

        // ë²ˆì—­ ì ìš© í•¨ìˆ˜
        function applyTranslations() {
            const pc = HAIRGATOR_I18N[currentLang]?.personalColor;
            if (!pc) return;

            // data-i18n ì†ì„±ìœ¼ë¡œ ë²ˆì—­ ì ìš©
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                const text = getNestedValue(HAIRGATOR_I18N[currentLang], key);
                if (text) el.textContent = text;
            });

            // data-i18n-html ì†ì„±ìœ¼ë¡œ HTML ë²ˆì—­ ì ìš©
            document.querySelectorAll('[data-i18n-html]').forEach(el => {
                const key = el.getAttribute('data-i18n-html');
                const text = getNestedValue(HAIRGATOR_I18N[currentLang], key);
                if (text) el.innerHTML = text;
            });

            // í—¤ë”
            updateText('.app-title', pc.title);
            updateText('.app-subtitle', pc.subtitle);

            // ë¡œë”© í…ìŠ¤íŠ¸
            updateText('#loading-text', pc.loading);

            // AI ë¶„ì„ ëª¨ë“œ
            updateText('#ai-analysis .section-title', pc.aiMode.title);
            updateText('#ai-analysis .nav-btn', pc.aiMode.backHome);
            updateText('#start-camera', pc.aiMode.startCamera);
            updateText('#capture-btn', pc.aiMode.capture);
            updateText('#retry-btn', pc.aiMode.retry);

            // ë¶„ì„ ë‹¨ê³„
            const steps = pc.aiMode.steps;
            updateText('.analysis-panel > h3', steps.title);
            updateStepText('ai-step-1', steps.step1, steps.step1Desc);
            updateStepText('ai-step-2', steps.step2, steps.step2Desc);
            updateStepText('ai-step-3', steps.step3, steps.step3Desc);
            updateStepText('ai-step-4', steps.step4, steps.step4Desc);

            // ë“œë˜ì´í•‘ ëª¨ë“œ
            updateText('#draping-mode .section-title', pc.drapingMode.title);
            updateText('.season-tabs [data-season="spring"]', pc.drapingMode.spring);
            updateText('.season-tabs [data-season="summer"]', pc.drapingMode.summer);
            updateText('.season-tabs [data-season="autumn"]', pc.drapingMode.autumn);
            updateText('.season-tabs [data-season="winter"]', pc.drapingMode.winter);

            // ì–¼êµ´ ê°€ì´ë“œ í…ìŠ¤íŠ¸
            const faceGuide = document.getElementById('ai-face-guide');
            if (faceGuide) {
                faceGuide.innerHTML = pc.aiMode.faceGuide;
            }

            const drapingGuide = document.getElementById('draping-face-guide');
            if (drapingGuide) {
                drapingGuide.innerHTML = pc.drapingMode.faceGuide;
            }

            // ìº¡ì²˜ ê°€ì´ë“œ
            const captureGuide = document.getElementById('capture-guide');
            if (captureGuide) {
                captureGuide.innerHTML = `<span style="color: #FFB400; font-size: 14px;">${pc.aiMode.captureGuide}</span>`;
            }
        }

        // ì¤‘ì²© ê°ì²´ ê°’ ê°€ì ¸ì˜¤ê¸°
        function getNestedValue(obj, path) {
            return path.split('.').reduce((current, key) => current?.[key], obj);
        }

        // í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸ í—¬í¼
        function updateText(selector, text) {
            const el = document.querySelector(selector);
            if (el && text) el.textContent = text;
        }

        // ë‹¨ê³„ë³„ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
        function updateStepText(stepId, title, desc) {
            const step = document.getElementById(stepId);
            if (step) {
                const h4 = step.querySelector('h4');
                const p = step.querySelector('p');
                if (h4 && title) h4.textContent = title;
                if (p && desc) p.textContent = desc;
            }
        }

        // ì‹œì¦Œ ì´ë¦„ì„ í‚¤ë¡œ ë³€í™˜
        function seasonToKey(season) {
            const mapping = {
                'ë´„ ì›œ ë¸Œë¼ì´íŠ¸': 'springWarmBright',
                'ë´„ ì›œ ë¼ì´íŠ¸': 'springWarmLight',
                'ê°€ì„ ì›œ ë”¥': 'autumnWarmDeep',
                'ê°€ì„ ì›œ ë®¤íŠ¸': 'autumnWarmMuted',
                'ì—¬ë¦„ ì¿¨ ë¸Œë¼ì´íŠ¸': 'summerCoolBright',
                'ì—¬ë¦„ ì¿¨ ë¼ì´íŠ¸': 'summerCoolLight',
                'ê²¨ìš¸ ì¿¨ ë”¥': 'winterCoolDeep',
                'ê²¨ìš¸ ì¿¨ ë®¤íŠ¸': 'winterCoolMuted',
                'ë‰´íŠ¸ëŸ´ ë¼ì´íŠ¸': 'neutralLight',
                'ë‰´íŠ¸ëŸ´ ë”¥': 'neutralDeep'
            };
            return mapping[season] || season;
        }

        // ì–¸ë”í†¤ ë²ˆì—­ ê°€ì ¸ì˜¤ê¸°
        function getUndertoneText(undertone) {
            const pc = HAIRGATOR_I18N[currentLang]?.personalColor;
            if (!pc) return undertone;

            if (undertone === 'Warm') return pc.undertones.warm;
            if (undertone === 'Cool') return pc.undertones.cool;
            return pc.undertones.neutral;
        }

        // ì‹œì¦Œ ì´ë¦„ ë²ˆì—­ ê°€ì ¸ì˜¤ê¸°
        function getSeasonText(season) {
            const pc = HAIRGATOR_I18N[currentLang]?.personalColor;
            if (!pc) return season;

            const key = seasonToKey(season);
            return pc.seasons[key] || season;
        }

        // ì‹œì¦Œ ì„¤ëª… ë²ˆì—­ ê°€ì ¸ì˜¤ê¸°
        function getSeasonDescriptionText(season) {
            const pc = HAIRGATOR_I18N[currentLang]?.personalColor;
            if (!pc) return '';

            const key = seasonToKey(season);
            return pc.seasonDescriptions[key] || '';
        }

        // ì‹œì¦Œ ì¶”ì²œ ë²ˆì—­ ê°€ì ¸ì˜¤ê¸°
        function getSeasonRecommendationText(season) {
            const pc = HAIRGATOR_I18N[currentLang]?.personalColor;
            if (!pc) return '';

            const key = seasonToKey(season);
            return pc.seasonRecommendations[key]?.replace(/\n/g, '<br>') || '';
        }

        // ê²°ê³¼ í…ìŠ¤íŠ¸ ê°€ì ¸ì˜¤ê¸°
        function getResultTexts() {
            const pc = HAIRGATOR_I18N[currentLang]?.personalColor;
            if (!pc) return {
                title: 'ğŸ¨ í¼ìŠ¤ë„ì»¬ëŸ¬ ë¶„ì„ ê²°ê³¼',
                skinAnalysis: 'ğŸ“ ë‹¹ì‹ ì˜ í”¼ë¶€ ë¶„ì„',
                skinTone: 'í”¼ë¶€í†¤',
                undertone: 'ì–¸ë”í†¤',
                recommendedSeason: 'âœ¨ ì¶”ì²œ í¼ìŠ¤ë„ì»¬ëŸ¬',
                matchingColors: 'ğŸ’„ ì–´ìš¸ë¦¬ëŠ” ì»¬ëŸ¬',
                confidence: 'ì‹ ë¢°ë„'
            };
            return pc.aiMode.result;
        }

        // ì´ˆê¸°í™” ì‹œ ë©”ì¸ì—ì„œ ì €ì¥ëœ ì–¸ì–´ ë¶ˆëŸ¬ì˜¤ê¸°
        document.addEventListener('DOMContentLoaded', function() {
            // localStorageì—ì„œ ë©”ì¸ì—ì„œ ì„¤ì •í•œ ì–¸ì–´ ê°€ì ¸ì˜¤ê¸°
            initLanguage();
        });

        console.log('HAIRGATOR Personal Color - ë‹¤êµ­ì–´ ì§€ì› ë²„ì „ ë¡œë“œ ì™„ë£Œ');
    </script>
</body>

</html>
