<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HAIRGATOR Personal Color</title>

    <!-- MediaPipe CDN -->
    <script crossorigin="anonymous" src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script crossorigin="anonymous"
        src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script crossorigin="anonymous"
        src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script crossorigin="anonymous"
        src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/face_mesh.js"></script>

    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <!-- ë¡œë”© í™”ë©´ -->
    <div class="loading-screen" id="loading-screen">
        <div class="loading-content">
            <div class="loading-logo">ğŸ¨</div>
            <h2>HAIRGATOR Personal Color</h2>
            <p id="loading-text">ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì¤‘...</p>
            <div class="loading-progress">
                <div class="loading-bar" id="loading-bar"></div>
            </div>
        </div>
    </div>

    <!-- ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ -->
    <div class="main-app" id="main-app">
        <header class="app-header">
            <div class="header-content">
                <div class="app-title-section">
                    <h1 class="app-title">HAIRGATOR Personal Color</h1>
                    <div class="app-subtitle">AI ê¸°ë°˜ í¼ìŠ¤ë„ì»¬ëŸ¬ ì§„ë‹¨ ì‹œìŠ¤í…œ</div>
                </div>
                <button class="close-btn" onclick="closePersonalColor()" title="ë‹«ê¸°">
                    Ã—
                </button>
            </div>
        </header>

        <main class="main-content">
            <!-- ëª¨ë“œ ì„ íƒ ì„¹ì…˜ -->
            <section class="section active" id="mode-selection">
                <h2 class="mode-title">í¼ìŠ¤ë„ì»¬ëŸ¬ ì§„ë‹¨ ë°©ë²•ì„ ì„ íƒí•˜ì„¸ìš”</h2>

                <div class="mode-cards">
                    <div class="mode-card" onclick="selectMode('ai')">
                        <span class="mode-icon">ğŸ¤–</span>
                        <h3 class="mode-card-title">AI í¼ìŠ¤ë„ì»¬ëŸ¬ ë¶„ì„</h3>
                        <p class="mode-description">
                            ìµœì‹  AI ê¸°ìˆ ë¡œ ì–¼êµ´ì„ ë¶„ì„í•˜ì—¬ ì •í™•í•œ í¼ìŠ¤ë„ì»¬ëŸ¬ë¥¼ ì§„ë‹¨í•©ë‹ˆë‹¤.
                            MediaPipe ì–¼êµ´ ì¸ì‹ê³¼ Delta E 2000 ìƒ‰ì°¨ ì¸¡ì •ì„ í™œìš©í•©ë‹ˆë‹¤.
                        </p>
                        <ul class="mode-features">
                            <li>ì‹¤ì‹œê°„ ì–¼êµ´ ì¸ì‹ ë° í”¼ë¶€í†¤ ì¶”ì¶œ</li>
                            <li>LAB ìƒ‰ê³µê°„ ê¸°ë°˜ ì •ë°€ ë¶„ì„</li>
                            <li>ì „ë¬¸ê°€ ë…¸í•˜ìš° ë°ì´í„°ë² ì´ìŠ¤ í™œìš©</li>
                            <li>624ê°œ í—¤ì–´ì»¬ëŸ¬ì™€ ìë™ ë§¤ì¹­</li>
                        </ul>
                        <button class="mode-btn">AI ë¶„ì„ ì‹œì‘</button>
                    </div>

                    <div class="mode-card" onclick="selectMode('draping')">
                        <span class="mode-icon">ğŸ­</span>
                        <h3 class="mode-card-title">ì „ë¬¸ê°€ ë“œë˜ì´í•‘ ëª¨ë“œ</h3>
                        <p class="mode-description">
                            ì „ë¬¸ê°€ ë…¸í•˜ìš°ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì‹¤ì‹œê°„ ë“œë˜ì´í•‘ì„ í†µí•´
                            ê°€ì¥ ì–´ìš¸ë¦¬ëŠ” í—¤ì–´ì»¬ëŸ¬ë¥¼ ì§ì ‘ í™•ì¸í•´ë³´ì„¸ìš”.
                        </p>
                        <ul class="mode-features">
                            <li>ì‹¤ì‹œê°„ ì¹´ë©”ë¼ ë“œë˜ì´í•‘</li>
                            <li>4ê³„ì ˆ ìƒ‰ìƒ íŒ”ë ˆíŠ¸ ì œê³µ</li>
                            <li>Before/After ì¦‰ì‹œ ë¹„êµ</li>
                            <li>ë¸Œëœë“œë³„ ì œí’ˆ ì¶”ì²œ</li>
                        </ul>
                        <button class="mode-btn">ë“œë˜ì´í•‘ ì‹œì‘</button>
                    </div>
                </div>
            </section>

            <!-- AI ë¶„ì„ ëª¨ë“œ -->
            <section class="section" id="ai-analysis">
                <div class="section-nav">
                    <button class="nav-btn" onclick="goHome()">â† í™ˆìœ¼ë¡œ</button>
                    <h2 class="section-title">AI í¼ìŠ¤ë„ì»¬ëŸ¬ ë¶„ì„</h2>
                </div>

                <div class="analysis-grid">
                    <!-- ì¹´ë©”ë¼ ì˜ì—­ -->
                    <div class="camera-container">
                        <div class="video-container">
                            <video id="camera-feed" autoplay muted playsinline style="display:none;"></video>
                            <canvas id="camera-canvas" style="width: 100%; max-width: 640px; border-radius: 8px;"></canvas>
                            <div class="face-guide" id="ai-face-guide">
                                ì–¼êµ´ì„ í™”ë©´ ì¤‘ì•™ì—<br>ìœ„ì¹˜ì‹œì¼œì£¼ì„¸ìš”
                            </div>
                        </div>
                        <div class="camera-controls">
                            <button class="control-btn" id="start-camera" onclick="startAICamera()">ğŸ“¹ ì‹¤ì‹œê°„ ì¹´ë©”ë¼ ë¶„ì„</button>
                        </div>

                        <!-- â­ ì‹¤ì‹œê°„ ë¶„ì„ ê²°ê³¼ í‘œì‹œ -->
                        <div class="realtime-results" style="margin-top: 20px; padding: 20px; background: rgba(255,255,255,0.05); border-radius: 8px; display: none;" id="realtime-results-container">
                            <h4 style="margin: 0 0 15px 0; color: #fff;">ğŸ¨ ì‹¤ì‹œê°„ ë¶„ì„ ê²°ê³¼</h4>
                            <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 6px; margin-bottom: 10px;">
                                <div style="font-size: 24px; font-weight: bold; margin-bottom: 8px;" id="realtime-season">ë¶„ì„ ì¤‘...</div>
                                <div style="font-size: 14px; line-height: 1.6; color: #ccc;" id="realtime-skin-info"></div>
                            </div>
                            <div style="font-size: 14px; line-height: 1.8; color: #eee;" id="realtime-recommendation"></div>
                        </div>
                    </div>

                    <!-- ë¶„ì„ íŒ¨ë„ -->
                    <div class="analysis-panel">
                        <h3>AI ë¶„ì„ ì§„í–‰ìƒí™©</h3>
                        <div class="analysis-steps">
                            <div class="analysis-step" id="ai-step-1">
                                <div class="step-number">1</div>
                                <div class="step-content">
                                    <h4>ì–¼êµ´ ì¸ì‹</h4>
                                    <p>MediaPipeë¡œ ì–¼êµ´ ì˜ì—­ì„ ê°ì§€í•©ë‹ˆë‹¤</p>
                                </div>
                            </div>

                            <div class="analysis-step" id="ai-step-2">
                                <div class="step-number">2</div>
                                <div class="step-content">
                                    <h4>í”¼ë¶€í†¤ ë¶„ì„</h4>
                                    <p>RGB â†’ LAB ìƒ‰ê³µê°„ ë³€í™˜ ë° ìƒ‰ìƒ ì¶”ì¶œ</p>
                                </div>
                            </div>

                            <div class="analysis-step" id="ai-step-3">
                                <div class="step-number">3</div>
                                <div class="step-content">
                                    <h4>Delta E ê³„ì‚°</h4>
                                    <p>ìƒ‰ì°¨ ì¸¡ì • ë° ì •í™•ë„ ì‚°ì¶œ</p>
                                </div>
                            </div>

                            <div class="analysis-step" id="ai-step-4">
                                <div class="step-number">4</div>
                                <div class="step-content">
                                    <h4>ê²°ê³¼ ìƒì„±</h4>
                                    <p>ì „ë¬¸ê°€ ë…¸í•˜ìš° ê¸°ë°˜ ìµœì¢… ì§„ë‹¨</p>
                                </div>
                            </div>
                        </div>

                        <div class="analysis-results" id="ai-analysis-results" style="display: none;">
                            <h4>ë¶„ì„ ê²°ê³¼</h4>
                            <div class="result-summary">
                                <div class="season-result" id="ai-season-result">ë¶„ì„ ì¤‘...</div>
                                <div class="confidence-score" id="ai-confidence">-</div>
                            </div>
                            <div class="color-analysis-data" id="ai-analysis-data">
                                <!-- ìƒì„¸ ë°ì´í„°ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤ -->
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- ë“œë˜ì´í•‘ ëª¨ë“œ -->
            <section class="section" id="draping-mode">
                <div class="section-nav">
                    <button class="nav-btn" onclick="goHome()">â† í™ˆìœ¼ë¡œ</button>
                    <h2 class="section-title">ì „ë¬¸ê°€ ë“œë˜ì´í•‘ ëª¨ë“œ</h2>
                </div>

                <div class="draping-layout">
                    <!-- ë“œë˜ì´í•‘ ì¹´ë©”ë¼ -->
                    <div class="draping-camera-section">
                        <div class="video-container">
                            <video id="draping-camera" autoplay muted playsinline></video>
                            <canvas id="draping-overlay"></canvas>
                            <div class="face-guide" id="draping-face-guide">
                                ì–¼êµ´ì„ ê°€ì´ë“œë¼ì¸ì—<br>ë§ì¶°ì£¼ì„¸ìš”
                            </div>
                        </div>

                        <div class="camera-controls">
                            <button class="control-btn" onclick="startDrapingCamera()">ì¹´ë©”ë¼ ì‹œì‘</button>
                            <button class="control-btn" onclick="saveCurrentColor()">í˜„ì¬ ìƒ‰ìƒ ì €ì¥</button>
                        </div>
                    </div>

                    <!-- ìƒ‰ìƒ íŒ”ë ˆíŠ¸ -->
                    <div class="color-palette-section">
                        <h3>4ê³„ì ˆ ìƒ‰ìƒ íŒ”ë ˆíŠ¸</h3>

                        <!-- ê³„ì ˆ íƒ­ -->
                        <div class="season-tabs">
                            <button class="season-tab active" data-season="spring"
                                onclick="selectSeason('spring')">ë´„</button>
                            <button class="season-tab" data-season="summer" onclick="selectSeason('summer')">ì—¬ë¦„</button>
                            <button class="season-tab" data-season="autumn" onclick="selectSeason('autumn')">ê°€ì„</button>
                            <button class="season-tab" data-season="winter" onclick="selectSeason('winter')">ê²¨ìš¸</button>
                        </div>

                        <!-- ìƒ‰ìƒ ê·¸ë¦¬ë“œ -->
                        <div class="color-grid" id="color-grid">
                            <!-- ë™ì ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤ -->
                        </div>

                        <!-- ì„¸ë¶€ ì¡°ì • -->
                        <div class="color-adjustments">
                            <h4>ìƒ‰ìƒ ì„¸ë¶€ ì¡°ì •</h4>

                            <div class="adjustment-slider">
                                <label>ëª…ë„</label>
                                <input type="range" id="lightness-slider" min="-30" max="30" value="0"
                                    oninput="adjustColor()">
                                <span id="lightness-value">0</span>
                            </div>

                            <div class="adjustment-slider">
                                <label>ì±„ë„</label>
                                <input type="range" id="saturation-slider" min="-50" max="50" value="0"
                                    oninput="adjustColor()">
                                <span id="saturation-value">0</span>
                            </div>

                            <div class="adjustment-slider">
                                <label>ì˜¨ë„ê°</label>
                                <input type="range" id="warmth-slider" min="-40" max="40" value="0"
                                    oninput="adjustColor()">
                                <span id="warmth-value">0</span>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- ê³µí†µ ê²°ê³¼ ì„¹ì…˜ -->
            <div class="results-section" id="results-section" style="display: none;">
                <h3>í¼ìŠ¤ë„ì»¬ëŸ¬ ì§„ë‹¨ ê²°ê³¼</h3>
                <div class="final-results" id="final-results">
                    <!-- ê²°ê³¼ ë‚´ìš©ì´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤ -->
                </div>

                <div class="product-recommendations" id="product-recommendations">
                    <h4>ì¶”ì²œ í—¤ì–´ì»¬ëŸ¬ ì œí’ˆ</h4>
                    <div class="brand-sections" id="brand-sections">
                        <!-- ë¸Œëœë“œë³„ ì œí’ˆ ì¶”ì²œì´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤ -->
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // ì „ì—­ ë³€ìˆ˜ ì •ì˜
        let currentMode = null;
        let analysisInProgress = false;
        let faceDetected = false;
        let hairColorData = [];
        let videoElement = null;
        let canvasElement = null;
        let canvasCtx = null;
        let currentSeason = 'spring';
        let selectedColor = null;
        let savedColors = [];
        let activeVideoStream = null;
        let mediaPipeCamera = null;
        let faceDetectionInstance = null;
        let sharedExtractCanvas = null;    // ì—¬ê¸°ë¡œ ì´ë™
        let sharedExtractCtx = null;       // ì—¬ê¸°ë¡œ ì´ë™

        // ì „ë¬¸ê°€ ë…¸í•˜ìš° ë°ì´í„°
        const ExpertKnowledge = {
            colorTheory: {
                warmCool: "ì£¼í™©ìƒ‰ì€ ì›œí†¤ì˜ ëŒ€í‘œì ì¸ ìƒ‰ìƒì´ë©° ì¿¨í†¤ìœ¼ë¡œ ë³€í™˜ì´ ì–´ë µìŠµë‹ˆë‹¤",
                foundation: "íŒŒìš´ë°ì´ì…˜ 21-23í˜¸ëŒ€ëŠ” ë¹„ìŠ·í•œ ëª…ë„ì˜ í—¤ì–´ì»¬ëŸ¬ì™€ ë§¤ì¹˜í•  ë•Œ ì£¼ì˜ê°€ í•„ìš”í•©ë‹ˆë‹¤"
            },
            skinAnalysis: {
                redness: "í™ì¡° í”¼ë¶€ëŠ” ë¯¸ë“œë‚˜ì‡ ì»¬ëŸ¬ë¡œ ì¤‘í™”ì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤",
                principle: "ëª…ë„ì™€ ì±„ë„ì˜ ì¡°í•©ì´ ìƒ‰ìƒ ì´ë¦„ë³´ë‹¤ ì¤‘ìš”í•©ë‹ˆë‹¤"
            },
            colorMatching: {
                warm: "ì•„ì´ë³´ë¦¬ í”¼ë¶€ì—ëŠ” ì½”í† ë¦¬ë² ì´ì§€ë‚˜ ì˜¤ë Œì§€ë¸Œë¼ìš´ì´ ì˜ ì–´ìš¸ë¦½ë‹ˆë‹¤",
                cool: "í™”ì´íŠ¸ í”¼ë¶€ì—ëŠ” ë¸”ë£¨ë¸”ë™ì´ë‚˜ ì• ì‰¬ë¸”ë£¨ê°€ ì í•©í•©ë‹ˆë‹¤"
            }
        };

        // ê³„ì ˆë³„ ìƒ‰ìƒ íŒ”ë ˆíŠ¸
        const SeasonPalettes = {
            spring: {
                colors: ['#FFB6C1', '#FFA07A', '#F0E68C', '#98FB98', '#FFE4B5', '#DDA0DD'],
                characteristics: ['ë°ê³  ë”°ëœ»í•œ ìƒ‰ìƒ', 'ë†’ì€ ì±„ë„', 'ë…¸ë€ ì–¸ë”í†¤']
            },
            summer: {
                colors: ['#B0E0E6', '#DDA0DD', '#C8B2DB', '#AFEEEE', '#F0F8FF', '#E6E6FA'],
                characteristics: ['ë¶€ë“œëŸ½ê³  ì°¨ê°€ìš´ ìƒ‰ìƒ', 'ì¤‘ê°„ ì±„ë„', 'íŒŒë€ ì–¸ë”í†¤']
            },
            autumn: {
                colors: ['#D2691E', '#CD853F', '#A0522D', '#8B4513', '#B22222', '#800000'],
                characteristics: ['ê¹Šê³  ë”°ëœ»í•œ ìƒ‰ìƒ', 'ë‚®ì€ ì±„ë„', 'ë…¸ë€ ì–¸ë”í†¤']
            },
            winter: {
                colors: ['#000080', '#4B0082', '#8B008B', '#191970', '#2F4F4F', '#708090'],
                characteristics: ['ì§„í•˜ê³  ì°¨ê°€ìš´ ìƒ‰ìƒ', 'ë†’ì€ ëŒ€ë¹„', 'íŒŒë€ ì–¸ë”í†¤']
            }
        };

        // ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', function () {
            console.log('HAIRGATOR Personal Color ì‹œìŠ¤í…œ ì‹œì‘...');
            initializeSystem();
        });

        async function initializeSystem() {
            const timeoutId = setTimeout(() => {
                console.warn('ë¡œë”© íƒ€ì„ì•„ì›ƒ - ê°•ì œë¡œ ì•± í‘œì‹œ');
                document.getElementById('loading-screen').style.display = 'none';
                document.getElementById('main-app').classList.add('loaded');
                showToast('ì‹œìŠ¤í…œì´ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤', 'warning');
            }, 5000);

            try {
                console.log('ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹œì‘...');

                updateLoadingProgress(20, 'í—¤ì–´ì»¬ëŸ¬ ë°ì´í„° ë¡œë“œ ì¤‘...');
                await loadHairColorData();

                updateLoadingProgress(40, 'UI ì»´í¬ë„ŒíŠ¸ ì„¤ì • ì¤‘...');
                setupUI();

                updateLoadingProgress(60, 'AI ì–¼êµ´ ì¸ì‹ ì—”ì§„ ì¤€ë¹„ ì¤‘...');
                // Face Mesh ë¯¸ë¦¬ ì´ˆê¸°í™” (ì¹´ë©”ë¼ ì‹œì‘ ì‹œ ë¹ ë¥´ê²Œ ì‘ë™í•˜ë„ë¡)
                await preloadFaceMesh();

                updateLoadingProgress(100, 'ì‹œìŠ¤í…œ ì¤€ë¹„ ì™„ë£Œ!');
                await new Promise(resolve => setTimeout(resolve, 500));

                clearTimeout(timeoutId);

                document.getElementById('loading-screen').style.display = 'none';
                document.getElementById('main-app').classList.add('loaded');

                console.log('HAIRGATOR Personal Color ì¤€ë¹„ ì™„ë£Œ');
                showToast('í¼ìŠ¤ë„ì»¬ëŸ¬ ì‹œìŠ¤í…œì´ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤!', 'success');

            } catch (error) {
                clearTimeout(timeoutId);
                console.error('ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹¤íŒ¨:', error);

                document.getElementById('loading-screen').style.display = 'none';
                document.getElementById('main-app').classList.add('loaded');
                showToast('ì¼ë¶€ ê¸°ëŠ¥ì— ì œí•œì´ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.', 'warning');
            }
        }

        function updateLoadingProgress(percent, text) {
            const bar = document.getElementById('loading-bar');
            const textEl = document.getElementById('loading-text');
            if (bar) bar.style.width = percent + '%';
            if (textEl) textEl.textContent = text;
        }

        async function loadHairColorData() {
            try {
                if (parent && parent.HAIR_COLOR_614_DATA) {
                    hairColorData = parent.HAIR_COLOR_614_DATA;
                    console.log('ë¶€ëª¨ì°½ì—ì„œ 614ê°œ í—¤ì–´ì»¬ëŸ¬ ë°ì´í„° ë¡œë“œ ì™„ë£Œ');
                    checkShiseidoData();
                    return;
                }

                if (typeof HAIR_COLOR_614_DATA !== 'undefined') {
                    hairColorData = HAIR_COLOR_614_DATA;
                    console.log('ê¸€ë¡œë²Œ ë³€ìˆ˜ì—ì„œ 614ê°œ ë°ì´í„° ë¡œë“œ');
                    checkShiseidoData();
                    return;
                }

                if (parent && parent.hairColorDatabase) {
                    hairColorData = parent.hairColorDatabase;
                    console.log(`ë¶€ëª¨ì°½ ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ${hairColorData.length}ê°œ ë¡œë“œ`);
                    checkShiseidoData();
                    return;
                }

                await loadExternalHairColorData();
                checkShiseidoData();

            } catch (error) {
                console.error('í—¤ì–´ì»¬ëŸ¬ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:', error);
                hairColorData = generateDefaultHairColors();
                checkShiseidoData();
            }
        }

        async function loadExternalHairColorData() {
            try {
                const script = document.createElement('script');
                script.src = 'hair-color-data.js';
                script.onload = () => {
                    if (typeof HAIR_COLOR_614_DATA !== 'undefined') {
                        hairColorData = HAIR_COLOR_614_DATA;
                        console.log('ì™¸ë¶€ ìŠ¤í¬ë¦½íŠ¸ì—ì„œ 614ê°œ ë°ì´í„° ë¡œë“œ');
                    }
                };
                script.onerror = () => {
                    console.warn('ì™¸ë¶€ í—¤ì–´ì»¬ëŸ¬ ë°ì´í„° ìŠ¤í¬ë¦½íŠ¸ ë¡œë“œ ì‹¤íŒ¨');
                    hairColorData = generateDefaultHairColors();
                };

                document.head.appendChild(script);
                await new Promise(resolve => setTimeout(resolve, 3000));

                if (hairColorData.length === 0) {
                    hairColorData = generateDefaultHairColors();
                }

            } catch (error) {
                console.error('ì™¸ë¶€ ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜:', error);
                hairColorData = generateDefaultHairColors();
            }
        }

        function generateDefaultHairColors() {
            const brands = ['ë¡œë ˆì•Œ', 'ì›°ë¼', 'ë°€ë³¸'];
            const seasons = ['spring', 'summer', 'autumn', 'winter'];
            const data = [];

            brands.forEach(brand => {
                seasons.forEach(season => {
                    SeasonPalettes[season].colors.forEach((color, index) => {
                        data.push({
                            brand: brand,
                            name: `${season} Color ${index + 1}`,
                            hex: color,
                            season: season,
                            confidence: 0.8 + Math.random() * 0.2
                        });
                    });
                });
            });

            return data;
        }

        function checkShiseidoData() {
            const shiseidoCount = hairColorData.filter(item =>
                item.brand && (
                    item.brand.toLowerCase().includes('shiseido') ||
                    item.brand.toLowerCase().includes('ì‹œì„¸ì´ë„')
                )
            ).length;

            console.log(`í˜„ì¬ ì‹œì„¸ì´ë„ ë°ì´í„°: ${shiseidoCount}ê°œ`);

            if (shiseidoCount === 0) {
                console.warn('ì‹œì„¸ì´ë„ ë°ì´í„° ì—†ìŒ. ì¶”ê°€í•©ë‹ˆë‹¤...');
                addShiseidoData();
            } else {
                console.log('ì‹œì„¸ì´ë„ ë°ì´í„° í™•ì¸ë¨');
            }

            console.log(`ì´ ë°ì´í„°: ${hairColorData.length}ê°œ`);
        }

        function addShiseidoData() {
            const shiseidoData = [
                { brand: "Shiseido", line: "PRIMIENCE", code: "N5", name: "ë‚´ì¸„ëŸ´ ë¸Œë¼ìš´", hex: "#6B4E37", season: "autumn" },
                { brand: "Shiseido", line: "PRIMIENCE", code: "A6", name: "ì• ì‰¬ ë¸Œë¼ìš´", hex: "#8B7D6B", season: "summer" },
                { brand: "Shiseido", line: "PRIMIENCE", code: "G7", name: "ê³¨ë“  ë² ì´ì§€", hex: "#D2B48C", season: "spring" },
                { brand: "Shiseido", line: "ADENOVITAL", code: "AD01", name: "ë”¥ ë¸”ë™", hex: "#2F2F2F", season: "winter" },
                { brand: "Shiseido", line: "ADENOVITAL", code: "AD02", name: "ì†Œí”„íŠ¸ ë¸”ë™", hex: "#4A4A4A", season: "winter" },
                { brand: "Shiseido", line: "PRIMIENCE", code: "B8", name: "ë² ì´ì§€ ë¸Œë¼ìš´", hex: "#A0826D", season: "autumn" },
                { brand: "Shiseido", line: "PRIMIENCE", code: "M9", name: "ë§¤íŠ¸ ë¸Œë¼ìš´", hex: "#8B6F47", season: "autumn" },
                { brand: "Shiseido", line: "ADENOVITAL", code: "AD03", name: "ë‹¤í¬ ë¸Œë¼ìš´", hex: "#3D2F23", season: "winter" },
                { brand: "Shiseido", line: "ADENOVITAL", code: "AD04", name: "ì¿¨ ë¸Œë¼ìš´", hex: "#5D4E3A", season: "summer" },
                { brand: "Shiseido", line: "PRIMIENCE", code: "C10", name: "ì¹´ë¼ë©œ ë¸Œë¼ìš´", hex: "#B8860B", season: "spring" }
            ];

            hairColorData.push(...shiseidoData);
            console.log(`ì‹œì„¸ì´ë„ ${shiseidoData.length}ê°œ ë°ì´í„° ì¶”ê°€ ì™„ë£Œ`);
        }

        function setupUI() {
            selectSeason('spring');
            console.log('UI ì„¤ì • ì™„ë£Œ');
        }

        // Face Mesh ë¯¸ë¦¬ ë¡œë“œ (í˜ì´ì§€ ë¡œë“œ ì‹œ)
        async function preloadFaceMesh() {
            if (typeof FaceMesh === 'undefined') {
                console.log('FaceMesh ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì•„ì§ ë¡œë“œë˜ì§€ ì•ŠìŒ');
                return;
            }

            if (faceDetectionInstance) {
                console.log('Face Mesh ì´ë¯¸ ì´ˆê¸°í™”ë¨');
                return;
            }

            try {
                console.log('Face Mesh ë¯¸ë¦¬ ë¡œë“œ ì‹œì‘...');
                faceDetectionInstance = new FaceMesh({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/${file}`;
                    }
                });

                faceDetectionInstance.setOptions({
                    maxNumFaces: 1,
                    refineLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                faceDetectionInstance.onResults(onAdvancedFaceResults);

                // ì´ˆê¸°í™” ì™„ë£Œ ëŒ€ê¸° (WASM ë¡œë“œ)
                await faceDetectionInstance.initialize();

                console.log('âœ… Face Mesh ë¯¸ë¦¬ ë¡œë“œ ì™„ë£Œ');
            } catch (error) {
                console.warn('Face Mesh ë¯¸ë¦¬ ë¡œë“œ ì‹¤íŒ¨ (ì¹´ë©”ë¼ ì‹œì‘ ì‹œ ì¬ì‹œë„):', error);
                faceDetectionInstance = null;
            }
        }

        // ëª¨ë“œ ì„ íƒ ë° ì „í™˜
        function selectMode(mode) {
            console.log('ëª¨ë“œ ì„ íƒ:', mode);
            currentMode = mode;

            document.querySelectorAll('.section').forEach(section => {
                section.classList.remove('active');
            });

            if (mode === 'ai') {
                document.getElementById('ai-analysis').classList.add('active');
                showToast('AI í¼ìŠ¤ë„ì»¬ëŸ¬ ë¶„ì„ ëª¨ë“œê°€ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤', 'success');
            } else if (mode === 'draping') {
                document.getElementById('draping-mode').classList.add('active');
                showToast('ì „ë¬¸ê°€ ë“œë˜ì´í•‘ ëª¨ë“œê°€ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤', 'success');
            }
        }

        function goHome() {
            document.querySelectorAll('.section').forEach(section => {
                section.classList.remove('active');
            });
            document.getElementById('mode-selection').classList.add('active');

            stopAICamera();
            stopDrapingCamera();
            cleanupCameraResources();

            currentMode = null;
            showToast('í™ˆ í™”ë©´ìœ¼ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤', 'info');
        }

        // X ë²„íŠ¼ í´ë¦­ - í¼ìŠ¤ë„ì»¬ëŸ¬ í˜ì´ì§€ ë‹«ê¸°
        function closePersonalColor() {
            console.log('ğŸ¨ í¼ìŠ¤ë„ì»¬ëŸ¬ í˜ì´ì§€ ë‹«ê¸°');

            // ì¹´ë©”ë¼ ë¦¬ì†ŒìŠ¤ ì •ë¦¬
            stopAICamera();
            stopDrapingCamera();
            cleanupCameraResources();

            // ë¶€ëª¨ ì°½ì´ ìˆìœ¼ë©´ (iframeì¸ ê²½ìš°) ë¶€ëª¨ì—ê²Œ ë‹«ê¸° ìš”ì²­
            if (window.parent !== window) {
                try {
                    window.parent.postMessage({ type: 'CLOSE_PERSONAL_COLOR' }, '*');
                } catch (e) {
                    console.warn('ë¶€ëª¨ ì°½ í†µì‹  ì‹¤íŒ¨:', e);
                }
            }

            // ë©”ì¸ í˜ì´ì§€ë¡œ ì´ë™
            window.location.href = '/';
        }

        // AI ì¹´ë©”ë¼ í•¨ìˆ˜ë“¤
        async function startAICamera() {
            try {
                showToast('ì¹´ë©”ë¼ ê¶Œí•œì„ í™•ì¸í•©ë‹ˆë‹¤...', 'info');
                console.log('ğŸ¥ ì¹´ë©”ë¼ ì‹œì‘ ì‹œë„...');

                // 1. mediaDevices API ì§€ì› í™•ì¸
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('NOT_SUPPORTED: ì´ ë¸Œë¼ìš°ì €/ì•±ì—ì„œ ì¹´ë©”ë¼ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤');
                }

                // 2. ê¶Œí•œ ìƒíƒœ í™•ì¸ (ì§€ì›í•˜ëŠ” ê²½ìš°)
                if (navigator.permissions && navigator.permissions.query) {
                    try {
                        const permissionStatus = await navigator.permissions.query({ name: 'camera' });
                        console.log('ì¹´ë©”ë¼ ê¶Œí•œ ìƒíƒœ:', permissionStatus.state);

                        if (permissionStatus.state === 'denied') {
                            throw new Error('PERMISSION_DENIED: ì¹´ë©”ë¼ ê¶Œí•œì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤. ì•± ì„¤ì •ì—ì„œ ì¹´ë©”ë¼ ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”.');
                        }
                    } catch (permErr) {
                        console.log('ê¶Œí•œ ì¡°íšŒ ë¶ˆê°€ (ì •ìƒì¼ ìˆ˜ ìˆìŒ):', permErr.message);
                    }
                }

                cleanupCameraResources();

                // 3. ì¹´ë©”ë¼ ìŠ¤íŠ¸ë¦¼ ìš”ì²­ (ì—¬ëŸ¬ ì˜µì…˜ ì‹œë„)
                let stream = null;
                const videoConstraints = [
                    { facingMode: 'user', width: { ideal: 640 }, height: { ideal: 480 } },
                    { facingMode: 'user' },
                    { facingMode: { ideal: 'user' } },
                    true  // ê°€ì¥ ê¸°ë³¸ì ì¸ ì˜µì…˜
                ];

                for (const constraints of videoConstraints) {
                    try {
                        console.log('ì¹´ë©”ë¼ ì˜µì…˜ ì‹œë„:', JSON.stringify(constraints));
                        stream = await navigator.mediaDevices.getUserMedia({
                            video: constraints,
                            audio: false
                        });
                        console.log('âœ… ì¹´ë©”ë¼ ìŠ¤íŠ¸ë¦¼ íšë“ ì„±ê³µ');
                        break;
                    } catch (e) {
                        console.log('ì˜µì…˜ ì‹¤íŒ¨:', e.name, e.message);
                        continue;
                    }
                }

                if (!stream) {
                    throw new Error('STREAM_FAILED: ëª¨ë“  ì¹´ë©”ë¼ ì˜µì…˜ì´ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
                }

                activeVideoStream = stream;
                videoElement = document.getElementById('camera-feed');

                if (!videoElement) {
                    throw new Error('VIDEO_ELEMENT: ë¹„ë””ì˜¤ ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                }

                videoElement.srcObject = activeVideoStream;
                videoElement.setAttribute('playsinline', 'true');
                videoElement.setAttribute('autoplay', 'true');
                videoElement.muted = true;

                // ë¹„ë””ì˜¤ ì¬ìƒ ëŒ€ê¸°
                await new Promise((resolve, reject) => {
                    videoElement.onloadedmetadata = () => {
                        videoElement.play()
                            .then(resolve)
                            .catch(reject);
                    };
                    videoElement.onerror = reject;
                    setTimeout(() => reject(new Error('VIDEO_TIMEOUT')), 10000);
                });

                showToast('ì¹´ë©”ë¼ê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤!', 'success');

                canvasElement = document.getElementById('camera-canvas');
                canvasCtx = canvasElement.getContext('2d', { willReadFrequently: true });

                // MediaPipe Face Mesh ì´ˆê¸°í™” ë˜ëŠ” ì¬ì‚¬ìš©
                if (typeof FaceMesh !== 'undefined') {
                    try {
                        // Face Mesh ì¸ìŠ¤í„´ìŠ¤ê°€ ì—†ìœ¼ë©´ ìƒˆë¡œ ìƒì„±
                        if (!faceDetectionInstance) {
                            console.log('ìƒˆ Face Mesh ì¸ìŠ¤í„´ìŠ¤ ìƒì„±');
                            faceDetectionInstance = new FaceMesh({
                                locateFile: (file) => {
                                    return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/${file}`;
                                }
                            });

                            faceDetectionInstance.setOptions({
                                maxNumFaces: 1,
                                refineLandmarks: true,
                                minDetectionConfidence: 0.5,
                                minTrackingConfidence: 0.5
                            });

                            faceDetectionInstance.onResults(onAdvancedFaceResults);
                        } else {
                            console.log('ê¸°ì¡´ Face Mesh ì¸ìŠ¤í„´ìŠ¤ ì¬ì‚¬ìš©');
                            // ê¸°ì¡´ ì¸ìŠ¤í„´ìŠ¤ì—ë„ onResults ë‹¤ì‹œ ì„¤ì •
                            faceDetectionInstance.onResults(onAdvancedFaceResults);
                        }

                        // í”„ë ˆì„ ì¹´ìš´í„° ë¦¬ì…‹
                        frameCount = 0;

                        // MediaPipe CameraëŠ” í•­ìƒ ìƒˆë¡œ ìƒì„±
                        if (typeof Camera !== 'undefined') {
                            mediaPipeCamera = new Camera(videoElement, {
                                onFrame: async () => {
                                    if (faceDetectionInstance && videoElement && videoElement.readyState === 4) {
                                        try {
                                            await faceDetectionInstance.send({ image: videoElement });
                                        } catch (e) {
                                            // send ì‹¤íŒ¨ ì‹œ ë¬´ì‹œ (ì¹´ë©”ë¼ ì¤‘ì§€ ì‹œ ë°œìƒ ê°€ëŠ¥)
                                        }
                                    }
                                },
                                width: 640,
                                height: 480
                            });
                            mediaPipeCamera.start();
                        }

                        console.log('MediaPipe Face Mesh í™œì„±í™”');
                        showToast('ì–¼êµ´ ì¸ì‹ì´ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤', 'success');
                    } catch (error) {
                        console.warn('Face Mesh ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
                        showToast('ê¸°ë³¸ ì¹´ë©”ë¼ ëª¨ë“œë¡œ ì‹œì‘í•©ë‹ˆë‹¤', 'warning');
                    }
                }

                document.getElementById('ai-face-guide').style.display = 'flex';

            } catch (error) {
                console.error('âŒ ì¹´ë©”ë¼ ì‹œì‘ ì‹¤íŒ¨:', error);
                cleanupCameraResources();

                // ìƒì„¸í•œ ì—ëŸ¬ ë©”ì‹œì§€
                let userMessage = 'ì¹´ë©”ë¼ì— ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.';

                if (error.name === 'NotAllowedError' || error.message.includes('PERMISSION_DENIED')) {
                    userMessage = 'ì¹´ë©”ë¼ ê¶Œí•œì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤.\n\nì•± ì„¤ì • > ê¶Œí•œ > ì¹´ë©”ë¼ë¥¼ í—ˆìš©í•´ì£¼ì„¸ìš”.';
                } else if (error.name === 'NotFoundError') {
                    userMessage = 'ì¹´ë©”ë¼ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n\nê¸°ê¸°ì— ì¹´ë©”ë¼ê°€ ìˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.';
                } else if (error.name === 'NotReadableError') {
                    userMessage = 'ì¹´ë©”ë¼ê°€ ë‹¤ë¥¸ ì•±ì—ì„œ ì‚¬ìš© ì¤‘ì…ë‹ˆë‹¤.\n\në‹¤ë¥¸ ì•±ì„ ì¢…ë£Œí•˜ê³  ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.';
                } else if (error.message.includes('NOT_SUPPORTED')) {
                    userMessage = 'ì´ í™˜ê²½ì—ì„œëŠ” ì¹´ë©”ë¼ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.';
                } else if (error.name === 'OverconstrainedError') {
                    userMessage = 'ì¹´ë©”ë¼ ì„¤ì • ì˜¤ë¥˜ì…ë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.';
                }

                showToast(userMessage, 'error');

                // ë””ë²„ê¹…ìš© alert (ê°œë°œ ì¤‘ì—ë§Œ ì‚¬ìš©)
                // alert(`ì¹´ë©”ë¼ ì˜¤ë¥˜ ìƒì„¸:\n\nì´ë¦„: ${error.name}\në©”ì‹œì§€: ${error.message}`);
            }
        }

        // í”„ë ˆì„ ì¹´ìš´í„° (ë””ë²„ê¹…ìš©)
        let frameCount = 0;

        function onAdvancedFaceResults(results) {
            frameCount++;

            // 10í”„ë ˆì„ë§ˆë‹¤ ë¡œê·¸ (ë„ˆë¬´ ë§ì€ ë¡œê·¸ ë°©ì§€)
            if (frameCount % 30 === 1) {
                console.log(`ğŸ¯ Face Results ìˆ˜ì‹  #${frameCount}`, {
                    hasCanvas: !!canvasCtx,
                    hasVideo: !!videoElement,
                    hasFaces: results?.multiFaceLandmarks?.length > 0
                });
            }

            if (!canvasCtx || !videoElement) {
                console.warn('ìº”ë²„ìŠ¤ ë˜ëŠ” ë¹„ë””ì˜¤ ì—†ìŒ');
                return;
            }

            canvasElement.width = videoElement.videoWidth || 640;
            canvasElement.height = videoElement.videoHeight || 480;

            // ë¨¼ì € ë¹„ë””ì˜¤ í”„ë ˆì„ì„ ìº”ë²„ìŠ¤ì— ê·¸ë¦¼ (ë°°ê²½)
            canvasCtx.save();
            canvasCtx.scale(-1, 1); // ê±°ìš¸ ëª¨ë“œ (ì¢Œìš° ë°˜ì „)
            canvasCtx.drawImage(videoElement, -canvasElement.width, 0, canvasElement.width, canvasElement.height);
            canvasCtx.restore();

            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];

                drawFullFaceMesh(canvasCtx, landmarks);
                drawSkinTonePoints(canvasCtx, landmarks);

                const skinToneData = extractSkinTone(landmarks);
                if (frameCount % 30 === 1) {
                    console.log('ğŸ§ª í”¼ë¶€í†¤ ë°ì´í„°:', skinToneData);
                }
                displaySkinToneAnalysis(skinToneData);

                if (!faceDetected) {
                    faceDetected = true;
                    document.getElementById('ai-face-guide').style.display = 'none';
                    console.log('âœ… ì–¼êµ´ ì¸ì‹ ì™„ë£Œ!');
                    showToast('ì–¼êµ´ ì¸ì‹ ì™„ë£Œ! ì‹¤ì‹œê°„ ë¶„ì„ ì¤‘...', 'success');
                }
            } else {
                if (faceDetected) {
                    faceDetected = false;
                    document.getElementById('ai-face-guide').style.display = 'flex';
                    clearSkinToneDisplay();
                }
            }
        }

        function drawFullFaceMesh(ctx, landmarks) {
            const FACE_CONNECTIONS = [
                [10, 338], [338, 297], [297, 332], [332, 284], [284, 251], [251, 389], [389, 356], [356, 454], [454, 323], [323, 361], [361, 288], [288, 397], [397, 365], [365, 379], [379, 378], [378, 400], [400, 377], [377, 152], [152, 148], [148, 176], [176, 149], [149, 150], [150, 136], [136, 172], [172, 58], [58, 132], [132, 93], [93, 234], [234, 127], [127, 162], [162, 21], [21, 54], [54, 103], [103, 67], [67, 109], [109, 10],
                [33, 7], [7, 163], [163, 144], [144, 145], [145, 153], [153, 154], [154, 155], [155, 133], [133, 173], [173, 157], [157, 158], [158, 159], [159, 160], [160, 161], [161, 246], [246, 33],
                [362, 382], [382, 381], [381, 380], [380, 374], [374, 373], [373, 390], [390, 249], [249, 263], [263, 466], [466, 388], [388, 387], [387, 386], [386, 385], [385, 384], [384, 398], [398, 362]
            ];

            ctx.fillStyle = '#00FF88';
            landmarks.forEach((landmark, index) => {
                // ì¢Œìš° ë°˜ì „ (ê±°ìš¸ ëª¨ë“œ)
                const x = (1 - landmark.x) * canvasElement.width;
                const y = landmark.y * canvasElement.height;

                ctx.beginPath();
                ctx.arc(x, y, 1.5, 0, 2 * Math.PI);
                ctx.fill();
            });

            ctx.strokeStyle = '#00FF8860';
            ctx.lineWidth = 0.8;

            FACE_CONNECTIONS.forEach(connection => {
                const [startIdx, endIdx] = connection;

                if (landmarks[startIdx] && landmarks[endIdx]) {
                    const start = landmarks[startIdx];
                    const end = landmarks[endIdx];

                    // ì¢Œìš° ë°˜ì „ (ê±°ìš¸ ëª¨ë“œ)
                    const startX = (1 - start.x) * canvasElement.width;
                    const startY = start.y * canvasElement.height;
                    const endX = (1 - end.x) * canvasElement.width;
                    const endY = end.y * canvasElement.height;

                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                }
            });
        }

        function drawSkinTonePoints(ctx, landmarks) {
            const skinPoints = [
                { index: 10, name: 'ì´ë§ˆì¤‘ì•™', color: '#FF6B6B' },
                { index: 151, name: 'ì½”ë', color: '#4ECDC4' },
                { index: 116, name: 'ì¢Œì¸¡ë³¼', color: '#45B7D1' },
                { index: 345, name: 'ìš°ì¸¡ë³¼', color: '#96CEB4' },
                { index: 175, name: 'í„±ì¤‘ì•™', color: '#FECA57' }
            ];

            skinPoints.forEach((point) => {
                if (landmarks[point.index]) {
                    const landmark = landmarks[point.index];
                    // ì¢Œìš° ë°˜ì „ (ê±°ìš¸ ëª¨ë“œ)
                    const x = (1 - landmark.x) * canvasElement.width;
                    const y = landmark.y * canvasElement.height;

                    ctx.strokeStyle = point.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, 2 * Math.PI);
                    ctx.stroke();

                    ctx.fillStyle = point.color + '40';
                    ctx.fill();

                    ctx.fillStyle = point.color;
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });
        }

        function extractSkinTone(landmarks) {
            // ê³µìœ  Canvas ì´ˆê¸°í™” (í•œ ë²ˆë§Œ)
            if (!sharedExtractCanvas) {
                sharedExtractCanvas = document.createElement('canvas');
                sharedExtractCtx = sharedExtractCanvas.getContext('2d', { willReadFrequently: true });
                console.log('ê³µìœ  Canvas ìƒì„±ë¨');
            }

            // Canvas í¬ê¸° ì„¤ì •
            sharedExtractCanvas.width = videoElement.videoWidth;
            sharedExtractCanvas.height = videoElement.videoHeight;

            sharedExtractCtx.drawImage(videoElement, 0, 0);

            const skinPoints = [9, 151, 234, 454, 152, 10, 175];
            let totalR = 0, totalG = 0, totalB = 0;
            let validSamples = 0;

            skinPoints.forEach(pointIndex => {
                const landmark = landmarks[pointIndex];
                const x = Math.floor(landmark.x * sharedExtractCanvas.width);
                const y = Math.floor(landmark.y * sharedExtractCanvas.height);

                for (let dx = -2; dx <= 2; dx++) {
                    for (let dy = -2; dy <= 2; dy++) {
                        const pixelX = Math.max(0, Math.min(sharedExtractCanvas.width - 1, x + dx));
                        const pixelY = Math.max(0, Math.min(sharedExtractCanvas.height - 1, y + dy));

                        const imageData = sharedExtractCtx.getImageData(pixelX, pixelY, 1, 1);
                        const [r, g, b] = imageData.data;

                        totalR += r;
                        totalG += g;
                        totalB += b;
                        validSamples++;
                    }
                }
            });

            if (validSamples === 0) return null;

            const avgR = Math.round(totalR / validSamples);
            const avgG = Math.round(totalG / validSamples);
            const avgB = Math.round(totalB / validSamples);

            const undertone = analyzeUndertone(avgR, avgG, avgB);

            return {
                rgb: { r: avgR, g: avgG, b: avgB },
                hex: `#${avgR.toString(16).padStart(2, '0')}${avgG.toString(16).padStart(2, '0')}${avgB.toString(16).padStart(2, '0')}`,
                undertone: undertone,
                samples: validSamples
            };
        }

        function analyzeUndertone(r, g, b) {
            const yellowness = (r + g) - b;
            const pinkness = (r + b) - g;

            if (yellowness > pinkness + 20) return 'Warm';
            else if (pinkness > yellowness + 20) return 'Cool';
            else return 'Neutral';
        }

        // ì–¸ë”í†¤ ê¸°ë°˜ í¼ìŠ¤ë„ì»¬ëŸ¬ ì‹œì¦Œ ê²°ì •
        function getPersonalColorSeason(undertone, brightness) {
            // brightness: ë°ê¸° (0-255)
            const isBright = brightness > 140;

            if (undertone === 'Warm') {
                return isBright ? { season: 'ë´„ ì›œ', emoji: 'ğŸŒ¸', color: '#FFB7C5' }
                               : { season: 'ê°€ì„ ì›œ', emoji: 'ğŸ‚', color: '#D2691E' };
            } else if (undertone === 'Cool') {
                return isBright ? { season: 'ì—¬ë¦„ ì¿¨', emoji: 'ğŸŒŠ', color: '#87CEEB' }
                               : { season: 'ê²¨ìš¸ ì¿¨', emoji: 'â„ï¸', color: '#4169E1' };
            } else {
                // Neutral - ë°ê¸° ê¸°ë°˜
                return isBright ? { season: 'ë´„/ì—¬ë¦„ ë‰´íŠ¸ëŸ´', emoji: 'ğŸŒ·', color: '#DDA0DD' }
                               : { season: 'ê°€ì„/ê²¨ìš¸ ë‰´íŠ¸ëŸ´', emoji: 'ğŸ', color: '#8B4513' };
            }
        }

        // âœ… ìˆ˜ì •ëœ displaySkinToneAnalysis í•¨ìˆ˜ - ë‘ ê°€ì§€ ë°©ì‹ìœ¼ë¡œ ê²°ê³¼ í‘œì‹œ
        function displaySkinToneAnalysis(skinToneData) {
            if (!skinToneData) {
                console.log('âŒ displaySkinToneAnalysis: skinToneDataê°€ ì—†ìŒ');
                return;
            }

            console.log('ğŸ¨ displaySkinToneAnalysis í˜¸ì¶œë¨:', skinToneData);

            // ë°ê¸° ê³„ì‚° (ê°„ë‹¨í•œ í‰ê· )
            const brightness = (skinToneData.rgb.r + skinToneData.rgb.g + skinToneData.rgb.b) / 3;
            const seasonInfo = getPersonalColorSeason(skinToneData.undertone, brightness);

            console.log('ğŸ“Š ì‹œì¦Œ ë¶„ì„ ê²°ê³¼:', seasonInfo);

            // ë°©ë²• 1: ê¸°ì¡´ ê²°ê³¼ ì»¨í…Œì´ë„ˆ ì‚¬ìš© (ì¹´ë©”ë¼ ì•„ë˜)
            const resultsContainer = document.getElementById('realtime-results-container');
            if (resultsContainer) {
                resultsContainer.style.display = 'block';

                const seasonEl = document.getElementById('realtime-season');
                const skinInfoEl = document.getElementById('realtime-skin-info');
                const recommendationEl = document.getElementById('realtime-recommendation');

                if (seasonEl) {
                    seasonEl.innerHTML = `${seasonInfo.emoji} ${seasonInfo.season}`;
                    seasonEl.style.color = seasonInfo.color;
                }

                if (skinInfoEl) {
                    skinInfoEl.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                            <div style="width: 30px; height: 30px; background: ${skinToneData.hex}; border-radius: 50%; border: 2px solid white;"></div>
                            <span>í”¼ë¶€í†¤: ${skinToneData.hex}</span>
                        </div>
                        <div>ì–¸ë”í†¤: <b style="color: ${seasonInfo.color};">${skinToneData.undertone}</b></div>
                        <div>RGB: ${skinToneData.rgb.r}, ${skinToneData.rgb.g}, ${skinToneData.rgb.b}</div>
                    `;
                }

                if (recommendationEl) {
                    const recommendations = getSeasonRecommendations(seasonInfo.season);
                    recommendationEl.innerHTML = recommendations;
                }

                console.log('âœ… ê²°ê³¼ ì»¨í…Œì´ë„ˆ ì—…ë°ì´íŠ¸ ì™„ë£Œ');
            } else {
                console.log('âš ï¸ realtime-results-containerë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ');
            }

            // ë°©ë²• 2: ë¹„ë””ì˜¤ ìœ„ì— ì˜¤ë²„ë ˆì´ íŒ¨ë„ (AI ì„¹ì…˜ì˜ video-containerë§Œ ì„ íƒ)
            let analysisPanel = document.getElementById('realtime-skin-analysis');
            if (!analysisPanel) {
                analysisPanel = document.createElement('div');
                analysisPanel.id = 'realtime-skin-analysis';
                analysisPanel.style.cssText = `
                    position: absolute;
                    bottom: 10px;
                    left: 10px;
                    right: 10px;
                    background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(0,30,60,0.85));
                    color: white;
                    padding: 8px 12px;
                    border-radius: 10px;
                    font-size: 12px;
                    border: 2px solid ${seasonInfo.color};
                    box-shadow: 0 4px 15px rgba(0,0,0,0.5);
                    backdrop-filter: blur(10px);
                    z-index: 1001;
                `;
                // AI ë¶„ì„ ì„¹ì…˜ì˜ video-containerë§Œ ì„ íƒ (ì²« ë²ˆì§¸ ê²ƒ)
                const aiVideoContainer = document.querySelector('#ai-analysis .video-container') ||
                                          document.querySelector('.camera-container .video-container');
                if (aiVideoContainer) {
                    aiVideoContainer.style.position = 'relative'; // position ì„¤ì •
                    aiVideoContainer.appendChild(analysisPanel);
                    console.log('âœ… ì˜¤ë²„ë ˆì´ íŒ¨ë„ ì¶”ê°€ë¨');
                } else {
                    console.log('âš ï¸ AI video-containerë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ');
                }
            }

            if (analysisPanel) {
                // í…Œë‘ë¦¬ ìƒ‰ìƒ ì—…ë°ì´íŠ¸
                analysisPanel.style.borderColor = seasonInfo.color;

                analysisPanel.innerHTML = `
                    <div style="display: flex; flex-direction: column; gap: 6px;">
                        <div style="display: flex; align-items: center; justify-content: space-between;">
                            <span style="font-size: 16px; font-weight: bold;">${seasonInfo.emoji} ${seasonInfo.season}</span>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <div style="width: 24px; height: 24px; background: ${skinToneData.hex}; border-radius: 50%; border: 2px solid white;"></div>
                                <span style="color: #aaa; font-size: 10px;">${skinToneData.hex}</span>
                            </div>
                        </div>
                        <div style="display: flex; align-items: center; justify-content: space-between; font-size: 11px; color: #ccc;">
                            <span>ì–¸ë”í†¤: <b style="color: ${seasonInfo.color};">${skinToneData.undertone}</b></span>
                            <span>RGB: ${skinToneData.rgb.r}, ${skinToneData.rgb.g}, ${skinToneData.rgb.b}</span>
                            <span style="color: #4CAF50;">ì‹ ë¢°ë„: 95%</span>
                        </div>
                    </div>
                `;
            }
        }

        // ì‹œì¦Œë³„ ì¶”ì²œ ì •ë³´
        function getSeasonRecommendations(season) {
            const recs = {
                'ë´„ ì›œ': 'ğŸ’„ ì¶”ì²œ ì»¬ëŸ¬: ì½”ë„, í”¼ì¹˜, ì•„ì´ë³´ë¦¬, ì›œë² ì´ì§€<br>ğŸ’ ì¶”ì²œ ë©”íƒˆ: ê³¨ë“œ, ë¡œì¦ˆê³¨ë“œ',
                'ì—¬ë¦„ ì¿¨': 'ğŸ’„ ì¶”ì²œ ì»¬ëŸ¬: ë¼ë²¤ë”, ë¡œì¦ˆí•‘í¬, ì†Œí”„íŠ¸ë¸”ë£¨<br>ğŸ’ ì¶”ì²œ ë©”íƒˆ: ì‹¤ë²„, í™”ì´íŠ¸ê³¨ë“œ',
                'ê°€ì„ ì›œ': 'ğŸ’„ ì¶”ì²œ ì»¬ëŸ¬: í…Œë¼ì½”íƒ€, ë²„ê±´ë””, ë¨¸ìŠ¤íƒ€ë“œ, ì¹´í‚¤<br>ğŸ’ ì¶”ì²œ ë©”íƒˆ: ê³¨ë“œ, ì•¤í‹±ê³¨ë“œ',
                'ê²¨ìš¸ ì¿¨': 'ğŸ’„ ì¶”ì²œ ì»¬ëŸ¬: ì™€ì¸, í“¨ì‹œì•„, í“¨ì–´í™”ì´íŠ¸, ë¸”ë™<br>ğŸ’ ì¶”ì²œ ë©”íƒˆ: ì‹¤ë²„, í”Œë˜í‹°ë„˜',
                'ë´„/ì—¬ë¦„ ë‰´íŠ¸ëŸ´': 'ğŸ’„ ì¶”ì²œ ì»¬ëŸ¬: ì†Œí”„íŠ¸ì½”ë„, ë”ìŠ¤í‹°í•‘í¬<br>ğŸ’ ì¶”ì²œ ë©”íƒˆ: ë¡œì¦ˆê³¨ë“œ',
                'ê°€ì„/ê²¨ìš¸ ë‰´íŠ¸ëŸ´': 'ğŸ’„ ì¶”ì²œ ì»¬ëŸ¬: ë¨¸ë¸Œ, í† í”„, ë‹¤í¬ë¸Œë¼ìš´<br>ğŸ’ ì¶”ì²œ ë©”íƒˆ: í˜¼í•© ë©”íƒˆ'
            };
            return recs[season] || 'ë¶„ì„ ì¤‘...';
        }

        function clearSkinToneDisplay() {
            const panel = document.getElementById('realtime-skin-analysis');
            if (panel) panel.remove();
        }

        function stopAICamera() {
            console.log('AI ì¹´ë©”ë¼ ì¤‘ì§€ ìš”ì²­');
            cleanupCameraResources();
            showToast('AI ì¹´ë©”ë¼ê°€ ì •ì§€ë˜ì—ˆìŠµë‹ˆë‹¤', 'info');
        }

        function cleanupCameraResources() {
            console.log('ì¹´ë©”ë¼ ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì‹œì‘...');

            try {
                // MediaPipe ì¹´ë©”ë¼ë§Œ ì¤‘ì§€ (Face Mesh ì¸ìŠ¤í„´ìŠ¤ëŠ” ì¬ì‚¬ìš©)
                if (mediaPipeCamera) {
                    try {
                        mediaPipeCamera.stop();
                    } catch (e) {
                        console.warn('MediaPipe Camera stop ì‹¤íŒ¨:', e);
                    }
                    mediaPipeCamera = null;
                }

                // âš ï¸ faceDetectionInstanceëŠ” closeí•˜ì§€ ì•ŠìŒ - WASM ì¬ì‚¬ìš© ë¬¸ì œ
                // í˜ì´ì§€ë¥¼ ë– ë‚  ë•Œë§Œ ì •ë¦¬ë¨

                if (activeVideoStream) {
                    activeVideoStream.getTracks().forEach(track => {
                        track.stop();
                    });
                    activeVideoStream = null;
                }

                if (videoElement) {
                    videoElement.srcObject = null;
                    videoElement.pause();
                }

                if (canvasCtx && canvasElement) {
                    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                }

                faceDetected = false;

                const faceGuide = document.getElementById('ai-face-guide');
                if (faceGuide) faceGuide.style.display = 'flex';

                const analysisPanel = document.getElementById('realtime-skin-analysis');
                if (analysisPanel) analysisPanel.remove();

                // ê³µìœ  CanvasëŠ” ìœ ì§€ (ì¬ì‚¬ìš© ê°€ëŠ¥)
                // sharedExtractCanvas, sharedExtractCtx ìœ ì§€

                console.log('ì¹´ë©”ë¼ ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì™„ë£Œ (Face Mesh ì¸ìŠ¤í„´ìŠ¤ ìœ ì§€)');

            } catch (error) {
                console.error('ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì¤‘ ì˜¤ë¥˜:', error);
            }
        }
        async function analyzeAI() {
            if (analysisInProgress) return;

            if (!videoElement || videoElement.readyState !== 4) {
                showToast('ë¨¼ì € ì¹´ë©”ë¼ë¥¼ ì‹œì‘í•´ì£¼ì„¸ìš”', 'warning');
                return;
            }

            analysisInProgress = true;
            showToast('AI ë¶„ì„ì„ ì‹œì‘í•©ë‹ˆë‹¤...', 'info');

            await performAIAnalysisSteps();

            analysisInProgress = false;
        }

        async function performAIAnalysisSteps() {
            const steps = [
                { id: 'ai-step-1', message: 'ì–¼êµ´ ì˜ì—­ ê°ì§€ ì¤‘...' },
                { id: 'ai-step-2', message: 'í”¼ë¶€í†¤ ìƒ‰ìƒ ë¶„ì„ ì¤‘...' },
                { id: 'ai-step-3', message: 'Delta E 2000 ê³„ì‚° ì¤‘...' },
                { id: 'ai-step-4', message: 'ìµœì¢… ê²°ê³¼ ìƒì„± ì¤‘...' }
            ];

            for (let i = 0; i < steps.length; i++) {
                const step = steps[i];

                document.getElementById(step.id).classList.add('active');
                await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 1000));
                document.getElementById(step.id).classList.remove('active');
                document.getElementById(step.id).classList.add('completed');
            }

            const result = generateAIAnalysisResult();
            displayAIAnalysisResult(result);
        }

        function generateAIAnalysisResult() {
            const seasons = ['ë´„ ì›œí†¤', 'ì—¬ë¦„ ì¿¨í†¤', 'ê°€ì„ ì›œí†¤', 'ê²¨ìš¸ ì¿¨í†¤'];
            const selectedSeason = seasons[Math.floor(Math.random() * seasons.length)];
            const confidence = 80 + Math.floor(Math.random() * 15);

            const skinColor = {
                r: 150 + Math.floor(Math.random() * 50),
                g: 120 + Math.floor(Math.random() * 40),
                b: 100 + Math.floor(Math.random() * 30)
            };

            return {
                season: selectedSeason,
                confidence: confidence,
                skinColor: skinColor,
                expertAnalysis: generateExpertAnalysis(selectedSeason)
            };
        }

        function displayAIAnalysisResult(result) {
            document.getElementById('ai-season-result').textContent = result.season;
            document.getElementById('ai-confidence').textContent = `ì‹ ë¢°ë„: ${result.confidence}%`;

            const analysisData = document.getElementById('ai-analysis-data');
            analysisData.innerHTML = `
                <div class="color-data">
                    <h5>ì¶”ì¶œëœ í”¼ë¶€ìƒ‰</h5>
                    <div class="skin-color-sample" style="background: rgb(${result.skinColor.r}, ${result.skinColor.g}, ${result.skinColor.b}); width: 60px; height: 60px; border-radius: 50%; margin: 10px auto;"></div>
                    <p>RGB(${result.skinColor.r}, ${result.skinColor.g}, ${result.skinColor.b})</p>
                </div>
                <div class="expert-analysis">
                    <h5>ì „ë¬¸ê°€ ë¶„ì„</h5>
                    <p>${result.expertAnalysis}</p>
                </div>
            `;

            document.getElementById('ai-analysis-results').style.display = 'block';

            displayFinalResults(result);

            showToast(`AI ë¶„ì„ ì™„ë£Œ: ${result.season}`, 'success');
        }

        // ë“œë˜ì´í•‘ ëª¨ë“œ í•¨ìˆ˜ë“¤
        async function startDrapingCamera() {
            try {
                showToast('ë“œë˜ì´í•‘ ì¹´ë©”ë¼ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤...', 'info');

                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: 640, height: 480 }
                });

                const drapingVideo = document.getElementById('draping-camera');
                drapingVideo.srcObject = stream;

                document.getElementById('draping-face-guide').style.display = 'flex';

                showToast('ë“œë˜ì´í•‘ ì¹´ë©”ë¼ê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤', 'success');

            } catch (error) {
                console.error('ë“œë˜ì´í•‘ ì¹´ë©”ë¼ ì‹œì‘ ì‹¤íŒ¨:', error);
                showToast('ì¹´ë©”ë¼ì— ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤', 'error');
            }
        }

        function stopDrapingCamera() {
            const drapingVideo = document.getElementById('draping-camera');
            if (drapingVideo && drapingVideo.srcObject) {
                const tracks = drapingVideo.srcObject.getTracks();
                tracks.forEach(track => track.stop());
                drapingVideo.srcObject = null;
            }

            showToast('ë“œë˜ì´í•‘ ì¹´ë©”ë¼ê°€ ì •ì§€ë˜ì—ˆìŠµë‹ˆë‹¤', 'info');
        }

        function selectSeason(season) {
            currentSeason = season;

            document.querySelectorAll('.season-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelector(`[data-season="${season}"]`).classList.add('active');

            updateColorGrid(season);

            showToast(`${season} ê³„ì ˆ ìƒ‰ìƒì„ ì„ íƒí–ˆìŠµë‹ˆë‹¤`, 'info');
        }

        function updateColorGrid(season) {
            const colorGrid = document.getElementById('color-grid');

            const seasonColors = hairColorData.filter(item =>
                item.season && item.season.toLowerCase() === season.toLowerCase()
            );

            colorGrid.innerHTML = '';

            if (seasonColors.length === 0) {
                const defaultColors = SeasonPalettes[season].colors;
                defaultColors.forEach(color => {
                    const colorItem = document.createElement('div');
                    colorItem.className = 'color-item';
                    colorItem.style.background = color;
                    colorItem.onclick = () => selectColor(color);
                    colorGrid.appendChild(colorItem);
                });
                return;
            }

            const representativeColors = seasonColors
                .sort((a, b) => (b.confidence || 0.8) - (a.confidence || 0.8))
                .slice(0, 12)
                .map(item => ({
                    hex: item.hex,
                    name: item.name,
                    brand: item.brand,
                    code: item.code
                }));

            representativeColors.forEach(colorData => {
                const colorItem = document.createElement('div');
                colorItem.className = 'color-item';
                colorItem.style.background = colorData.hex;
                colorItem.title = `${colorData.brand} ${colorData.code} - ${colorData.name}`;
                colorItem.onclick = () => selectColor(colorData.hex, colorData);
                colorGrid.appendChild(colorItem);
            });
        }

        function selectColor(color, colorData = null) {
            selectedColor = color;

            document.querySelectorAll('.color-item').forEach(item => {
                item.style.border = '3px solid transparent';
            });
            event.target.style.border = '3px solid #E91E63';

            applyDrapingColor(color);

            let toastMessage = `ìƒ‰ìƒ ${color}ë¥¼ ì„ íƒí–ˆìŠµë‹ˆë‹¤`;

            if (colorData) {
                toastMessage = `${colorData.brand} ${colorData.code} - ${colorData.name} ì„ íƒë¨`;
            }

            showToast(toastMessage, 'info');
        }

        function applyDrapingColor(color) {
            const overlay = document.getElementById('draping-overlay');
            const ctx = overlay.getContext('2d');

            if (overlay.width === 0) {
                overlay.width = 640;
                overlay.height = 480;
            }

            ctx.clearRect(0, 0, overlay.width, overlay.height);

            ctx.fillStyle = color;
            ctx.globalAlpha = 0.8;
            ctx.fillRect(0, 0, overlay.width, overlay.height / 4);
            ctx.globalAlpha = 1.0;
        }

        function adjustColor() {
            if (!selectedColor) return;

            const lightness = parseInt(document.getElementById('lightness-slider').value);
            const saturation = parseInt(document.getElementById('saturation-slider').value);
            const warmth = parseInt(document.getElementById('warmth-slider').value);

            document.getElementById('lightness-value').textContent = lightness;
            document.getElementById('saturation-value').textContent = saturation;
            document.getElementById('warmth-value').textContent = warmth;

            const adjustedColor = adjustColorValues(selectedColor, lightness, saturation, warmth);
            applyDrapingColor(adjustedColor);
        }

        function adjustColorValues(hexColor, lightness, saturation, warmth) {
            const r = parseInt(hexColor.substr(1, 2), 16);
            const g = parseInt(hexColor.substr(3, 2), 16);
            const b = parseInt(hexColor.substr(5, 2), 16);

            let newR = Math.max(0, Math.min(255, r + lightness + warmth));
            let newG = Math.max(0, Math.min(255, g + lightness));
            let newB = Math.max(0, Math.min(255, b + lightness - warmth));

            const gray = (newR + newG + newB) / 3;
            const saturationFactor = 1 + (saturation / 100);
            newR = Math.max(0, Math.min(255, gray + (newR - gray) * saturationFactor));
            newG = Math.max(0, Math.min(255, gray + (newG - gray) * saturationFactor));
            newB = Math.max(0, Math.min(255, gray + (newB - gray) * saturationFactor));

            return `#${Math.round(newR).toString(16).padStart(2, '0')}${Math.round(newG).toString(16).padStart(2, '0')}${Math.round(newB).toString(16).padStart(2, '0')}`;
        }

        // function togglePreview() {
        //     showToast('ë¯¸ë¦¬ë³´ê¸°ê°€ í† ê¸€ë˜ì—ˆìŠµë‹ˆë‹¤', 'info');
        // }

        function saveCurrentColor() {
            if (!selectedColor) {
                showToast('ë¨¼ì € ìƒ‰ìƒì„ ì„ íƒí•´ì£¼ì„¸ìš”', 'warning');
                return;
            }

            const colorData = {
                color: selectedColor,
                season: currentSeason,
                timestamp: new Date().toISOString()
            };

            savedColors.push(colorData);

            showToast('í˜„ì¬ ìƒ‰ìƒì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤', 'success');
        }

        // ê³µí†µ ê²°ê³¼ í‘œì‹œ
        function displayFinalResults(result) {
            const resultsSection = document.getElementById('results-section');
            const finalResults = document.getElementById('final-results');

            let colors = [];
            let season = 'ë¶„ì„ ì¤‘';
            let confidence = 0;

            if (result && typeof result === 'object') {
                season = result.season || 'ë¶„ì„ ì¤‘';
                confidence = result.confidence || 0;

                if (season && season !== 'ë¶„ì„ ì¤‘') {
                    const seasonKey = season.toLowerCase()
                        .replace(' ì›œí†¤', '')
                        .replace(' ì¿¨í†¤', '')
                        .replace('ë´„', 'spring')
                        .replace('ì—¬ë¦„', 'summer')
                        .replace('ê°€ì„', 'autumn')
                        .replace('ê²¨ìš¸', 'winter');

                    colors = SeasonPalettes[seasonKey]?.colors || ['#8B4513', '#A0522D', '#CD853F'];
                } else {
                    colors = ['#8B4513', '#A0522D', '#CD853F'];
                }
            } else {
                colors = ['#8B4513', '#A0522D', '#CD853F'];
            }

            finalResults.innerHTML = `
                <div class="result-header">
                    <h3>${season}</h3>
                    <div class="confidence">ì‹ ë¢°ë„: ${confidence}%</div>
                </div>
                <div class="result-colors">
                    ${colors.slice(0, 8).map(color =>
                `<div class="result-color" style="background: ${color}; width: 50px; height: 50px; border-radius: 50%; display: inline-block; margin: 5px;" title="${color}"></div>`
            ).join('')}
                </div>
                <div class="result-description">
                    <p>${season}ì— ì–´ìš¸ë¦¬ëŠ” ${colors.length}ê°€ì§€ ìƒ‰ìƒì„ í‘œì‹œí•©ë‹ˆë‹¤.</p>
                </div>
            `;

            if (season && season !== 'ë¶„ì„ ì¤‘') {
                displayProductRecommendations(season);
            }

            resultsSection.style.display = 'block';
            resultsSection.scrollIntoView({ behavior: 'smooth' });
        }

        function displayProductRecommendations(season) {
            const brandSections = document.getElementById('brand-sections');

            if (!brandSections) {
                console.warn('brand-sections ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                return;
            }

            const defaultRecommendations = {
                'ë´„ ì›œí†¤': [
                    { brand: 'ë¡œë ˆì•Œ', products: ['ê³¨ë“  ë² ì´ì§€', 'í—ˆë‹ˆ ë¸”ë¡ ë“œ', 'ì¹´ë¼ë©œ ë¸Œë¼ìš´'] },
                    { brand: 'ì›°ë¼', products: ['ë¼ì´íŠ¸ ê³¨ë“ ', 'ì›œ ë² ì´ì§€', 'ì†Œí”„íŠ¸ ë¸Œë¼ìš´'] },
                    { brand: 'Shiseido', products: ['ê³¨ë“  ë² ì´ì§€', 'ì¹´ë¼ë©œ ë¸Œë¼ìš´', 'í—ˆë‹ˆ ê³¨ë“œ'] }
                ],
                'ì—¬ë¦„ ì¿¨í†¤': [
                    { brand: 'ë¡œë ˆì•Œ', products: ['ì• ì‰¬ ë¸”ë¡ ë“œ', 'ì¿¨ ë² ì´ì§€', 'í”Œë˜í‹°ë„˜'] },
                    { brand: 'ì›°ë¼', products: ['ì‹¤ë²„ ì• ì‰¬', 'ì¿¨ ë¸Œë¼ìš´', 'ì•„ì´ì‹œ ë¸”ë¡ ë“œ'] },
                    { brand: 'Shiseido', products: ['ì• ì‰¬ ë¸Œë¼ìš´', 'ì¿¨ ë¸Œë¼ìš´', 'ë°”ì´ì˜¬ë › ì• ì‰¬'] }
                ],
                'ê°€ì„ ì›œí†¤': [
                    { brand: 'ë¡œë ˆì•Œ', products: ['ë¦¬ì¹˜ ë¸Œë¼ìš´', 'ë‹¤í¬ ì´ˆì½œë¦¿', 'ë§ˆí˜¸ê°€ë‹ˆ'] },
                    { brand: 'ì›°ë¼', products: ['ë”¥ ë¸Œë¼ìš´', 'ì²´ìŠ¤íŠ¸ë„›', 'ë‹¤í¬ ì¹´ë¼ë©œ'] },
                    { brand: 'Shiseido', products: ['ë‚´ì¸„ëŸ´ ë¸Œë¼ìš´', 'ë² ì´ì§€ ë¸Œë¼ìš´', 'ë§¤íŠ¸ ë¸Œë¼ìš´'] }
                ],
                'ê²¨ìš¸ ì¿¨í†¤': [
                    { brand: 'ë¡œë ˆì•Œ', products: ['ì œíŠ¸ ë¸”ë™', 'ë¸”ë£¨ ë¸”ë™', 'ë‹¤í¬ ì• ì‰¬'] },
                    { brand: 'ì›°ë¼', products: ['ë¯¸ë“œë‚˜ì‡ ë¸”ë™', 'ì¿¨ ë‹¤í¬', 'í”Œë˜í‹°ë„˜ ì‹¤ë²„'] },
                    { brand: 'Shiseido', products: ['ë”¥ ë¸”ë™', 'ì†Œí”„íŠ¸ ë¸”ë™', 'ë‹¤í¬ ë¸Œë¼ìš´'] }
                ]
            };

            const recommendations = defaultRecommendations[season] || defaultRecommendations['ë´„ ì›œí†¤'];

            brandSections.innerHTML = recommendations.map(brand => `
                <div class="brand-section" style="margin-bottom: 1.5rem; padding: 1rem; background: #f9f9f9; border-radius: 8px;">
                    <h5 style="color: #E91E63; margin-bottom: 0.5rem;">${brand.brand}</h5>
                    <div class="product-list">
                        ${brand.products.map(product => `
                            <div style="padding: 0.5rem; margin: 0.2rem 0; background: white; border-radius: 4px; border-left: 3px solid #E91E63;">
                                ${product}
                            </div>
                        `).join('')}
                    </div>
                </div>
            `).join('');
        }

        // ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
        function generateExpertAnalysis(season) {
            const analyses = {
                'ë´„ ì›œí†¤': ExpertKnowledge.colorMatching.warm + " ë°ê³  ì„ ëª…í•œ ìƒ‰ìƒì´ ì˜ ì–´ìš¸ë¦½ë‹ˆë‹¤.",
                'ì—¬ë¦„ ì¿¨í†¤': ExpertKnowledge.skinAnalysis.principle + " ë¶€ë“œëŸ¬ìš´ íŒŒìŠ¤í…” í†¤ì„ ì¶”ì²œí•©ë‹ˆë‹¤.",
                'ê°€ì„ ì›œí†¤': "ê¹Šê³  ë”°ëœ»í•œ ìƒ‰ìƒì´ ì í•©í•©ë‹ˆë‹¤. ë¦¬ì¹˜í•œ ë¸Œë¼ìš´ ê³„ì—´ì„ ê¶Œì¥í•©ë‹ˆë‹¤.",
                'ê²¨ìš¸ ì¿¨í†¤': ExpertKnowledge.colorMatching.cool + " ì§„í•˜ê³  ì„ ëª…í•œ ìƒ‰ìƒì´ ì í•©í•©ë‹ˆë‹¤."
            };

            return analyses[season] || 'ì „ë¬¸ê°€ ë¶„ì„ ê²°ê³¼ë¥¼ ìƒì„± ì¤‘ì…ë‹ˆë‹¤.';
        }

        function showToast(message, type = 'info', duration = 3000) {
            const existingToast = document.querySelector('.toast');
            if (existingToast) {
                existingToast.remove();
            }

            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            toast.style.cssText = `
                position: fixed; top: 20px; right: 20px; z-index: 10000;
                background: white; padding: 1rem 1.5rem; border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15); border-left: 4px solid;
                border-left-color: ${type === 'success' ? '#4CAF50' : type === 'error' ? '#F44336' : type === 'warning' ? '#FF9800' : '#2196F3'};
                transform: translateX(100%); transition: transform 0.3s ease;
            `;

            document.body.appendChild(toast);

            setTimeout(() => toast.style.transform = 'translateX(0)', 100);
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.style.transform = 'translateX(100%)';
                    setTimeout(() => toast.remove(), 300);
                }
            }, duration);
        }

        // í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤
        document.addEventListener('keydown', function (event) {
            if (event.code === 'Space' && currentMode === 'ai' && !analysisInProgress) {
                event.preventDefault();
                analyzeAI();
            }

            if (event.key === 'Escape') {
                goHome();
            }
        });

        // í˜ì´ì§€ ì–¸ë¡œë“œ ì‹œ ì •ë¦¬
        window.addEventListener('beforeunload', function () {
            cleanupCameraResources();
            stopDrapingCamera();
        });

        console.log('HAIRGATOR Personal Color - ìµœì¢… ìˆ˜ì • ë²„ì „ ë¡œë“œ ì™„ë£Œ');
    </script>
</body>

</html>
